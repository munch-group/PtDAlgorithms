<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.31">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Rabbits (full API example) – ptdalgorithms</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js" integrity="sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==" crossorigin="anonymous"></script><script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-e1a5c8363afafaef2c763b6775fbf3ca.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-dde8d7229bfee0f8bb5efd37f0f9ae1e.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script src="../../site_libs/quarto-contrib/glightbox/glightbox.min.js"></script>
<link href="../../site_libs/quarto-contrib/glightbox/glightbox.min.css" rel="stylesheet">
<link href="../../site_libs/quarto-contrib/glightbox/lightbox.css" rel="stylesheet">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" integrity="sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==" crossorigin="anonymous"></script>

<script type="application/javascript">define('jquery', [],function() {return window.jQuery;})</script>


<link rel="stylesheet" href="../../api/_styles-quartodoc.css">
<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">ptdalgorithms</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../api/"> 
<span class="menu-text">Python API reference</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../r_api/"> 
<span class="menu-text">R API reference</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../c_api/"> 
<span class="menu-text">C API reference</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/munch-group/ptdalgorithms/"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#installing-the-ptdalgorithms-library" id="toc-installing-the-ptdalgorithms-library" class="nav-link active" data-scroll-target="#installing-the-ptdalgorithms-library">Installing the ptdalgorithms library</a></li>
  <li><a href="#state-space-construction" id="toc-state-space-construction" class="nav-link" data-scroll-target="#state-space-construction">State-space construction</a>
  <ul class="collapse">
  <li><a href="#continuous-phase-type-distribution" id="toc-continuous-phase-type-distribution" class="nav-link" data-scroll-target="#continuous-phase-type-distribution">Continuous phase-type distribution</a></li>
  </ul></li>
  <li><a href="#this-makes-the-kernel-die" id="toc-this-makes-the-kernel-die" class="nav-link" data-scroll-target="#this-makes-the-kernel-die">this makes the kernel die…</a>
  <ul class="collapse">
  <li><a href="#rewards" id="toc-rewards" class="nav-link" data-scroll-target="#rewards">Rewards</a></li>
  </ul></li>
  <li><a href="#random-sampling" id="toc-random-sampling" class="nav-link" data-scroll-target="#random-sampling">Random sampling</a>
  <ul class="collapse">
  <li><a href="#discrete-phase-type-distributions" id="toc-discrete-phase-type-distributions" class="nav-link" data-scroll-target="#discrete-phase-type-distributions">Discrete phase-type distributions</a></li>
  </ul></li>
  <li><a href="#multivariate-phase-type-distributions" id="toc-multivariate-phase-type-distributions" class="nav-link" data-scroll-target="#multivariate-phase-type-distributions">Multivariate phase-type distributions</a>
  <ul class="collapse">
  <li><a href="#parameterized-edges" id="toc-parameterized-edges" class="nav-link" data-scroll-target="#parameterized-edges">Parameterized edges</a></li>
  <li><a href="#time-inhomogeneity" id="toc-time-inhomogeneity" class="nav-link" data-scroll-target="#time-inhomogeneity">Time inhomogeneity</a></li>
  <li><a href="#building-the-state-space-in-c" id="toc-building-the-state-space-in-c" class="nav-link" data-scroll-target="#building-the-state-space-in-c">Building the state space in C</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Rabbits (full API example)</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p>This notebook will describe almost all functions of the ptdalgorithms Python package. The core functionality is implemented in C, with a binding layer to Python through C++ and pybind11. Except for the specified construction code of the state space, most code will be almost equally fast to invoking the C api directly (maybe twice as slow). The package is based on graph algorithms published in (…), and is many orders of magnitude faster than matrix-based equations which are usually applied. We do not recommend using the C++ api directly.</p>
<p>We will show how to install the package and construct a state space through the Python api. We will then show how to compute the moments (expectation, variance) through the ptdalgorithms package, and how to compute the distribution functions. This means that you can make discrete and continuous phase-type distributions, compute their moments, distribution functions, sample from them, compute rewards and multivariate distributions, and time inhomogenous distributions.</p>
<p>We will also show how easy it is to create the state-space in C and return it to Python, to make large graphs!</p>
<div id="cell-2" class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>load_ext autoreload</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>autoreload <span class="dv">2</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<section id="installing-the-ptdalgorithms-library" class="level2">
<h2 class="anchored" data-anchor-id="installing-the-ptdalgorithms-library">Installing the ptdalgorithms library</h2>
<p>Using conda (recommended):</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode txt code-with-copy"><code class="sourceCode default"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>conda install -c conda-forge -c munch-group ptdalgorithms</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Using pip:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode txt code-with-copy"><code class="sourceCode default"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>pip install ptdalgorithms</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div id="cell-6" class="cell" data-execution_count="5">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>np.random.seed(<span class="dv">42</span>)</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> seaborn <span class="im">as</span> sns</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a><span class="co"># plt.style.use('dark_background')</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a><span class="co"># import matplotlib</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a><span class="co"># matplotlib.rcParams['axes.facecolor'] = '#1F1F1F'</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a><span class="co"># matplotlib.rcParams['figure.facecolor'] = '#1F1F1F'</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a><span class="co">#%matplotlib widget</span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>config InlineBackend.figure_format <span class="op">=</span> <span class="st">'retina'</span></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> ptdalgorithms <span class="im">as</span> ptd</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="state-space-construction" class="level1">
<h1>State-space construction</h1>
<div id="cell-8" class="cell" data-execution_count="6">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> c(<span class="op">*</span>args):</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    elem <span class="op">=</span> []</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> arg <span class="kw">in</span> args:</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">hasattr</span>(arg, <span class="st">'__len__'</span>) <span class="kw">and</span> <span class="bu">len</span>(arg) <span class="op">&gt;</span> <span class="dv">1</span>:</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>            elem.extend(arg)</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>            elem.append(arg)</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.array(elem)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="cell-9" class="cell" data-execution_count="7">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> print_states(vertex):</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(vertex.state())</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> edge <span class="kw">in</span> vertex.edges():</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="st">" "</span>, edge.weight() , <span class="st">"-&gt;"</span>, edge.to().state())    </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>This phase-type distribution models the time until all rabits have died We can find the expectation, variance, moments</p>
<div id="cell-11" class="cell" data-execution_count="8">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> construct_rabbit_graph(nr_rabbits, flood_left, flood_right):</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>    <span class="co"># we represent the vector as two integers, the number of </span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>    <span class="co"># rabbits on the left and right island</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>    state_vector_length <span class="op">=</span> <span class="dv">2</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>    graph <span class="op">=</span> ptd.Graph(state_vector_length)</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>    <span class="co"># the initial state is the only starting state, with probability 1</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>    initial_state <span class="op">=</span> [nr_rabbits, <span class="dv">0</span>]</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>    vertex <span class="op">=</span> graph.find_or_create_vertex(initial_state)</span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>    graph.starting_vertex().add_edge(vertex, <span class="dv">1</span>)</span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>    index <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>    <span class="co"># iterate over all unvisited vertices</span></span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> index <span class="op">&lt;</span> graph.vertices_length():</span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a>        vertex <span class="op">=</span> graph.vertex_at(index)</span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a>        state <span class="op">=</span> vertex.state()</span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> state[<span class="dv">0</span>] <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a>            <span class="co"># rabbit jump left to right</span></span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true" tabindex="-1"></a>            child_state <span class="op">=</span> [state[<span class="dv">0</span>] <span class="op">-</span> <span class="dv">1</span>, state[<span class="dv">1</span>] <span class="op">+</span> <span class="dv">1</span>]</span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true" tabindex="-1"></a>            vertex.add_edge(</span>
<span id="cb7-23"><a href="#cb7-23" aria-hidden="true" tabindex="-1"></a>                graph.find_or_create_vertex(child_state),</span>
<span id="cb7-24"><a href="#cb7-24" aria-hidden="true" tabindex="-1"></a>                weight<span class="op">=</span><span class="dv">1</span></span>
<span id="cb7-25"><a href="#cb7-25" aria-hidden="true" tabindex="-1"></a>            )</span>
<span id="cb7-26"><a href="#cb7-26" aria-hidden="true" tabindex="-1"></a>            <span class="co"># left island flooding</span></span>
<span id="cb7-27"><a href="#cb7-27" aria-hidden="true" tabindex="-1"></a>            child_state <span class="op">=</span> [<span class="dv">0</span>, state[<span class="dv">1</span>]]</span>
<span id="cb7-28"><a href="#cb7-28" aria-hidden="true" tabindex="-1"></a>            vertex.add_edge(</span>
<span id="cb7-29"><a href="#cb7-29" aria-hidden="true" tabindex="-1"></a>                graph.find_or_create_vertex(child_state), </span>
<span id="cb7-30"><a href="#cb7-30" aria-hidden="true" tabindex="-1"></a>                weight<span class="op">=</span>flood_left</span>
<span id="cb7-31"><a href="#cb7-31" aria-hidden="true" tabindex="-1"></a>            )</span>
<span id="cb7-32"><a href="#cb7-32" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> state[<span class="dv">1</span>] <span class="op">&gt;</span> <span class="dv">0</span>:   </span>
<span id="cb7-33"><a href="#cb7-33" aria-hidden="true" tabindex="-1"></a>            child_state <span class="op">=</span> [state[<span class="dv">0</span>] <span class="op">+</span> <span class="dv">1</span>, state[<span class="dv">1</span>] <span class="op">-</span> <span class="dv">1</span>]</span>
<span id="cb7-34"><a href="#cb7-34" aria-hidden="true" tabindex="-1"></a>            vertex.add_edge(</span>
<span id="cb7-35"><a href="#cb7-35" aria-hidden="true" tabindex="-1"></a>                graph.find_or_create_vertex(child_state),</span>
<span id="cb7-36"><a href="#cb7-36" aria-hidden="true" tabindex="-1"></a>                weight<span class="op">=</span><span class="dv">1</span></span>
<span id="cb7-37"><a href="#cb7-37" aria-hidden="true" tabindex="-1"></a>            )</span>
<span id="cb7-38"><a href="#cb7-38" aria-hidden="true" tabindex="-1"></a>            <span class="co"># right island flooding</span></span>
<span id="cb7-39"><a href="#cb7-39" aria-hidden="true" tabindex="-1"></a>            child_state <span class="op">=</span> [state[<span class="dv">0</span>], <span class="dv">0</span>]</span>
<span id="cb7-40"><a href="#cb7-40" aria-hidden="true" tabindex="-1"></a>            vertex.add_edge(</span>
<span id="cb7-41"><a href="#cb7-41" aria-hidden="true" tabindex="-1"></a>                graph.find_or_create_vertex(child_state), </span>
<span id="cb7-42"><a href="#cb7-42" aria-hidden="true" tabindex="-1"></a>                weight<span class="op">=</span>flood_right</span>
<span id="cb7-43"><a href="#cb7-43" aria-hidden="true" tabindex="-1"></a>            )</span>
<span id="cb7-44"><a href="#cb7-44" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb7-45"><a href="#cb7-45" aria-hidden="true" tabindex="-1"></a>        index <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb7-46"><a href="#cb7-46" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> graph</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="cell-12" class="cell" data-execution_count="9">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>graph <span class="op">=</span> construct_rabbit_graph(<span class="dv">2</span>, <span class="dv">2</span>, <span class="dv">4</span>)        </span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>graph.states()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="9">
<pre><code>array([[0, 0],
       [2, 0],
       [1, 1],
       [0, 0],
       [0, 2],
       [0, 1],
       [1, 0]], dtype=int32)</code></pre>
</div>
</div>
<p>You can plot the graph for visual inspection:</p>
<div id="cell-14" class="cell" data-execution_count="10">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>graph.plot()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="10">
<div>
<figure class="figure">
<p><a href="rabbits_full_py_api_example_files/figure-html/cell-8-output-1.svg" class="lightbox" data-gallery="quarto-lightbox-gallery-1"><img src="rabbits_full_py_api_example_files/figure-html/cell-8-output-1.svg" class="img-fluid figure-img"></a></p>
</figure>
</div>
</div>
</div>
<p>and group, states by some property, by supplying a lambda function for the <code>subgraphfun</code> keyword argument:</p>
<div id="cell-16" class="cell" data-execution_count="11">
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>graph.plot(subgraphfun<span class="op">=</span><span class="kw">lambda</span> state: <span class="ss">f"#rabbits: </span><span class="sc">{</span><span class="bu">sum</span>(state)<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="11">
<div>
<figure class="figure">
<p><a href="rabbits_full_py_api_example_files/figure-html/cell-9-output-1.svg" class="lightbox" data-gallery="quarto-lightbox-gallery-2"><img src="rabbits_full_py_api_example_files/figure-html/cell-9-output-1.svg" class="img-fluid figure-img"></a></p>
</figure>
</div>
</div>
</div>
<p>In an abbreviated version using the aliases <code>ae</code> and <code>focv</code> for <code>add_edge</code> and <code>find_and_create_vertex</code></p>
<div id="cell-18" class="cell" data-execution_count="12">
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>nr_rabbits, flood_left, flood_right <span class="op">=</span> <span class="dv">2</span>, <span class="dv">2</span>, <span class="dv">4</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>graph <span class="op">=</span> ptd.Graph(<span class="dv">2</span>)</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>graph.starting_vertex().add_edge(graph.focv(c(nr_rabbits, <span class="dv">0</span>)), <span class="dv">1</span>)</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>i <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> i <span class="op">&lt;</span> graph.vertices_length():</span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>    v <span class="op">=</span> graph.vertex_at(i)</span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>    st <span class="op">=</span> v.state()</span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> st[<span class="dv">0</span>] <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>        v.ae(graph.focv([st[<span class="dv">0</span>]<span class="op">-</span><span class="dv">1</span>, st[<span class="dv">1</span>]<span class="op">+</span><span class="dv">1</span>]), <span class="dv">1</span>)</span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>        v.ae(graph.focv([<span class="dv">0</span>, st[<span class="dv">1</span>]]), flood_left)</span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> st[<span class="dv">1</span>] <span class="op">&gt;</span> <span class="dv">0</span>:   </span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a>        v.ae(graph.focv([st[<span class="dv">0</span>]<span class="op">+</span><span class="dv">1</span>, st[<span class="dv">1</span>]<span class="op">-</span><span class="dv">1</span>]), <span class="dv">1</span>)</span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a>        v.ae(graph.focv([st[<span class="dv">0</span>], <span class="dv">0</span>]), flood_right)</span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a>    i <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true" tabindex="-1"></a><span class="co">#graph.states()</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>You can skip some of the boilerplate code by passing a callback function and an initial state to <code>Graph</code>. The call back function has the signature <code>callback(List[int]) -&gt; List[Dict]</code>. It takes a list argument specifying a state and returns a list of dictionaries each specifying a child state and an edge weight: <code>{'state': [0, 1], 'weight': 0.4}</code>. This approach is slower and is intended mainly for speed up model development and exploration, and to reduce the amount of code needed to represent many models.</p>
<p>To create a callback function, just think of rules of your model and ask yourself: “Given some state, what are the allowed transitions to other states and with what rates to these transititons occur?”. Make a small dictionary for each such transition with the child state and rate (weight) and return them as a list. Here is an example. If the current state is “two rabbits on the left island” (<code>[2, 0]</code>), the reachable states are: “one rabbit on each island” (<code>[1, 1]</code>) if one rabbit jumps and and “no rabbits” (<code>[0, 0]</code>) if the island is flodded. The callback function should in that case produce the mapping:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>[<span class="dv">2</span>, <span class="dv">0</span>] <span class="op">-&gt;</span> [{<span class="st">'state'</span>: [<span class="dv">1</span>, <span class="dv">1</span>], <span class="st">'weight'</span>: <span class="dv">1</span>, }, {<span class="st">'state'</span>: [<span class="dv">0</span>, <span class="dv">0</span>], <span class="st">'weight'</span>: flood_left}]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Here is what the callback function looks like for the rabbit model:</p>
<div id="cell-20" class="cell" data-execution_count="13">
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> rabbit_islands(state):</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>    children <span class="op">=</span> []</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> state[<span class="dv">0</span>] <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>        children.append({<span class="st">'state'</span>: [state[<span class="dv">0</span>]<span class="op">-</span><span class="dv">1</span>, state[<span class="dv">1</span>]<span class="op">+</span><span class="dv">1</span>], <span class="st">'weight'</span>: <span class="dv">1</span>})</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>        children.append({<span class="st">'state'</span>: [<span class="dv">0</span>,          state[<span class="dv">1</span>]  ], <span class="st">'weight'</span>: flood_left})</span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> state[<span class="dv">1</span>] <span class="op">&gt;</span> <span class="dv">0</span>:   </span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>        children.append({<span class="st">'state'</span>: [state[<span class="dv">0</span>]<span class="op">+</span><span class="dv">1</span>, state[<span class="dv">1</span>]<span class="op">-</span><span class="dv">1</span>], <span class="st">'weight'</span>: <span class="dv">1</span>})</span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>        children.append({<span class="st">'state'</span>: [state[<span class="dv">0</span>],   <span class="dv">0</span>         ], <span class="st">'weight'</span>: flood_right})</span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> children</span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a>initial_state <span class="op">=</span> [nr_rabbits, <span class="dv">0</span>]    </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Notice that the usual scoping rules apply to the callback functions: the variables defined outside the function <code>flood_left</code> and <code>flood_right</code> are accessible to the function as for any Python function.</p>
<div id="cell-22" class="cell" data-execution_count="14">
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>graph <span class="op">=</span> ptd.Graph(callback<span class="op">=</span>rabbit_islands,</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>                  initial<span class="op">=</span>initial_state,</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>                  trans_as_dict<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>graph.plot()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="14">
<div>
<figure class="figure">
<p><a href="rabbits_full_py_api_example_files/figure-html/cell-12-output-1.svg" class="lightbox" data-gallery="quarto-lightbox-gallery-3"><img src="rabbits_full_py_api_example_files/figure-html/cell-12-output-1.svg" class="img-fluid figure-img"></a></p>
</figure>
</div>
</div>
</div>
<p>Notice <code>trans_as_dict=True</code> keyword argument above. To play more nicely with boradcasting this is <code>False</code> by default. Returning a list of (state, rate) tuples is the default callback signature:</p>
<div id="cell-24" class="cell" data-execution_count="15">
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> rabbit_islands(state):</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>    children <span class="op">=</span> []</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> state[<span class="dv">0</span>] <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>        children.append(([state[<span class="dv">0</span>]<span class="op">-</span><span class="dv">1</span>, state[<span class="dv">1</span>]<span class="op">+</span><span class="dv">1</span>], <span class="dv">1</span>))</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>        children.append(([<span class="dv">0</span>,          state[<span class="dv">1</span>]  ], flood_left))</span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> state[<span class="dv">1</span>] <span class="op">&gt;</span> <span class="dv">0</span>:   </span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>        children.append(([state[<span class="dv">0</span>]<span class="op">+</span><span class="dv">1</span>, state[<span class="dv">1</span>]<span class="op">-</span><span class="dv">1</span>], <span class="dv">1</span>))</span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>        children.append(([state[<span class="dv">0</span>],   <span class="dv">0</span>         ], flood_right))</span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> children</span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a>initial_state <span class="op">=</span> [nr_rabbits, <span class="dv">0</span>]  </span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true" tabindex="-1"></a>graph <span class="op">=</span> ptd.Graph(callback<span class="op">=</span>rabbit_islands,</span>
<span id="cb16-14"><a href="#cb16-14" aria-hidden="true" tabindex="-1"></a>                  initial<span class="op">=</span>initial_state</span>
<span id="cb16-15"><a href="#cb16-15" aria-hidden="true" tabindex="-1"></a>                 )</span>
<span id="cb16-16"><a href="#cb16-16" aria-hidden="true" tabindex="-1"></a>graph.plot()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="15">
<div>
<figure class="figure">
<p><a href="rabbits_full_py_api_example_files/figure-html/cell-13-output-1.svg" class="lightbox" data-gallery="quarto-lightbox-gallery-4"><img src="rabbits_full_py_api_example_files/figure-html/cell-13-output-1.svg" class="img-fluid figure-img"></a></p>
</figure>
</div>
</div>
</div>
<section id="continuous-phase-type-distribution" class="level2">
<h2 class="anchored" data-anchor-id="continuous-phase-type-distribution">Continuous phase-type distribution</h2>
<p>We can now construct the graphs by the function. The flooding rates are set to 2 and 4</p>
<div id="cell-27" class="cell" data-execution_count="13">
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>graph <span class="op">=</span> construct_rabbit_graph(<span class="dv">2</span>, <span class="dv">2</span>, <span class="dv">4</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Get the number of vertices in the graph:</p>
<div id="cell-29" class="cell" data-execution_count="14">
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>graph.vertices_length()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="14">
<pre><code>7</code></pre>
</div>
</div>
<p>as well as integer vector states that those vertices represent:</p>
<div id="cell-31" class="cell" data-execution_count="15">
<div class="sourceCode cell-code" id="cb20"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>M <span class="op">=</span> graph.states()</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>M</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="15">
<pre><code>array([[0, 0],
       [2, 0],
       [1, 1],
       [0, 0],
       [0, 2],
       [0, 1],
       [1, 0]], dtype=int32)</code></pre>
</div>
</div>
<p>(or nicely as a dataframe):</p>
<div id="cell-33" class="cell" data-execution_count="16">
<div class="sourceCode cell-code" id="cb22"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>pd.DataFrame(M, columns<span class="op">=</span>[<span class="st">"Rabbits left"</span>, <span class="st">"Rabbits right"</span>]).style.hide()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="16">
<style type="text/css">
</style>

<table id="T_eae7f" class="caption-top table table-sm table-striped small" data-quarto-postprocess="true">
<thead>
<tr class="header">
<th id="T_eae7f_level0_col0" class="col_heading level0 col0" data-quarto-table-cell-role="th">Rabbits left</th>
<th id="T_eae7f_level0_col1" class="col_heading level0 col1" data-quarto-table-cell-role="th">Rabbits right</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td id="T_eae7f_row0_col0" class="data row0 col0">0</td>
<td id="T_eae7f_row0_col1" class="data row0 col1">0</td>
</tr>
<tr class="even">
<td id="T_eae7f_row1_col0" class="data row1 col0">2</td>
<td id="T_eae7f_row1_col1" class="data row1 col1">0</td>
</tr>
<tr class="odd">
<td id="T_eae7f_row2_col0" class="data row2 col0">1</td>
<td id="T_eae7f_row2_col1" class="data row2 col1">1</td>
</tr>
<tr class="even">
<td id="T_eae7f_row3_col0" class="data row3 col0">0</td>
<td id="T_eae7f_row3_col1" class="data row3 col1">0</td>
</tr>
<tr class="odd">
<td id="T_eae7f_row4_col0" class="data row4 col0">0</td>
<td id="T_eae7f_row4_col1" class="data row4 col1">2</td>
</tr>
<tr class="even">
<td id="T_eae7f_row5_col0" class="data row5 col0">0</td>
<td id="T_eae7f_row5_col1" class="data row5 col1">1</td>
</tr>
<tr class="odd">
<td id="T_eae7f_row6_col0" class="data row6 col0">1</td>
<td id="T_eae7f_row6_col1" class="data row6 col1">0</td>
</tr>
</tbody>
</table>
</div>
</div>
<p>This phase-type distribution models the time until all rabits have died. For convenience, we can get its expectation and variance like this:</p>
<div id="cell-35" class="cell" data-execution_count="17">
<div class="sourceCode cell-code" id="cb23"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>graph.expectation()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>INFO: building reward compute graph...</code></pre>
</div>
<div class="cell-output cell-output-display" data-execution_count="17">
<pre><code>0.5038265306122448</code></pre>
</div>
</div>
<div id="cell-36" class="cell" data-execution_count="18">
<div class="sourceCode cell-code" id="cb26"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a>graph.variance()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="18">
<pre><code>0.2264567497917534</code></pre>
</div>
</div>
<p>But if you want you can get any number of moments like this (here three):</p>
<div id="cell-38" class="cell" data-execution_count="19">
<div class="sourceCode cell-code" id="cb28"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a>graph.moments(<span class="dv">3</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="19">
<pre><code>[0.5038265306122448, 0.48029792274052463, 0.6559101757731152]</code></pre>
</div>
</div>
<p>We can find the expected waiting time given that we start in any of the states, not just the starting state:</p>
<div id="cell-40" class="cell" data-execution_count="20">
<div class="sourceCode cell-code" id="cb30"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a>graph.expected_waiting_time()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="20">
<pre><code>[0.5038265306122448,
 0.5038265306122448,
 0.5114795918367346,
 0.0,
 0.30229591836734687,
 0.28571428571428564,
 0.4285714285714285]</code></pre>
</div>
</div>
<p>If needed for downstream analysis, matrix-based representation of the phase-type distribution can be extracted. Note that the indices in this representatoin do <em>not</em> correspond to vertex indicies in the graph.</p>
</section>
</section>
<section id="this-makes-the-kernel-die" class="level1">
<h1>this makes the kernel die…</h1>
<div id="cell-43" class="cell" data-execution_count="21">
<div class="sourceCode cell-code" id="cb32"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="co"># graph.as_matrices()</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>We can get the CDF and PDF. The distribution methods reuse cached computations and recompute only if the graph changes. Compare the running times for the first and second call to the function:</p>
<div id="cell-45" class="cell" data-execution_count="22">
<div class="sourceCode cell-code" id="cb33"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a>time <span class="op">=</span> np.arange(<span class="dv">0</span>, <span class="dv">4</span>, <span class="fl">0.001</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="cell-46" class="cell" data-execution_count="23">
<div class="sourceCode cell-code" id="cb34"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="op">%%</span>time</span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>cdf <span class="op">=</span> graph.cdf(time)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>CPU times: user 307 μs, sys: 32 μs, total: 339 μs
Wall time: 373 μs</code></pre>
</div>
</div>
<div id="cell-47" class="cell" data-execution_count="24">
<div class="sourceCode cell-code" id="cb36"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="op">%%</span>time</span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a>cdf <span class="op">=</span> graph.cdf(time)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>CPU times: user 44 μs, sys: 15 μs, total: 59 μs
Wall time: 55.8 μs</code></pre>
</div>
</div>
<div id="cell-48" class="cell" data-execution_count="25">
<div class="sourceCode cell-code" id="cb38"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="op">%%</span>time</span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a>pdf <span class="op">=</span> graph.pdf(time)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>CPU times: user 43 μs, sys: 2 μs, total: 45 μs
Wall time: 47.9 μs</code></pre>
</div>
</div>
<p>PDF and CDF of distribution. Observe the long tails!</p>
<div id="cell-50" class="cell" data-execution_count="26">
<div class="sourceCode cell-code" id="cb40"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a>fig, (ax1, ax2) <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">2</span>, figsize<span class="op">=</span>(<span class="dv">8</span>, <span class="dv">3</span>))</span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a>ax1.plot(time, pdf)</span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a>ax1.set_title(<span class="st">"PDF"</span>)</span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true" tabindex="-1"></a>ax1.set_ylim(bottom<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb40-5"><a href="#cb40-5" aria-hidden="true" tabindex="-1"></a>ax2.plot(time, cdf)</span>
<span id="cb40-6"><a href="#cb40-6" aria-hidden="true" tabindex="-1"></a>ax2.set_title(<span class="st">"CDF"</span>)</span>
<span id="cb40-7"><a href="#cb40-7" aria-hidden="true" tabindex="-1"></a>ax2.set_ylim(bottom<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb40-8"><a href="#cb40-8" aria-hidden="true" tabindex="-1"></a>sns.despine()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><a href="rabbits_full_py_api_example_files/figure-html/cell-27-output-1.png" class="lightbox" data-gallery="quarto-lightbox-gallery-5"><img src="rabbits_full_py_api_example_files/figure-html/cell-27-output-1.png" width="671" height="296" class="figure-img"></a></p>
</figure>
</div>
</div>
</div>
<section id="rewards" class="level2">
<h2 class="anchored" data-anchor-id="rewards">Rewards</h2>
<p>We can add rewards which are based on the number of rabbits on the second island.</p>
<div id="cell-53" class="cell" data-execution_count="27">
<div class="sourceCode cell-code" id="cb41"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a>rewards <span class="op">=</span> graph.states()[:, <span class="dv">1</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Can also be computed like this:</p>
<div id="cell-55" class="cell" data-execution_count="28">
<div class="sourceCode cell-code" id="cb42"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a>rewards <span class="op">=</span> np.array([graph.vertex_at(i).state()[<span class="dv">1</span>] <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(graph.vertices_length())])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Adding these rewards, the phase-type distribution now represent the total accumulated time that any rabbits spends on the right island.</p>
<p>Using rewards to the moment functions etc. is much faster than changing the graph.</p>
<p>The expectation and variance are now:</p>
<div id="cell-59" class="cell" data-execution_count="29">
<div class="sourceCode cell-code" id="cb43"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a>graph.expectation(rewards), graph.variance(rewards)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="29">
<pre><code>(0.09438775510204081, 0.04634787588504789)</code></pre>
</div>
</div>
<p>Using rewards to the moment functions etc. is much faster than actually changing the graph, but sometimes we might want to be interested in reward transforming the phase-type distribution, giving us the full distribution of accumulated rewards. For example if we want the pdf/cdf.</p>
<div id="cell-61" class="cell" data-execution_count="30">
<div class="sourceCode cell-code" id="cb45"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a>right_graph <span class="op">=</span> graph.reward_transform(rewards)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Now we get the expectation and variance from before without adding any rewards:</p>
<div id="cell-63" class="cell" data-execution_count="31">
<div class="sourceCode cell-code" id="cb46"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a>right_graph.expectation(), right_graph.variance()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>INFO: building reward compute graph...</code></pre>
</div>
<div class="cell-output cell-output-display" data-execution_count="31">
<pre><code>(0.09438775510204078, 0.046347875885047865)</code></pre>
</div>
</div>
<p>We can find the distribution function for the the total accumulate time spent by any rabbit on an island. We show here the PDF and CDF</p>
<div id="cell-65" class="cell" data-execution_count="32">
<div class="sourceCode cell-code" id="cb49"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a>accumulated_rewards <span class="op">=</span> np.arange(<span class="dv">0</span>, <span class="dv">2</span>, <span class="fl">0.01</span>)</span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-3"><a href="#cb49-3" aria-hidden="true" tabindex="-1"></a>pdf <span class="op">=</span> right_graph.pdf(accumulated_rewards)</span>
<span id="cb49-4"><a href="#cb49-4" aria-hidden="true" tabindex="-1"></a>cdf <span class="op">=</span> right_graph.cdf(accumulated_rewards)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>PDF and CDF of distribution. Notice how we have a “defect” i.e.&nbsp;a probability of obtaining no rewards:</p>
<div id="cell-67" class="cell" data-tags="[]" data-execution_count="33">
<div class="sourceCode cell-code" id="cb50"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a>right_graph.defect()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="33">
<pre><code>0.6666666666666666</code></pre>
</div>
</div>
<p>The defect is shown with a dotted line below. Remember to always consider this defect.</p>
<div id="cell-69" class="cell" data-execution_count="34">
<div class="sourceCode cell-code" id="cb52"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a>fig, (ax1, ax2) <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">2</span>, figsize<span class="op">=</span>(<span class="dv">8</span>, <span class="dv">3</span>), sharey<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true" tabindex="-1"></a>ax1.plot(accumulated_rewards, pdf)</span>
<span id="cb52-3"><a href="#cb52-3" aria-hidden="true" tabindex="-1"></a>ax1.set_title(<span class="st">"PDF"</span>)</span>
<span id="cb52-4"><a href="#cb52-4" aria-hidden="true" tabindex="-1"></a>ax1.set_ylim(bottom<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb52-5"><a href="#cb52-5" aria-hidden="true" tabindex="-1"></a>ax2.plot(accumulated_rewards, cdf)</span>
<span id="cb52-6"><a href="#cb52-6" aria-hidden="true" tabindex="-1"></a>ax2.set_title(<span class="st">"CDF"</span>)</span>
<span id="cb52-7"><a href="#cb52-7" aria-hidden="true" tabindex="-1"></a>ax2.set_ylim(bottom<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb52-8"><a href="#cb52-8" aria-hidden="true" tabindex="-1"></a>ax2.axhline(y<span class="op">=</span>right_graph.defect(), linestyle<span class="op">=</span><span class="st">'dotted'</span>, color<span class="op">=</span><span class="st">'black'</span>)</span>
<span id="cb52-9"><a href="#cb52-9" aria-hidden="true" tabindex="-1"></a>sns.despine()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><a href="rabbits_full_py_api_example_files/figure-html/cell-35-output-1.png" class="lightbox" data-gallery="quarto-lightbox-gallery-6"><img src="rabbits_full_py_api_example_files/figure-html/cell-35-output-1.png" width="671" height="296" class="figure-img"></a></p>
</figure>
</div>
</div>
</div>
<p>There are also utility methods to get the stop probability i.e.&nbsp;probabilities of occupying each state at time t.</p>
<div id="cell-71" class="cell" data-execution_count="35">
<div class="sourceCode cell-code" id="cb53"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a>graph.stop_probability(<span class="fl">0.2</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="35">
<pre><code>[0.0,
 0.5561531639166896,
 0.07040541534825098,
 0.0,
 0.007095725804629082,
 0.016348108066650276,
 0.03374890558205247]</code></pre>
</div>
</div>
<p>We can use that to compute the expected number of rabbits across time:</p>
<div id="cell-73" class="cell" data-execution_count="36">
<div class="sourceCode cell-code" id="cb55"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a>times <span class="op">=</span> np.arange(<span class="dv">0</span>, <span class="dv">2</span>, <span class="fl">0.05</span>)</span>
<span id="cb55-2"><a href="#cb55-2" aria-hidden="true" tabindex="-1"></a>expected_rabbits_left <span class="op">=</span> [</span>
<span id="cb55-3"><a href="#cb55-3" aria-hidden="true" tabindex="-1"></a>    np.<span class="bu">sum</span>(graph.stop_probability(i) </span>
<span id="cb55-4"><a href="#cb55-4" aria-hidden="true" tabindex="-1"></a>           <span class="op">*</span> np.<span class="bu">sum</span>(graph.states(), axis<span class="op">=</span><span class="dv">1</span>)) </span>
<span id="cb55-5"><a href="#cb55-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> times</span>
<span id="cb55-6"><a href="#cb55-6" aria-hidden="true" tabindex="-1"></a>    ]</span>
<span id="cb55-7"><a href="#cb55-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-8"><a href="#cb55-8" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">1</span>, figsize<span class="op">=</span>(<span class="dv">4</span>, <span class="dv">3</span>))</span>
<span id="cb55-9"><a href="#cb55-9" aria-hidden="true" tabindex="-1"></a>ax.plot(times, expected_rabbits_left)</span>
<span id="cb55-10"><a href="#cb55-10" aria-hidden="true" tabindex="-1"></a>ax.set_xlabel(<span class="st">'time'</span>)</span>
<span id="cb55-11"><a href="#cb55-11" aria-hidden="true" tabindex="-1"></a>ax.set_ylabel(<span class="st">"Expected nr rabbits"</span>)</span>
<span id="cb55-12"><a href="#cb55-12" aria-hidden="true" tabindex="-1"></a>sns.despine()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><a href="rabbits_full_py_api_example_files/figure-html/cell-37-output-1.png" class="lightbox" data-gallery="quarto-lightbox-gallery-7"><img src="rabbits_full_py_api_example_files/figure-html/cell-37-output-1.png" width="385" height="294" class="figure-img"></a></p>
</figure>
</div>
</div>
</div>
<p>We can also get the accumulated visiting time of a particular state. E.g. the total time before time t=0.5 where there was a rabbit on the right island:</p>
<div id="cell-75" class="cell" data-execution_count="37">
<div class="sourceCode cell-code" id="cb56"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a>rewards <span class="op">=</span> (graph.states()[:,<span class="dv">1</span>]<span class="op">&gt;</span><span class="dv">0</span>).astype(<span class="bu">int</span>)</span>
<span id="cb56-2"><a href="#cb56-2" aria-hidden="true" tabindex="-1"></a>np.<span class="bu">sum</span>(graph.accumulated_visiting_time(time<span class="op">=</span><span class="fl">0.5</span>) <span class="op">*</span> rewards)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="37">
<pre><code>np.float64(0.04053231796047568)</code></pre>
</div>
</div>
<div id="cell-76" class="cell" data-execution_count="38">
<div class="sourceCode cell-code" id="cb58"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a>graph.expected_residence_time()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="38">
<pre><code>[0.0, 0.5038265306122448, 0.0, 0.0, 0.0, 0.0, 0.0]</code></pre>
</div>
</div>
</section>
</section>
<section id="random-sampling" class="level1">
<h1>Random sampling</h1>
<p>The library includes functions to do random sampling. These are useful to also validate the computations</p>
<div id="cell-79" class="cell" data-execution_count="39">
<div class="sourceCode cell-code" id="cb60"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true" tabindex="-1"></a>graph.sample(<span class="dv">5</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="39">
<pre><code>[0.16942571554192568,
 0.050413995296475146,
 0.11035839585273738,
 0.0560109248063384,
 0.33927458720992903]</code></pre>
</div>
</div>
<div id="cell-80" class="cell" data-execution_count="40">
<div class="sourceCode cell-code" id="cb62"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb62-1"><a href="#cb62-1" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(figsize<span class="op">=</span>(<span class="dv">4</span>, <span class="dv">3</span>))</span>
<span id="cb62-2"><a href="#cb62-2" aria-hidden="true" tabindex="-1"></a>samples <span class="op">=</span> graph.sample(<span class="dv">1000000</span>)</span>
<span id="cb62-3"><a href="#cb62-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb62-4"><a href="#cb62-4" aria-hidden="true" tabindex="-1"></a>ax.hist(samples, bins<span class="op">=</span><span class="dv">50</span>, density<span class="op">=</span><span class="va">True</span>, label<span class="op">=</span><span class="st">'Samples'</span>)</span>
<span id="cb62-5"><a href="#cb62-5" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> np.arange(<span class="dv">0</span>, <span class="dv">2</span>, <span class="fl">0.05</span>)</span>
<span id="cb62-6"><a href="#cb62-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb62-7"><a href="#cb62-7" aria-hidden="true" tabindex="-1"></a>ax.plot(x, [graph.pdf(t) <span class="cf">for</span> t <span class="kw">in</span> x], label<span class="op">=</span><span class="st">'PDF'</span>)</span>
<span id="cb62-8"><a href="#cb62-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb62-9"><a href="#cb62-9" aria-hidden="true" tabindex="-1"></a>ax.set_xlim(<span class="dv">0</span>, <span class="dv">2</span>)</span>
<span id="cb62-10"><a href="#cb62-10" aria-hidden="true" tabindex="-1"></a>ax.legend()</span>
<span id="cb62-11"><a href="#cb62-11" aria-hidden="true" tabindex="-1"></a>sns.despine()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><a href="rabbits_full_py_api_example_files/figure-html/cell-41-output-1.png" class="lightbox" data-gallery="quarto-lightbox-gallery-8"><img src="rabbits_full_py_api_example_files/figure-html/cell-41-output-1.png" width="372" height="274" class="figure-img"></a></p>
</figure>
</div>
</div>
</div>
<p>You can produce the moments from sampling if needed. Compare to the sampled and exact second moments:</p>
<div id="cell-82" class="cell" data-execution_count="41">
<div class="sourceCode cell-code" id="cb63"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb63-1"><a href="#cb63-1" aria-hidden="true" tabindex="-1"></a>np.<span class="bu">sum</span>(np.array(graph.sample(<span class="dv">1000000</span>))<span class="op">**</span><span class="dv">2</span>)<span class="op">/</span><span class="dv">1000000</span>, graph.moments(<span class="dv">2</span>)[<span class="dv">1</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="41">
<pre><code>(np.float64(0.4798029981357515), 0.48029792274052463)</code></pre>
</div>
</div>
<div id="cell-83" class="cell" data-execution_count="42">
<div class="sourceCode cell-code" id="cb65"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb65-1"><a href="#cb65-1" aria-hidden="true" tabindex="-1"></a>rewards <span class="op">=</span> graph.states()[:,<span class="dv">1</span>]</span>
<span id="cb65-2"><a href="#cb65-2" aria-hidden="true" tabindex="-1"></a>np.<span class="bu">sum</span>(np.array(graph.sample(<span class="dv">1000000</span>, rewards))<span class="op">**</span><span class="dv">2</span>)<span class="op">/</span><span class="dv">1000000</span>, graph.moments(<span class="dv">2</span>, rewards)[<span class="dv">1</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="42">
<pre><code>(np.float64(0.055031020812912015), 0.05525692419825073)</code></pre>
</div>
</div>
<p>Reward-transforming first and then computing without rewards achieves the same thing:</p>
<div id="cell-85" class="cell" data-execution_count="43">
<div class="sourceCode cell-code" id="cb67"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb67-1"><a href="#cb67-1" aria-hidden="true" tabindex="-1"></a>revtr_graph <span class="op">=</span> graph.reward_transform(rewards)</span>
<span id="cb67-2"><a href="#cb67-2" aria-hidden="true" tabindex="-1"></a>np.<span class="bu">sum</span>(np.array(revtr_graph.sample(<span class="dv">1000000</span>))<span class="op">**</span><span class="dv">2</span>)<span class="op">/</span><span class="dv">1000000</span>, revtr_graph.moments(<span class="dv">2</span>)[<span class="dv">1</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>INFO: building reward compute graph...</code></pre>
</div>
<div class="cell-output cell-output-display" data-execution_count="43">
<pre><code>(np.float64(0.05471903186096611), 0.05525692419825069)</code></pre>
</div>
</div>
<section id="discrete-phase-type-distributions" class="level2">
<h2 class="anchored" data-anchor-id="discrete-phase-type-distributions">Discrete phase-type distributions</h2>
<p>We can also work with discrete phase-type distributions. This is the number of jumps in a Markov Chain before absorption. We will model that any rabbit can find a carrot at each time with rate 0.1 and see how many carrots the rabbits will have found. We could of course just make a new state-space creation function, but we can also manipulate existing.</p>
<div id="cell-88" class="cell" data-execution_count="44">
<div class="sourceCode cell-code" id="cb70"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb70-1"><a href="#cb70-1" aria-hidden="true" tabindex="-1"></a>carrot_graph <span class="op">=</span> graph.clone()</span>
<span id="cb70-2"><a href="#cb70-2" aria-hidden="true" tabindex="-1"></a>vlength <span class="op">=</span> carrot_graph.vertices_length()</span>
<span id="cb70-3"><a href="#cb70-3" aria-hidden="true" tabindex="-1"></a>carrot_vertices <span class="op">=</span> np.repeat(<span class="va">False</span>, vlength<span class="op">*</span><span class="dv">2</span>)</span>
<span id="cb70-4"><a href="#cb70-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb70-5"><a href="#cb70-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb70-6"><a href="#cb70-6" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(vlength):</span>
<span id="cb70-7"><a href="#cb70-7" aria-hidden="true" tabindex="-1"></a>    vertex <span class="op">=</span> carrot_graph.vertex_at(i)</span>
<span id="cb70-8"><a href="#cb70-8" aria-hidden="true" tabindex="-1"></a>    rabbits <span class="op">=</span> <span class="bu">sum</span>(vertex.state())</span>
<span id="cb70-9"><a href="#cb70-9" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb70-10"><a href="#cb70-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> rabbits <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb70-11"><a href="#cb70-11" aria-hidden="true" tabindex="-1"></a>        obtained_carrot_vertex <span class="op">=</span> carrot_graph.create_vertex([<span class="dv">0</span>])</span>
<span id="cb70-12"><a href="#cb70-12" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Go directly back to the state we came from</span></span>
<span id="cb70-13"><a href="#cb70-13" aria-hidden="true" tabindex="-1"></a>        obtained_carrot_vertex.add_edge(vertex, <span class="dv">1</span>)</span>
<span id="cb70-14"><a href="#cb70-14" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Rate of finding carrot</span></span>
<span id="cb70-15"><a href="#cb70-15" aria-hidden="true" tabindex="-1"></a>        vertex.add_edge(obtained_carrot_vertex, rabbits <span class="op">*</span> <span class="fl">0.1</span>)</span>
<span id="cb70-16"><a href="#cb70-16" aria-hidden="true" tabindex="-1"></a>        carrot_vertices[obtained_carrot_vertex.index()] <span class="op">=</span> <span class="va">True</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-error">
<div class="ansi-escaped-output">
<pre><span class="ansi-red-fg">---------------------------------------------------------------------------</span>
<span class="ansi-red-fg">AttributeError</span>                            Traceback (most recent call last)
Cell <span class="ansi-green-fg">In[44], line 11</span>
<span class="ansi-green-fg ansi-bold">      8</span> rabbits <span style="color:rgb(98,98,98)">=</span> <span style="color:rgb(0,135,0)">sum</span>(vertex<span style="color:rgb(98,98,98)">.</span>state())
<span class="ansi-green-fg ansi-bold">     10</span> <span style="font-weight:bold;color:rgb(0,135,0)">if</span> rabbits <span style="color:rgb(98,98,98)">&gt;</span> <span style="color:rgb(98,98,98)">0</span>:
<span class="ansi-green-fg">---&gt; 11</span>     obtained_carrot_vertex <span style="color:rgb(98,98,98)">=</span> <span class="ansi-yellow-bg">carrot_graph</span><span style="color:rgb(98,98,98)" class="ansi-yellow-bg">.</span><span class="ansi-yellow-bg">create_vertex</span>([<span style="color:rgb(98,98,98)">0</span>])
<span class="ansi-green-fg ansi-bold">     12</span>     <span style="font-style:italic;color:rgb(95,135,135)"># Go directly back to the state we came from</span>
<span class="ansi-green-fg ansi-bold">     13</span>     obtained_carrot_vertex<span style="color:rgb(98,98,98)">.</span>add_edge(vertex, <span style="color:rgb(98,98,98)">1</span>)

<span class="ansi-red-fg">AttributeError</span>: 'ptdalgorithms.ptdalgorithmscpp_pybind.Graph' object has no attribute 'create_vertex'</pre>
</div>
</div>
</div>
<div id="cell-89" class="cell" data-execution_count="45">
<div class="sourceCode cell-code" id="cb71"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb71-1"><a href="#cb71-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb71-2"><a href="#cb71-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb71-3"><a href="#cb71-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb71-4"><a href="#cb71-4" aria-hidden="true" tabindex="-1"></a>vlength <span class="op">=</span> carrot_graph.vertices_length()</span>
<span id="cb71-5"><a href="#cb71-5" aria-hidden="true" tabindex="-1"></a>carrot_vertices <span class="op">=</span> np.repeat(<span class="va">False</span>, vlength<span class="op">*</span><span class="dv">2</span>)</span>
<span id="cb71-6"><a href="#cb71-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb71-7"><a href="#cb71-7" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(vlength):</span>
<span id="cb71-8"><a href="#cb71-8" aria-hidden="true" tabindex="-1"></a>    vertex <span class="op">=</span> carrot_graph.vertex_at(i)</span>
<span id="cb71-9"><a href="#cb71-9" aria-hidden="true" tabindex="-1"></a>    rabbits <span class="op">=</span> <span class="bu">sum</span>(vertex.state())</span>
<span id="cb71-10"><a href="#cb71-10" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb71-11"><a href="#cb71-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> rabbits <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb71-12"><a href="#cb71-12" aria-hidden="true" tabindex="-1"></a>        obtained_carrot_vertex <span class="op">=</span> carrot_graph.create_vertex([<span class="dv">0</span>])</span>
<span id="cb71-13"><a href="#cb71-13" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Go directly back to the state we came from</span></span>
<span id="cb71-14"><a href="#cb71-14" aria-hidden="true" tabindex="-1"></a>        obtained_carrot_vertex.add_edge(vertex, <span class="dv">1</span>)</span>
<span id="cb71-15"><a href="#cb71-15" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Rate of finding carrot</span></span>
<span id="cb71-16"><a href="#cb71-16" aria-hidden="true" tabindex="-1"></a>        vertex.add_edge(obtained_carrot_vertex, rabbits <span class="op">*</span> <span class="fl">0.1</span>)</span>
<span id="cb71-17"><a href="#cb71-17" aria-hidden="true" tabindex="-1"></a>        carrot_vertices[obtained_carrot_vertex.index()] <span class="op">=</span> <span class="va">True</span></span>
<span id="cb71-18"><a href="#cb71-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb71-19"><a href="#cb71-19" aria-hidden="true" tabindex="-1"></a>carrot_vertices <span class="op">=</span> carrot_vertices[np.arange(carrot_graph.vertices_length())]</span>
<span id="cb71-20"><a href="#cb71-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb71-21"><a href="#cb71-21" aria-hidden="true" tabindex="-1"></a><span class="co"># We now want to make the graph discrete. We do this by 'normalizing' the edges</span></span>
<span id="cb71-22"><a href="#cb71-22" aria-hidden="true" tabindex="-1"></a><span class="co"># This is imply scaling the vertices such that the total out-going rate is 1</span></span>
<span id="cb71-23"><a href="#cb71-23" aria-hidden="true" tabindex="-1"></a><span class="co"># As it is now the probability of transitions</span></span>
<span id="cb71-24"><a href="#cb71-24" aria-hidden="true" tabindex="-1"></a>weights_were_multiplied_with <span class="op">=</span> carrot_graph.normalize()</span>
<span id="cb71-25"><a href="#cb71-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb71-26"><a href="#cb71-26" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"This is the discrete state space as a sub-transition matrix:"</span>)</span>
<span id="cb71-27"><a href="#cb71-27" aria-hidden="true" tabindex="-1"></a><span class="co">#carrot_graph.as_matrices()</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-error">
<div class="ansi-escaped-output">
<pre><span class="ansi-red-fg">---------------------------------------------------------------------------</span>
<span class="ansi-red-fg">AttributeError</span>                            Traceback (most recent call last)
Cell <span class="ansi-green-fg">In[45], line 9</span>
<span class="ansi-green-fg ansi-bold">      6</span> rabbits <span style="color:rgb(98,98,98)">=</span> <span style="color:rgb(0,135,0)">sum</span>(vertex<span style="color:rgb(98,98,98)">.</span>state())
<span class="ansi-green-fg ansi-bold">      8</span> <span style="font-weight:bold;color:rgb(0,135,0)">if</span> rabbits <span style="color:rgb(98,98,98)">&gt;</span> <span style="color:rgb(98,98,98)">0</span>:
<span class="ansi-green-fg">----&gt; 9</span>     obtained_carrot_vertex <span style="color:rgb(98,98,98)">=</span> <span class="ansi-yellow-bg">carrot_graph</span><span style="color:rgb(98,98,98)" class="ansi-yellow-bg">.</span><span class="ansi-yellow-bg">create_vertex</span>([<span style="color:rgb(98,98,98)">0</span>])
<span class="ansi-green-fg ansi-bold">     10</span>     <span style="font-style:italic;color:rgb(95,135,135)"># Go directly back to the state we came from</span>
<span class="ansi-green-fg ansi-bold">     11</span>     obtained_carrot_vertex<span style="color:rgb(98,98,98)">.</span>add_edge(vertex, <span style="color:rgb(98,98,98)">1</span>)

<span class="ansi-red-fg">AttributeError</span>: 'ptdalgorithms.ptdalgorithmscpp_pybind.Graph' object has no attribute 'create_vertex'</pre>
</div>
</div>
</div>
<div id="cell-90" class="cell" data-execution_count="46">
<div class="sourceCode cell-code" id="cb72"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb72-1"><a href="#cb72-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> vertex <span class="kw">in</span> carrot_graph.vertices():</span>
<span id="cb72-2"><a href="#cb72-2" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(vertex.index(),vertex.state(), vertex.edges())</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>0 [0, 0] [1-(2,0)]
1 [2, 0] [1-(1,1), 2-(0,0)]
2 [1, 1] [1-(0,2), 2-(0,1), 1-(2,0), 4-(1,0)]
3 [0, 0] []
4 [0, 2] [1-(1,1), 4-(0,0)]
5 [0, 1] [1-(1,0), 4-(0,0)]
6 [1, 0] [1-(0,1), 2-(0,0)]</code></pre>
</div>
</div>
<div id="cell-91" class="cell" data-execution_count="47">
<div class="sourceCode cell-code" id="cb74"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb74-1"><a href="#cb74-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> vertex <span class="kw">in</span> carrot_graph.vertices():</span>
<span id="cb74-2"><a href="#cb74-2" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(vertex)</span>
<span id="cb74-3"><a href="#cb74-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> edge <span class="kw">in</span> vertex.edges():</span>
<span id="cb74-4"><a href="#cb74-4" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="st">"  "</span>, edge)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>(0,0)
   1-(2,0)
(2,0)
   1-(1,1)
   2-(0,0)
(1,1)
   1-(0,2)
   2-(0,1)
   1-(2,0)
   4-(1,0)
(0,0)
(0,2)
   1-(1,1)
   4-(0,0)
(0,1)
   1-(1,0)
   4-(0,0)
(1,0)
   1-(0,1)
   2-(0,0)</code></pre>
</div>
</div>
<div id="cell-92" class="cell" data-execution_count="48">
<div class="sourceCode cell-code" id="cb76"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb76-1"><a href="#cb76-1" aria-hidden="true" tabindex="-1"></a>carrot_vertices.astype(<span class="bu">int</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="48">
<pre><code>array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])</code></pre>
</div>
</div>
<p>We now want to find the expected number of eaten carrots. We set the reward such that the carrot vertex has a reward of ‘1’.</p>
<div id="cell-94" class="cell" data-execution_count="49">
<div class="sourceCode cell-code" id="cb78"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb78-1"><a href="#cb78-1" aria-hidden="true" tabindex="-1"></a>rewards <span class="op">=</span> carrot_vertices.astype(<span class="bu">int</span>)</span>
<span id="cb78-2"><a href="#cb78-2" aria-hidden="true" tabindex="-1"></a>carrot_graph.expectation_discrete(rewards)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-error">
<div class="ansi-escaped-output">
<pre><span class="ansi-red-fg">---------------------------------------------------------------------------</span>
<span class="ansi-red-fg">RuntimeError</span>                              Traceback (most recent call last)
Cell <span class="ansi-green-fg">In[49], line 2</span>
<span class="ansi-green-fg ansi-bold">      1</span> rewards <span style="color:rgb(98,98,98)">=</span> carrot_vertices<span style="color:rgb(98,98,98)">.</span>astype(<span style="color:rgb(0,135,0)">int</span>)
<span class="ansi-green-fg">----&gt; 2</span> <span class="ansi-yellow-bg">carrot_graph</span><span style="color:rgb(98,98,98)" class="ansi-yellow-bg">.</span><span class="ansi-yellow-bg">expectation_discrete</span><span class="ansi-yellow-bg">(</span><span class="ansi-yellow-bg">rewards</span><span class="ansi-yellow-bg">)</span>

<span class="ansi-red-fg">RuntimeError</span>: Failed: Rewards must match the number of vertices. Expected 7, got 14</pre>
</div>
</div>
</div>
<p>We can verify that the number of carrots correspond to scaling the continuous graph:</p>
<div id="cell-96" class="cell" data-execution_count="50">
<div class="sourceCode cell-code" id="cb79"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb79-1"><a href="#cb79-1" aria-hidden="true" tabindex="-1"></a>graph.expectation(graph.states().<span class="bu">sum</span>(axis<span class="op">=</span><span class="dv">1</span>)) <span class="op">*</span> <span class="fl">0.1</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="50">
<pre><code>0.09056122448979591</code></pre>
</div>
</div>
<p>Of course we cannot do this for other moments:</p>
<div id="cell-98" class="cell" data-execution_count="51">
<div class="sourceCode cell-code" id="cb81"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb81-1"><a href="#cb81-1" aria-hidden="true" tabindex="-1"></a>carrot_graph.variance_discrete(rewards)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-error">
<div class="ansi-escaped-output">
<pre><span class="ansi-red-fg">---------------------------------------------------------------------------</span>
<span class="ansi-red-fg">RuntimeError</span>                              Traceback (most recent call last)
Cell <span class="ansi-green-fg">In[51], line 1</span>
<span class="ansi-green-fg">----&gt; 1</span> <span class="ansi-yellow-bg">carrot_graph</span><span style="color:rgb(98,98,98)" class="ansi-yellow-bg">.</span><span class="ansi-yellow-bg">variance_discrete</span><span class="ansi-yellow-bg">(</span><span class="ansi-yellow-bg">rewards</span><span class="ansi-yellow-bg">)</span>

<span class="ansi-red-fg">RuntimeError</span>: Failed: Rewards must match the number of vertices. Expected 7, got 14</pre>
</div>
</div>
</div>
<p>Verified by sampling:</p>
<div id="cell-100" class="cell" data-execution_count="52">
<div class="sourceCode cell-code" id="cb82"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb82-1"><a href="#cb82-1" aria-hidden="true" tabindex="-1"></a>samples <span class="op">=</span> carrot_graph.sample_discrete(<span class="dv">1000000</span>, rewards)</span>
<span id="cb82-2"><a href="#cb82-2" aria-hidden="true" tabindex="-1"></a>samples <span class="op">=</span> np.array(samples)</span>
<span id="cb82-3"><a href="#cb82-3" aria-hidden="true" tabindex="-1"></a>np.<span class="bu">sum</span>(samples<span class="op">**</span><span class="dv">2</span>) <span class="op">/</span> <span class="dv">1000000</span> <span class="op">-</span> ((np.<span class="bu">sum</span>(samples)) <span class="op">/</span> <span class="dv">1000000</span>)<span class="op">**</span><span class="dv">2</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-error">
<div class="ansi-escaped-output">
<pre><span class="ansi-red-fg">---------------------------------------------------------------------------</span>
<span class="ansi-red-fg">RuntimeError</span>                              Traceback (most recent call last)
Cell <span class="ansi-green-fg">In[52], line 1</span>
<span class="ansi-green-fg">----&gt; 1</span> samples <span style="color:rgb(98,98,98)">=</span> <span class="ansi-yellow-bg">carrot_graph</span><span style="color:rgb(98,98,98)" class="ansi-yellow-bg">.</span><span class="ansi-yellow-bg">sample_discrete</span><span class="ansi-yellow-bg">(</span><span style="color:rgb(98,98,98)" class="ansi-yellow-bg">1000000</span><span class="ansi-yellow-bg">,</span><span class="ansi-yellow-bg"> </span><span class="ansi-yellow-bg">rewards</span><span class="ansi-yellow-bg">)</span>
<span class="ansi-green-fg ansi-bold">      2</span> samples <span style="color:rgb(98,98,98)">=</span> np<span style="color:rgb(98,98,98)">.</span>array(samples)
<span class="ansi-green-fg ansi-bold">      3</span> np<span style="color:rgb(98,98,98)">.</span>sum(samples<span style="color:rgb(98,98,98)">*</span><span style="color:rgb(98,98,98)">*</span><span style="color:rgb(98,98,98)">2</span>) <span style="color:rgb(98,98,98)">/</span> <span style="color:rgb(98,98,98)">1000000</span> <span style="color:rgb(98,98,98)">-</span> ((np<span style="color:rgb(98,98,98)">.</span>sum(samples)) <span style="color:rgb(98,98,98)">/</span> <span style="color:rgb(98,98,98)">1000000</span>)<span style="color:rgb(98,98,98)">*</span><span style="color:rgb(98,98,98)">*</span><span style="color:rgb(98,98,98)">2</span>

<span class="ansi-red-fg">RuntimeError</span>: Failed: Rewards must match the number of vertices. Expected 7, got 14</pre>
</div>
</div>
</div>
<div id="cell-101" class="cell" data-execution_count="53">
<div class="sourceCode cell-code" id="cb83"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb83-1"><a href="#cb83-1" aria-hidden="true" tabindex="-1"></a><span class="co"># We can find the distribution function for the the total number of carrots found</span></span>
<span id="cb83-2"><a href="#cb83-2" aria-hidden="true" tabindex="-1"></a>carrots <span class="op">=</span> np.arange(<span class="dv">10</span>)</span>
<span id="cb83-3"><a href="#cb83-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Notice that with this reward transformation the graph is no longer sparse, as all paths through</span></span>
<span id="cb83-4"><a href="#cb83-4" aria-hidden="true" tabindex="-1"></a><span class="co"># the graph are represented!!</span></span>
<span id="cb83-5"><a href="#cb83-5" aria-hidden="true" tabindex="-1"></a>found_carrots_graph  <span class="op">=</span> carrot_graph.reward_transform_discrete(rewards)</span>
<span id="cb83-6"><a href="#cb83-6" aria-hidden="true" tabindex="-1"></a>pmf <span class="op">=</span> found_carrots_graph.pmf_discrete(carrots)</span>
<span id="cb83-7"><a href="#cb83-7" aria-hidden="true" tabindex="-1"></a>cdf <span class="op">=</span> found_carrots_graph.cdf_discrete(carrots)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="cell-102" class="cell" data-execution_count="54">
<div class="sourceCode cell-code" id="cb84"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb84-1"><a href="#cb84-1" aria-hidden="true" tabindex="-1"></a>fig, (ax1, ax2) <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">2</span>, figsize<span class="op">=</span>(<span class="dv">8</span>, <span class="dv">3</span>), sharey<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb84-2"><a href="#cb84-2" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> np.arange(<span class="dv">0</span>, <span class="dv">10</span>, <span class="dv">1</span>)</span>
<span id="cb84-3"><a href="#cb84-3" aria-hidden="true" tabindex="-1"></a>ax1.plot(x, pmf)</span>
<span id="cb84-4"><a href="#cb84-4" aria-hidden="true" tabindex="-1"></a>ax1.set_title(<span class="st">"PDF"</span>)</span>
<span id="cb84-5"><a href="#cb84-5" aria-hidden="true" tabindex="-1"></a>ax1.set_xlabel(<span class="st">'Total number of carrots found'</span>)</span>
<span id="cb84-6"><a href="#cb84-6" aria-hidden="true" tabindex="-1"></a><span class="co"># ax1.set_ylim(bottom=0)</span></span>
<span id="cb84-7"><a href="#cb84-7" aria-hidden="true" tabindex="-1"></a>ax2.plot(x, cdf)</span>
<span id="cb84-8"><a href="#cb84-8" aria-hidden="true" tabindex="-1"></a>ax2.set_title(<span class="st">"CDF"</span>)</span>
<span id="cb84-9"><a href="#cb84-9" aria-hidden="true" tabindex="-1"></a><span class="co"># ax2.set_ylim(bottom=0)</span></span>
<span id="cb84-10"><a href="#cb84-10" aria-hidden="true" tabindex="-1"></a>ax2.set_xlabel(<span class="st">'Total number of carrots found'</span>)</span>
<span id="cb84-11"><a href="#cb84-11" aria-hidden="true" tabindex="-1"></a>ax2.axhline(y<span class="op">=</span>right_graph.defect(), linestyle<span class="op">=</span><span class="st">'dotted'</span>, color<span class="op">=</span><span class="st">'black'</span>)</span>
<span id="cb84-12"><a href="#cb84-12" aria-hidden="true" tabindex="-1"></a>sns.despine()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><a href="rabbits_full_py_api_example_files/figure-html/cell-55-output-1.png" class="lightbox" data-gallery="quarto-lightbox-gallery-9"><img src="rabbits_full_py_api_example_files/figure-html/cell-55-output-1.png" width="671" height="315" class="figure-img"></a></p>
</figure>
</div>
</div>
</div>
</section>
</section>
<section id="multivariate-phase-type-distributions" class="level1">
<h1>Multivariate phase-type distributions</h1>
<p>Instead of a univariate reward, we can have the distribution earn a <em>vector</em> of rewards for each time unit spent at a vertex. We will continue with the rabbit example. We will now show the relationship between total time spent by any rabbit on either of the two islands.</p>
<div id="cell-105" class="cell" data-execution_count="55">
<div class="sourceCode cell-code" id="cb85"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb85-1"><a href="#cb85-1" aria-hidden="true" tabindex="-1"></a>states <span class="op">=</span> graph.states()</span>
<span id="cb85-2"><a href="#cb85-2" aria-hidden="true" tabindex="-1"></a>states[:, <span class="dv">1</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="55">
<pre><code>array([0, 0, 1, 0, 2, 1, 0], dtype=int32)</code></pre>
</div>
</div>
<div id="cell-106" class="cell" data-execution_count="56">
<div class="sourceCode cell-code" id="cb87"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb87-1"><a href="#cb87-1" aria-hidden="true" tabindex="-1"></a>states <span class="op">=</span> graph.states()</span>
<span id="cb87-2"><a href="#cb87-2" aria-hidden="true" tabindex="-1"></a>graph.covariance(states[:,<span class="dv">0</span>], states[:,<span class="dv">1</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="56">
<pre><code>0.030003774468971296</code></pre>
</div>
</div>
<div id="cell-107" class="cell" data-execution_count="57">
<div class="sourceCode cell-code" id="cb89"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb89-1"><a href="#cb89-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb89-2"><a href="#cb89-2" aria-hidden="true" tabindex="-1"></a>simulations <span class="op">=</span> graph.sample_multivariate(<span class="dv">100000</span>, graph.states())</span>
<span id="cb89-3"><a href="#cb89-3" aria-hidden="true" tabindex="-1"></a>simulated_cov <span class="op">=</span> <span class="bu">sum</span>(simulations[<span class="dv">0</span>,:]<span class="op">*</span>simulations[<span class="dv">1</span>,:])<span class="op">/</span><span class="dv">100000</span> <span class="op">-</span> <span class="op">\</span></span>
<span id="cb89-4"><a href="#cb89-4" aria-hidden="true" tabindex="-1"></a>                    <span class="bu">sum</span>(simulations[<span class="dv">0</span>,:])<span class="op">/</span><span class="dv">100000</span><span class="op">*</span><span class="bu">sum</span>(simulations[<span class="dv">1</span>,:])<span class="op">/</span><span class="dv">100000</span></span>
<span id="cb89-5"><a href="#cb89-5" aria-hidden="true" tabindex="-1"></a>simulated_cov</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="57">
<pre><code>np.float64(0.029618498210833108)</code></pre>
</div>
</div>
<p>The api also supports multivariate <em>discrete</em> phase-type distributions. We show the covariance between carrots found on either island.</p>
<div id="cell-109" class="cell" data-execution_count="58">
<div class="sourceCode cell-code" id="cb91"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb91-1"><a href="#cb91-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb91-2"><a href="#cb91-2" aria-hidden="true" tabindex="-1"></a>mdph_carrot_graph <span class="op">=</span> graph.clone()</span>
<span id="cb91-3"><a href="#cb91-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb91-4"><a href="#cb91-4" aria-hidden="true" tabindex="-1"></a>vlength <span class="op">=</span> mdph_carrot_graph.vertices_length()</span>
<span id="cb91-5"><a href="#cb91-5" aria-hidden="true" tabindex="-1"></a>carrot_vertices_left <span class="op">=</span> np.repeat(<span class="va">False</span>, vlength<span class="op">*</span><span class="dv">2</span>)</span>
<span id="cb91-6"><a href="#cb91-6" aria-hidden="true" tabindex="-1"></a>carrot_vertices_right <span class="op">=</span> np.repeat(<span class="va">False</span>, vlength<span class="op">*</span><span class="dv">2</span>)</span>
<span id="cb91-7"><a href="#cb91-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb91-8"><a href="#cb91-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb91-9"><a href="#cb91-9" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(vlength):</span>
<span id="cb91-10"><a href="#cb91-10" aria-hidden="true" tabindex="-1"></a>    vertex <span class="op">=</span> mdph_carrot_graph.vertex_at(i)</span>
<span id="cb91-11"><a href="#cb91-11" aria-hidden="true" tabindex="-1"></a>    rabbits <span class="op">=</span> vertex.state()</span>
<span id="cb91-12"><a href="#cb91-12" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb91-13"><a href="#cb91-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> rabbits[<span class="dv">0</span>] <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb91-14"><a href="#cb91-14" aria-hidden="true" tabindex="-1"></a>        obtained_carrot_vertex <span class="op">=</span> mdph_carrot_graph.create_vertex([<span class="dv">0</span>])</span>
<span id="cb91-15"><a href="#cb91-15" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Go directly back to the state we came from</span></span>
<span id="cb91-16"><a href="#cb91-16" aria-hidden="true" tabindex="-1"></a>        obtained_carrot_vertex.add_edge(vertex, <span class="dv">1</span>)</span>
<span id="cb91-17"><a href="#cb91-17" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Rate of finding carrot</span></span>
<span id="cb91-18"><a href="#cb91-18" aria-hidden="true" tabindex="-1"></a>        vertex.add_edge(obtained_carrot_vertex, rabbits[<span class="dv">0</span>] <span class="op">*</span> <span class="fl">0.1</span>)</span>
<span id="cb91-19"><a href="#cb91-19" aria-hidden="true" tabindex="-1"></a>        carrot_vertices_left[obtained_carrot_vertex.index()] <span class="op">=</span> <span class="va">True</span></span>
<span id="cb91-20"><a href="#cb91-20" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb91-21"><a href="#cb91-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> rabbits[<span class="dv">1</span>] <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb91-22"><a href="#cb91-22" aria-hidden="true" tabindex="-1"></a>        obtained_carrot_vertex <span class="op">=</span> mdph_carrot_graph.create_vertex([<span class="dv">0</span>])</span>
<span id="cb91-23"><a href="#cb91-23" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Go directly back to the state we came from</span></span>
<span id="cb91-24"><a href="#cb91-24" aria-hidden="true" tabindex="-1"></a>        obtained_carrot_vertex.add_edge(vertex, <span class="dv">1</span>)</span>
<span id="cb91-25"><a href="#cb91-25" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Rate of finding carrot</span></span>
<span id="cb91-26"><a href="#cb91-26" aria-hidden="true" tabindex="-1"></a>        vertex.add_edge(obtained_carrot_vertex, rabbits[<span class="dv">1</span>] <span class="op">*</span> <span class="fl">0.1</span>)</span>
<span id="cb91-27"><a href="#cb91-27" aria-hidden="true" tabindex="-1"></a>        carrot_vertices_right[obtained_carrot_vertex.index()] <span class="op">=</span> <span class="va">True</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-error">
<div class="ansi-escaped-output">
<pre><span class="ansi-red-fg">---------------------------------------------------------------------------</span>
<span class="ansi-red-fg">AttributeError</span>                            Traceback (most recent call last)
Cell <span class="ansi-green-fg">In[58], line 13</span>
<span class="ansi-green-fg ansi-bold">     10</span> rabbits <span style="color:rgb(98,98,98)">=</span> vertex<span style="color:rgb(98,98,98)">.</span>state()
<span class="ansi-green-fg ansi-bold">     12</span> <span style="font-weight:bold;color:rgb(0,135,0)">if</span> rabbits[<span style="color:rgb(98,98,98)">0</span>] <span style="color:rgb(98,98,98)">&gt;</span> <span style="color:rgb(98,98,98)">0</span>:
<span class="ansi-green-fg">---&gt; 13</span>     obtained_carrot_vertex <span style="color:rgb(98,98,98)">=</span> <span class="ansi-yellow-bg">mdph_carrot_graph</span><span style="color:rgb(98,98,98)" class="ansi-yellow-bg">.</span><span class="ansi-yellow-bg">create_vertex</span>([<span style="color:rgb(98,98,98)">0</span>])
<span class="ansi-green-fg ansi-bold">     14</span>     <span style="font-style:italic;color:rgb(95,135,135)"># Go directly back to the state we came from</span>
<span class="ansi-green-fg ansi-bold">     15</span>     obtained_carrot_vertex<span style="color:rgb(98,98,98)">.</span>add_edge(vertex, <span style="color:rgb(98,98,98)">1</span>)

<span class="ansi-red-fg">AttributeError</span>: 'ptdalgorithms.ptdalgorithmscpp_pybind.Graph' object has no attribute 'create_vertex'</pre>
</div>
</div>
</div>
<p>Covariance:</p>
<div id="cell-111" class="cell" data-execution_count="59">
<div class="sourceCode cell-code" id="cb92"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb92-1"><a href="#cb92-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb92-2"><a href="#cb92-2" aria-hidden="true" tabindex="-1"></a>carrot_vertices_left <span class="op">=</span> carrot_vertices_left[<span class="dv">0</span>:mdph_carrot_graph.vertices_length()]</span>
<span id="cb92-3"><a href="#cb92-3" aria-hidden="true" tabindex="-1"></a>carrot_vertices_right <span class="op">=</span> carrot_vertices_right[<span class="dv">0</span>:mdph_carrot_graph.vertices_length()]</span>
<span id="cb92-4"><a href="#cb92-4" aria-hidden="true" tabindex="-1"></a>mdph_carrot_graph.normalize()</span>
<span id="cb92-5"><a href="#cb92-5" aria-hidden="true" tabindex="-1"></a>rewards <span class="op">=</span> np.column_stack((carrot_vertices_left, carrot_vertices_right)).astype(<span class="bu">int</span>)</span>
<span id="cb92-6"><a href="#cb92-6" aria-hidden="true" tabindex="-1"></a>mdph_carrot_graph.covariance_discrete(rewards[:,<span class="dv">0</span>], rewards[:,<span class="dv">1</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>INFO: building reward compute graph...</code></pre>
</div>
<div class="cell-output cell-output-display" data-execution_count="59">
<pre><code>0.0</code></pre>
</div>
</div>
<p>Sampled covariance:</p>
<div id="cell-113" class="cell" data-execution_count="60">
<div class="sourceCode cell-code" id="cb95"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb95-1"><a href="#cb95-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb95-2"><a href="#cb95-2" aria-hidden="true" tabindex="-1"></a>simulations <span class="op">=</span> mdph_carrot_graph.sample_multivariate_discrete(<span class="dv">1000000</span>, rewards)</span>
<span id="cb95-3"><a href="#cb95-3" aria-hidden="true" tabindex="-1"></a>simulated_cov <span class="op">&lt;-</span> np.<span class="bu">sum</span>(simulations[<span class="dv">0</span>,:]<span class="op">*</span>simulations[<span class="dv">1</span>,:])<span class="op">/</span><span class="dv">1000000</span> <span class="op">-</span> <span class="op">\</span></span>
<span id="cb95-4"><a href="#cb95-4" aria-hidden="true" tabindex="-1"></a>                    np.<span class="bu">sum</span>(simulations[<span class="dv">0</span>,:])<span class="op">/</span><span class="dv">1000000</span><span class="op">*</span>np.<span class="bu">sum</span>(simulations[<span class="dv">1</span>,:])<span class="op">/</span><span class="dv">1000000</span></span>
<span id="cb95-5"><a href="#cb95-5" aria-hidden="true" tabindex="-1"></a>simulated_cov</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="60">
<pre><code>np.float64(0.029618498210833108)</code></pre>
</div>
</div>
<section id="parameterized-edges" class="level2">
<h2 class="anchored" data-anchor-id="parameterized-edges">Parameterized edges</h2>
<p>We can <em>parameterize</em> the edges to easily update the weights of the edge</p>
<p>We do this by assigning a <em>state</em> to the <em>edge</em>.</p>
<p>We will now also say that the rate of rabbits jumping is proportional to the number of rabbits on the island.</p>
<p>Our state is [rabbits able to jump, left flooding, right flooding]</p>
<div id="cell-116" class="cell" data-execution_count="61">
<div class="sourceCode cell-code" id="cb97"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb97-1"><a href="#cb97-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb97-2"><a href="#cb97-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> construct_rabbit_graph_params(nr_rabbits):</span>
<span id="cb97-3"><a href="#cb97-3" aria-hidden="true" tabindex="-1"></a>    <span class="co"># We represent the vector as two integers, the number of rabbits on the left and right island</span></span>
<span id="cb97-4"><a href="#cb97-4" aria-hidden="true" tabindex="-1"></a>    state_vector_length <span class="op">=</span> <span class="dv">2</span></span>
<span id="cb97-5"><a href="#cb97-5" aria-hidden="true" tabindex="-1"></a>    graph <span class="op">=</span> ptd.Graph(state_vector_length)</span>
<span id="cb97-6"><a href="#cb97-6" aria-hidden="true" tabindex="-1"></a>    initial_state <span class="op">=</span> [nr_rabbits, <span class="dv">0</span>]</span>
<span id="cb97-7"><a href="#cb97-7" aria-hidden="true" tabindex="-1"></a>    <span class="co"># The initial state is the only starting state, with 100% starting probability</span></span>
<span id="cb97-8"><a href="#cb97-8" aria-hidden="true" tabindex="-1"></a>    graph.starting_vertex().add_edge(</span>
<span id="cb97-9"><a href="#cb97-9" aria-hidden="true" tabindex="-1"></a>      graph.find_or_create_vertex(initial_state),</span>
<span id="cb97-10"><a href="#cb97-10" aria-hidden="true" tabindex="-1"></a>      <span class="dv">1</span></span>
<span id="cb97-11"><a href="#cb97-11" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb97-12"><a href="#cb97-12" aria-hidden="true" tabindex="-1"></a>    index <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb97-13"><a href="#cb97-13" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Iterate over all unvisited vertices</span></span>
<span id="cb97-14"><a href="#cb97-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> index <span class="op">&lt;</span> graph.vertices_length():</span>
<span id="cb97-15"><a href="#cb97-15" aria-hidden="true" tabindex="-1"></a>      vertex <span class="op">=</span> graph.vertex_at(index)</span>
<span id="cb97-16"><a href="#cb97-16" aria-hidden="true" tabindex="-1"></a>      state <span class="op">=</span> vertex.state()</span>
<span id="cb97-17"><a href="#cb97-17" aria-hidden="true" tabindex="-1"></a>      <span class="cf">if</span> state[<span class="dv">0</span>] <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb97-18"><a href="#cb97-18" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Rabbit jump left to right</span></span>
<span id="cb97-19"><a href="#cb97-19" aria-hidden="true" tabindex="-1"></a>        child_state <span class="op">=</span> [state[<span class="dv">0</span>] <span class="op">-</span> <span class="dv">1</span>, state[<span class="dv">1</span>] <span class="op">+</span> <span class="dv">1</span>]</span>
<span id="cb97-20"><a href="#cb97-20" aria-hidden="true" tabindex="-1"></a>        vertex.add_edge_parameterized(</span>
<span id="cb97-21"><a href="#cb97-21" aria-hidden="true" tabindex="-1"></a>          graph.find_or_create_vertex(child_state),</span>
<span id="cb97-22"><a href="#cb97-22" aria-hidden="true" tabindex="-1"></a>          <span class="dv">0</span>,</span>
<span id="cb97-23"><a href="#cb97-23" aria-hidden="true" tabindex="-1"></a>          [state[<span class="dv">0</span>],<span class="dv">0</span>,<span class="dv">0</span>]</span>
<span id="cb97-24"><a href="#cb97-24" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb97-25"><a href="#cb97-25" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Left island flooding</span></span>
<span id="cb97-26"><a href="#cb97-26" aria-hidden="true" tabindex="-1"></a>        child_state <span class="op">=</span> c(<span class="dv">0</span>, state[<span class="dv">1</span>])</span>
<span id="cb97-27"><a href="#cb97-27" aria-hidden="true" tabindex="-1"></a>        vertex.add_edge_parameterized(</span>
<span id="cb97-28"><a href="#cb97-28" aria-hidden="true" tabindex="-1"></a>          graph.find_or_create_vertex(child_state),</span>
<span id="cb97-29"><a href="#cb97-29" aria-hidden="true" tabindex="-1"></a>          <span class="dv">0</span>,</span>
<span id="cb97-30"><a href="#cb97-30" aria-hidden="true" tabindex="-1"></a>          [<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">0</span>]</span>
<span id="cb97-31"><a href="#cb97-31" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb97-32"><a href="#cb97-32" aria-hidden="true" tabindex="-1"></a>      <span class="cf">if</span> state[<span class="dv">1</span>] <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb97-33"><a href="#cb97-33" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Rabbit jump right to left</span></span>
<span id="cb97-34"><a href="#cb97-34" aria-hidden="true" tabindex="-1"></a>        child_state <span class="op">=</span> [state[<span class="dv">0</span>] <span class="op">+</span> <span class="dv">1</span>, state[<span class="dv">1</span>] <span class="op">-</span> <span class="dv">1</span>]</span>
<span id="cb97-35"><a href="#cb97-35" aria-hidden="true" tabindex="-1"></a>        vertex.add_edge_parameterized(</span>
<span id="cb97-36"><a href="#cb97-36" aria-hidden="true" tabindex="-1"></a>          graph.find_or_create_vertex(child_state),</span>
<span id="cb97-37"><a href="#cb97-37" aria-hidden="true" tabindex="-1"></a>          <span class="dv">0</span>, </span>
<span id="cb97-38"><a href="#cb97-38" aria-hidden="true" tabindex="-1"></a>          [state[<span class="dv">1</span>],<span class="dv">0</span>,<span class="dv">0</span>]</span>
<span id="cb97-39"><a href="#cb97-39" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb97-40"><a href="#cb97-40" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Right island flooding with rate of 4</span></span>
<span id="cb97-41"><a href="#cb97-41" aria-hidden="true" tabindex="-1"></a>        child_state <span class="op">=</span> [state[<span class="dv">0</span>], <span class="dv">0</span>]</span>
<span id="cb97-42"><a href="#cb97-42" aria-hidden="true" tabindex="-1"></a>        vertex.add_edge_parameterized(</span>
<span id="cb97-43"><a href="#cb97-43" aria-hidden="true" tabindex="-1"></a>          graph.find_or_create_vertex(child_state),</span>
<span id="cb97-44"><a href="#cb97-44" aria-hidden="true" tabindex="-1"></a>          <span class="dv">0</span>,</span>
<span id="cb97-45"><a href="#cb97-45" aria-hidden="true" tabindex="-1"></a>          [<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">1</span>]</span>
<span id="cb97-46"><a href="#cb97-46" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb97-47"><a href="#cb97-47" aria-hidden="true" tabindex="-1"></a>      index <span class="op">=</span> index <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb97-48"><a href="#cb97-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb97-49"><a href="#cb97-49" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span>(graph)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The parameterized edges have what ever weight is assigned to them, and the state does not by itself mean anything.</p>
<div id="cell-118" class="cell" data-execution_count="62">
<div class="sourceCode cell-code" id="cb98"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb98-1"><a href="#cb98-1" aria-hidden="true" tabindex="-1"></a>param_graph <span class="op">=</span> construct_rabbit_graph_params(<span class="dv">2</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>If we let the edge have a state, this gives us an easy way of changing the weights based on some model parameters. In this case, it is the rate of jumping left rate of flooding and right rate of flooding.</p>
<p>The update simply takes the inner product of the state vector and the model parameters, e.g.&nbsp;if the state is x1, x2 and the parameters are p1, p2, then the weight of the edge becomed x1<em>p1+x2</em>p2</p>
<div id="cell-120" class="cell" data-execution_count="63">
<div class="sourceCode cell-code" id="cb99"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb99-1"><a href="#cb99-1" aria-hidden="true" tabindex="-1"></a>param_graph.update_parameterized_weights([<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">4</span>])</span>
<span id="cb99-2"><a href="#cb99-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Expectation (1,2,4):"</span>, param_graph.expectation())</span>
<span id="cb99-3"><a href="#cb99-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb99-4"><a href="#cb99-4" aria-hidden="true" tabindex="-1"></a>param_graph.update_parameterized_weights([<span class="dv">2</span>, <span class="dv">2</span>, <span class="dv">4</span>])</span>
<span id="cb99-5"><a href="#cb99-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Expectation (1,2,4):"</span>, param_graph.expectation())</span>
<span id="cb99-6"><a href="#cb99-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb99-7"><a href="#cb99-7" aria-hidden="true" tabindex="-1"></a>param_graph.update_parameterized_weights([<span class="dv">2</span>, <span class="dv">4</span>, <span class="dv">4</span>])</span>
<span id="cb99-8"><a href="#cb99-8" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Expectation (1,2,4):"</span>, param_graph.expectation())</span>
<span id="cb99-9"><a href="#cb99-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb99-10"><a href="#cb99-10" aria-hidden="true" tabindex="-1"></a>param_graph.update_parameterized_weights([<span class="dv">2</span>, <span class="dv">4</span>, <span class="dv">18</span>])</span>
<span id="cb99-11"><a href="#cb99-11" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Expectation (1,2,4):"</span>, param_graph.expectation())</span>
<span id="cb99-12"><a href="#cb99-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb99-13"><a href="#cb99-13" aria-hidden="true" tabindex="-1"></a>param_graph.update_parameterized_weights([<span class="dv">8</span>, <span class="dv">4</span>, <span class="dv">18</span>])</span>
<span id="cb99-14"><a href="#cb99-14" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Expectation (1,2,4):"</span>, param_graph.expectation())</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Expectation (1,2,4): 0.5083056478405314
Expectation (1,2,4): 0.49565217391304334
Expectation (1,2,4): 0.30000000000000004
Expectation (1,2,4): 0.22709632268736477
Expectation (1,2,4): 0.17719439369563442</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>INFO: building reward compute graph...
INFO: building reward compute graph...
INFO: building reward compute graph...
INFO: building reward compute graph...
INFO: building reward compute graph...</code></pre>
</div>
</div>
<p>Note that the moment graph <em>has</em> to be recalculated after updating weights</p>
<div id="cell-122" class="cell" data-execution_count="64">
<div class="sourceCode cell-code" id="cb102"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb102-1"><a href="#cb102-1" aria-hidden="true" tabindex="-1"></a>param_graph.update_parameterized_weights([<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">4</span>])</span>
<span id="cb102-2"><a href="#cb102-2" aria-hidden="true" tabindex="-1"></a><span class="co">#param_graph.as_matrices()</span></span>
<span id="cb102-3"><a href="#cb102-3" aria-hidden="true" tabindex="-1"></a>      </span>
<span id="cb102-4"><a href="#cb102-4" aria-hidden="true" tabindex="-1"></a>param_graph.update_parameterized_weights([<span class="dv">8</span>, <span class="dv">4</span>, <span class="dv">18</span>])</span>
<span id="cb102-5"><a href="#cb102-5" aria-hidden="true" tabindex="-1"></a><span class="co">#param_graph.as_matrices()</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="time-inhomogeneity" class="level2">
<h2 class="anchored" data-anchor-id="time-inhomogeneity">Time inhomogeneity</h2>
<p>If the weights change over time - or new edges are added!</p>
<p>Then the distribution is time inhomogeneous. The api also supports such distributions, but in limited manner.</p>
<p>Like the pph, dph, etc. functions, it is a (very good) approximation based on very small steps. If the rates change dramatically, set the granularity as an argument to the functions!! E.g. set it to a high enough value.</p>
<p>If we pick a time far into the future, we can integrate under the pdf to find the expectation!</p>
<p>Integrating over accumulated visiting time:</p>
<div id="cell-126" class="cell" data-execution_count="65">
<div class="sourceCode cell-code" id="cb103"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb103-1"><a href="#cb103-1" aria-hidden="true" tabindex="-1"></a><span class="bu">sum</span>(graph.accumulated_visiting_time(<span class="dv">10</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="65">
<pre><code>0.5038265306014538</code></pre>
</div>
</div>
<p>The first moment (expectation):</p>
<div id="cell-128" class="cell" data-execution_count="66">
<div class="sourceCode cell-code" id="cb105"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb105-1"><a href="#cb105-1" aria-hidden="true" tabindex="-1"></a>graph.expectation()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="66">
<pre><code>0.5038265306122448</code></pre>
</div>
</div>
<p>Say at a certain point in time, the flooding starts!</p>
<p>In the beginning, there is <em>no</em> flooding</p>
<div id="cell-130" class="cell" data-execution_count="67">
<div class="sourceCode cell-code" id="cb107"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb107-1"><a href="#cb107-1" aria-hidden="true" tabindex="-1"></a>param_graph.update_parameterized_weights([<span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>We can build a context to step over the distribution. Weights can be freely changed and edges added in such a context</p>
<div id="cell-132" class="cell" data-execution_count="68">
<div class="sourceCode cell-code" id="cb108"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb108-1"><a href="#cb108-1" aria-hidden="true" tabindex="-1"></a><span class="co"># import ptdalgorithms as ptd</span></span>
<span id="cb108-2"><a href="#cb108-2" aria-hidden="true" tabindex="-1"></a><span class="co"># import numpy as np</span></span>
<span id="cb108-3"><a href="#cb108-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-4"><a href="#cb108-4" aria-hidden="true" tabindex="-1"></a><span class="co"># def c(*args):</span></span>
<span id="cb108-5"><a href="#cb108-5" aria-hidden="true" tabindex="-1"></a><span class="co">#     elem = []</span></span>
<span id="cb108-6"><a href="#cb108-6" aria-hidden="true" tabindex="-1"></a><span class="co">#     for arg in args:</span></span>
<span id="cb108-7"><a href="#cb108-7" aria-hidden="true" tabindex="-1"></a><span class="co">#         if hasattr(arg, '__len__') and len(arg) &gt; 1:</span></span>
<span id="cb108-8"><a href="#cb108-8" aria-hidden="true" tabindex="-1"></a><span class="co">#             elem.extend(arg)</span></span>
<span id="cb108-9"><a href="#cb108-9" aria-hidden="true" tabindex="-1"></a><span class="co">#         else:</span></span>
<span id="cb108-10"><a href="#cb108-10" aria-hidden="true" tabindex="-1"></a><span class="co">#             elem.append(arg)</span></span>
<span id="cb108-11"><a href="#cb108-11" aria-hidden="true" tabindex="-1"></a><span class="co">#     return np.array(elem)</span></span>
<span id="cb108-12"><a href="#cb108-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-13"><a href="#cb108-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-14"><a href="#cb108-14" aria-hidden="true" tabindex="-1"></a><span class="co"># nr_rabbits, flood_left, flood_right = 2, 2, 4</span></span>
<span id="cb108-15"><a href="#cb108-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-16"><a href="#cb108-16" aria-hidden="true" tabindex="-1"></a><span class="co"># # we represent the vector as two integers, the number of </span></span>
<span id="cb108-17"><a href="#cb108-17" aria-hidden="true" tabindex="-1"></a><span class="co"># # rabbits on the left and right island</span></span>
<span id="cb108-18"><a href="#cb108-18" aria-hidden="true" tabindex="-1"></a><span class="co"># state_vector_length = 2</span></span>
<span id="cb108-19"><a href="#cb108-19" aria-hidden="true" tabindex="-1"></a><span class="co"># graph = ptd.Graph(state_vector_length)</span></span>
<span id="cb108-20"><a href="#cb108-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-21"><a href="#cb108-21" aria-hidden="true" tabindex="-1"></a><span class="co"># # the initial state is the only starting state, with probability 1</span></span>
<span id="cb108-22"><a href="#cb108-22" aria-hidden="true" tabindex="-1"></a><span class="co"># initial_state = c(nr_rabbits, 0)</span></span>
<span id="cb108-23"><a href="#cb108-23" aria-hidden="true" tabindex="-1"></a><span class="co"># vertex = graph.find_or_create_vertex(initial_state)</span></span>
<span id="cb108-24"><a href="#cb108-24" aria-hidden="true" tabindex="-1"></a><span class="co"># graph.starting_vertex().add_edge(vertex, 1)</span></span>
<span id="cb108-25"><a href="#cb108-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-26"><a href="#cb108-26" aria-hidden="true" tabindex="-1"></a><span class="co"># index = 1</span></span>
<span id="cb108-27"><a href="#cb108-27" aria-hidden="true" tabindex="-1"></a><span class="co"># # iterate over all unvisited vertices</span></span>
<span id="cb108-28"><a href="#cb108-28" aria-hidden="true" tabindex="-1"></a><span class="co"># while index &lt; graph.vertices_length():</span></span>
<span id="cb108-29"><a href="#cb108-29" aria-hidden="true" tabindex="-1"></a><span class="co">#     vertex = graph.vertex_at(index)</span></span>
<span id="cb108-30"><a href="#cb108-30" aria-hidden="true" tabindex="-1"></a><span class="co">#     state = vertex.state()</span></span>
<span id="cb108-31"><a href="#cb108-31" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb108-32"><a href="#cb108-32" aria-hidden="true" tabindex="-1"></a><span class="co">#     if state[0] &gt; 0:</span></span>
<span id="cb108-33"><a href="#cb108-33" aria-hidden="true" tabindex="-1"></a><span class="co">#         # rabbit jump left to right</span></span>
<span id="cb108-34"><a href="#cb108-34" aria-hidden="true" tabindex="-1"></a><span class="co">#         child_state = c(state[0] - 1, state[1] + 1)</span></span>
<span id="cb108-35"><a href="#cb108-35" aria-hidden="true" tabindex="-1"></a><span class="co">#         vertex.add_edge(</span></span>
<span id="cb108-36"><a href="#cb108-36" aria-hidden="true" tabindex="-1"></a><span class="co">#             graph.find_or_create_vertex(child_state),</span></span>
<span id="cb108-37"><a href="#cb108-37" aria-hidden="true" tabindex="-1"></a><span class="co">#             weight=1</span></span>
<span id="cb108-38"><a href="#cb108-38" aria-hidden="true" tabindex="-1"></a><span class="co">#         )</span></span>
<span id="cb108-39"><a href="#cb108-39" aria-hidden="true" tabindex="-1"></a><span class="co">#         # left island flooding</span></span>
<span id="cb108-40"><a href="#cb108-40" aria-hidden="true" tabindex="-1"></a><span class="co">#         child_state = c(0, state[1])</span></span>
<span id="cb108-41"><a href="#cb108-41" aria-hidden="true" tabindex="-1"></a><span class="co">#         vertex.add_edge(</span></span>
<span id="cb108-42"><a href="#cb108-42" aria-hidden="true" tabindex="-1"></a><span class="co">#             graph.find_or_create_vertex(child_state), </span></span>
<span id="cb108-43"><a href="#cb108-43" aria-hidden="true" tabindex="-1"></a><span class="co">#             weight=flood_left</span></span>
<span id="cb108-44"><a href="#cb108-44" aria-hidden="true" tabindex="-1"></a><span class="co">#         )</span></span>
<span id="cb108-45"><a href="#cb108-45" aria-hidden="true" tabindex="-1"></a><span class="co">#     if state[1] &gt; 0:   </span></span>
<span id="cb108-46"><a href="#cb108-46" aria-hidden="true" tabindex="-1"></a><span class="co">#         child_state = c(state[0] + 1, state[1] - 1)</span></span>
<span id="cb108-47"><a href="#cb108-47" aria-hidden="true" tabindex="-1"></a><span class="co">#         vertex.add_edge(</span></span>
<span id="cb108-48"><a href="#cb108-48" aria-hidden="true" tabindex="-1"></a><span class="co">#             graph.find_or_create_vertex(child_state),</span></span>
<span id="cb108-49"><a href="#cb108-49" aria-hidden="true" tabindex="-1"></a><span class="co">#             weight=1</span></span>
<span id="cb108-50"><a href="#cb108-50" aria-hidden="true" tabindex="-1"></a><span class="co">#         )</span></span>
<span id="cb108-51"><a href="#cb108-51" aria-hidden="true" tabindex="-1"></a><span class="co">#         # right island flooding</span></span>
<span id="cb108-52"><a href="#cb108-52" aria-hidden="true" tabindex="-1"></a><span class="co">#         child_state = c(state[0], 0)</span></span>
<span id="cb108-53"><a href="#cb108-53" aria-hidden="true" tabindex="-1"></a><span class="co">#         vertex.add_edge(</span></span>
<span id="cb108-54"><a href="#cb108-54" aria-hidden="true" tabindex="-1"></a><span class="co">#             graph.find_or_create_vertex(child_state), </span></span>
<span id="cb108-55"><a href="#cb108-55" aria-hidden="true" tabindex="-1"></a><span class="co">#             weight=flood_right</span></span>
<span id="cb108-56"><a href="#cb108-56" aria-hidden="true" tabindex="-1"></a><span class="co">#         )</span></span>
<span id="cb108-57"><a href="#cb108-57" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-58"><a href="#cb108-58" aria-hidden="true" tabindex="-1"></a><span class="co">#     index += 1</span></span>
<span id="cb108-59"><a href="#cb108-59" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb108-60"><a href="#cb108-60" aria-hidden="true" tabindex="-1"></a><span class="co"># # graph.plot(nodesep=1, ranksep=0.1)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="cell-133" class="cell" data-execution_count="69">
<div class="sourceCode cell-code" id="cb109"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb109-1"><a href="#cb109-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb109-2"><a href="#cb109-2" aria-hidden="true" tabindex="-1"></a><span class="co"># ctx = graph.distribution_context()</span></span>
<span id="cb109-3"><a href="#cb109-3" aria-hidden="true" tabindex="-1"></a><span class="co"># cdfs = []</span></span>
<span id="cb109-4"><a href="#cb109-4" aria-hidden="true" tabindex="-1"></a><span class="co"># times = []</span></span>
<span id="cb109-5"><a href="#cb109-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb109-6"><a href="#cb109-6" aria-hidden="true" tabindex="-1"></a><span class="co"># # while ctx.time() &lt; 1.5:</span></span>
<span id="cb109-7"><a href="#cb109-7" aria-hidden="true" tabindex="-1"></a><span class="co"># while ctx.cdf() &lt; 0.999:</span></span>
<span id="cb109-8"><a href="#cb109-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb109-9"><a href="#cb109-9" aria-hidden="true" tabindex="-1"></a><span class="co">#     cdfs.append(ctx.cdf())</span></span>
<span id="cb109-10"><a href="#cb109-10" aria-hidden="true" tabindex="-1"></a><span class="co">#     times.append(ctx.time())</span></span>
<span id="cb109-11"><a href="#cb109-11" aria-hidden="true" tabindex="-1"></a><span class="co">#     param_graph.update_parameterized_weights(</span></span>
<span id="cb109-12"><a href="#cb109-12" aria-hidden="true" tabindex="-1"></a><span class="co">#         [1,</span></span>
<span id="cb109-13"><a href="#cb109-13" aria-hidden="true" tabindex="-1"></a><span class="co">#         ctx.time() - 1.5, </span></span>
<span id="cb109-14"><a href="#cb109-14" aria-hidden="true" tabindex="-1"></a><span class="co">#         2 * ctx.time() - 1.5</span></span>
<span id="cb109-15"><a href="#cb109-15" aria-hidden="true" tabindex="-1"></a><span class="co">#         ]</span></span>
<span id="cb109-16"><a href="#cb109-16" aria-hidden="true" tabindex="-1"></a><span class="co">#     )</span></span>
<span id="cb109-17"><a href="#cb109-17" aria-hidden="true" tabindex="-1"></a><span class="co">#     ctx.step()</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>It increases by every time step. Time until all rabbits are dead. Flooding increases linearly after 1.5 time units:</p>
<div id="cell-135" class="cell" data-execution_count="70">
<div class="sourceCode cell-code" id="cb110"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb110-1"><a href="#cb110-1" aria-hidden="true" tabindex="-1"></a>param_graph.update_parameterized_weights([<span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>])</span>
<span id="cb110-2"><a href="#cb110-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb110-3"><a href="#cb110-3" aria-hidden="true" tabindex="-1"></a>ctx <span class="op">=</span> param_graph.distribution_context()</span>
<span id="cb110-4"><a href="#cb110-4" aria-hidden="true" tabindex="-1"></a>cdfs <span class="op">=</span> []</span>
<span id="cb110-5"><a href="#cb110-5" aria-hidden="true" tabindex="-1"></a>times <span class="op">=</span> []</span>
<span id="cb110-6"><a href="#cb110-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb110-7"><a href="#cb110-7" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> ctx.time() <span class="op">&lt;</span> <span class="fl">1.5</span>:</span>
<span id="cb110-8"><a href="#cb110-8" aria-hidden="true" tabindex="-1"></a>    cdfs.append(ctx.cdf())</span>
<span id="cb110-9"><a href="#cb110-9" aria-hidden="true" tabindex="-1"></a>    times.append(ctx.time())</span>
<span id="cb110-10"><a href="#cb110-10" aria-hidden="true" tabindex="-1"></a>    ctx.step()</span>
<span id="cb110-11"><a href="#cb110-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb110-12"><a href="#cb110-12" aria-hidden="true" tabindex="-1"></a><span class="co">#param_graph.update_parameterized_weights([1, 1, 1])</span></span>
<span id="cb110-13"><a href="#cb110-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb110-14"><a href="#cb110-14" aria-hidden="true" tabindex="-1"></a><span class="co"># at time 1.5, the flooding starts!</span></span>
<span id="cb110-15"><a href="#cb110-15" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> ctx.cdf() <span class="op">&lt;</span> <span class="fl">0.999</span>:</span>
<span id="cb110-16"><a href="#cb110-16" aria-hidden="true" tabindex="-1"></a>    cdfs.append(ctx.cdf())</span>
<span id="cb110-17"><a href="#cb110-17" aria-hidden="true" tabindex="-1"></a>    times.append(ctx.time())</span>
<span id="cb110-18"><a href="#cb110-18" aria-hidden="true" tabindex="-1"></a>    param_graph.update_parameterized_weights(</span>
<span id="cb110-19"><a href="#cb110-19" aria-hidden="true" tabindex="-1"></a>        [<span class="dv">1</span>,</span>
<span id="cb110-20"><a href="#cb110-20" aria-hidden="true" tabindex="-1"></a>        ctx.time() <span class="op">-</span> <span class="fl">1.5</span>, </span>
<span id="cb110-21"><a href="#cb110-21" aria-hidden="true" tabindex="-1"></a>        <span class="dv">2</span> <span class="op">*</span> ctx.time() <span class="op">-</span> <span class="fl">1.5</span></span>
<span id="cb110-22"><a href="#cb110-22" aria-hidden="true" tabindex="-1"></a>        ]</span>
<span id="cb110-23"><a href="#cb110-23" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb110-24"><a href="#cb110-24" aria-hidden="true" tabindex="-1"></a>    ctx.step()</span>
<span id="cb110-25"><a href="#cb110-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb110-26"><a href="#cb110-26" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">1</span>, figsize<span class="op">=</span>(<span class="dv">4</span>, <span class="dv">3</span>))</span>
<span id="cb110-27"><a href="#cb110-27" aria-hidden="true" tabindex="-1"></a>ax.plot(times, cdfs)</span>
<span id="cb110-28"><a href="#cb110-28" aria-hidden="true" tabindex="-1"></a>sns.despine()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><a href="rabbits_full_py_api_example_files/figure-html/cell-71-output-1.png" class="lightbox" data-gallery="quarto-lightbox-gallery-10"><img src="rabbits_full_py_api_example_files/figure-html/cell-71-output-1.png" width="361" height="274" class="figure-img"></a></p>
</figure>
</div>
</div>
</div>
<p>If we pick a time far into the future, we can integrate under it to find the expectation. This means that we can scale by a reward, and thereby find the marginal expectation.</p>
<p>Summing over accumulated visiting time (with reward):</p>
<div id="cell-138" class="cell" data-execution_count="71">
<div class="sourceCode cell-code" id="cb111"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb111-1"><a href="#cb111-1" aria-hidden="true" tabindex="-1"></a>np.<span class="bu">sum</span>(graph.accumulated_visiting_time(<span class="dv">10</span>)<span class="op">*</span>graph.states()[:,<span class="dv">1</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="71">
<pre><code>np.float64(0.09438775509887067)</code></pre>
</div>
</div>
<p>The first moment (expectation) (with reward):</p>
<div id="cell-140" class="cell" data-execution_count="72">
<div class="sourceCode cell-code" id="cb113"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb113-1"><a href="#cb113-1" aria-hidden="true" tabindex="-1"></a>graph.expectation(graph.states()[:,<span class="dv">1</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="72">
<pre><code>0.09438775510204081</code></pre>
</div>
</div>
<p>But if the time is <em>not</em> far into the future, we get the expectation up to a certain point in time.</p>
<p>Expectation (rewarded) when truncating at 0.05 time:</p>
<div id="cell-143" class="cell" data-execution_count="73">
<div class="sourceCode cell-code" id="cb115"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb115-1"><a href="#cb115-1" aria-hidden="true" tabindex="-1"></a>np.<span class="bu">sum</span>(graph.accumulated_visiting_time(<span class="fl">0.05</span>)<span class="op">*</span>graph.states()[:,<span class="dv">1</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="73">
<pre><code>np.float64(0.0011713234985744549)</code></pre>
</div>
</div>
<p>Untruncated expectation:</p>
<div id="cell-145" class="cell" data-execution_count="74">
<div class="sourceCode cell-code" id="cb117"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb117-1"><a href="#cb117-1" aria-hidden="true" tabindex="-1"></a>graph.expectation(graph.states()[:,<span class="dv">1</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="74">
<pre><code>0.09438775510204081</code></pre>
</div>
</div>
<p>Expectation (rewarded) when <em>starting</em> at 0.05 time:</p>
<div id="cell-147" class="cell" data-execution_count="75">
<div class="sourceCode cell-code" id="cb119"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb119-1"><a href="#cb119-1" aria-hidden="true" tabindex="-1"></a>graph.expected_waiting_time(graph.states()[:,<span class="dv">1</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="75">
<pre><code>[0.09438775510204081,
 0.09438775510204081,
 0.28316326530612246,
 0.0,
 0.4566326530612244,
 0.21428571428571422,
 0.0714285714285714]</code></pre>
</div>
</div>
<div id="cell-148" class="cell" data-execution_count="76">
<div class="sourceCode cell-code" id="cb121"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb121-1"><a href="#cb121-1" aria-hidden="true" tabindex="-1"></a>np.<span class="bu">sum</span>(graph.stop_probability(<span class="fl">0.05</span>)<span class="op">*</span>np.array(graph.expected_waiting_time(graph.states()[:,<span class="dv">1</span>])))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="76">
<pre><code>np.float64(0.09325811466426455)</code></pre>
</div>
</div>
<p>Subtracting these gives the <em>same</em> value:</p>
<div id="cell-150" class="cell" data-execution_count="77">
<div class="sourceCode cell-code" id="cb123"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb123-1"><a href="#cb123-1" aria-hidden="true" tabindex="-1"></a>(graph.expectation(graph.states()[:,<span class="dv">1</span>]) <span class="op">\</span></span>
<span id="cb123-2"><a href="#cb123-2" aria-hidden="true" tabindex="-1"></a>     <span class="op">-</span> np.<span class="bu">sum</span>(graph.stop_probability(<span class="fl">0.05</span>) <span class="op">\</span></span>
<span id="cb123-3"><a href="#cb123-3" aria-hidden="true" tabindex="-1"></a>              <span class="op">*</span> np.array(graph.expected_waiting_time(graph.states()[:,<span class="dv">1</span>])))</span>
<span id="cb123-4"><a href="#cb123-4" aria-hidden="true" tabindex="-1"></a>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="77">
<pre><code>np.float64(0.0011296404377762609)</code></pre>
</div>
</div>
<p>We can increase granularity for better performance:</p>
<div id="cell-152" class="cell" data-execution_count="78">
<div class="sourceCode cell-code" id="cb125"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb125-1"><a href="#cb125-1" aria-hidden="true" tabindex="-1"></a>np.<span class="bu">sum</span>(graph.accumulated_visiting_time(<span class="fl">0.05</span>, granularity<span class="op">=</span><span class="dv">1000000</span>)<span class="op">*</span>graph.states()[:,<span class="dv">1</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="78">
<pre><code>np.float64(0.0011138317897953385)</code></pre>
</div>
</div>
</section>
<section id="building-the-state-space-in-c" class="level2">
<h2 class="anchored" data-anchor-id="building-the-state-space-in-c">Building the state space in C</h2>
<p>Very large models can be take a long time to construct. So if you have deloped a model that you need to construct repeatedly, the library allow you to implement the state construction as a stand-alone C/C++ extension available as python module.</p>
<p>The C code building the state space for the rabit model looks like this:</p>
<pre class="{c}"><code>ptdalgorithms::Graph build(int starting_rabbits, float flooding_left, float flooding_right) {

    size_t state_size = 2;
    struct ptd_graph *graph = ptd_graph_create(state_size);
    struct ptd_avl_tree *avl_tree = ptd_avl_tree_create(state_size);
    int *initial_state = (int*)calloc(graph-&gt;state_length, sizeof(*initial_state));
    int *child_state = (int*)calloc(graph-&gt;state_length, sizeof(*initial_state));
    initial_state[0] = starting_rabbits;
    ptd_graph_add_edge(
            graph-&gt;starting_vertex,
            ptd_find_or_create_vertex(graph, avl_tree, initial_state),
            1
    );
    for (size_t k = 1; k &lt; graph-&gt;vertices_length; k++) {
        struct ptd_vertex *vertex = graph-&gt;vertices[k];
        int *state = vertex-&gt;state;
        if (state[0] &gt; 0) {
            memcpy(child_state, vertex-&gt;state, graph-&gt;state_length * sizeof(int));
            child_state[0] -= 1;
            child_state[1] += 1;

            ptd_graph_add_edge(
                    vertex,
                    ptd_find_or_create_vertex(graph, avl_tree, child_state),
                    1
            );
            memcpy(child_state, vertex-&gt;state, graph-&gt;state_length * sizeof(int));
            child_state[0] = 0;
            ptd_graph_add_edge(
                    vertex,
                    ptd_find_or_create_vertex(graph, avl_tree, child_state),
                    flooding_left
            );
        }
        if (state[1] &gt; 0) {
            memcpy(child_state, vertex-&gt;state, graph-&gt;state_length * sizeof(int));
            child_state[1] -= 1;
            child_state[0] += 1;
            ptd_graph_add_edge(
                    vertex,
                    ptd_find_or_create_vertex(graph, avl_tree, child_state),
                    1
            );
            memcpy(child_state, vertex-&gt;state, graph-&gt;state_length * sizeof(int));
            child_state[1] = 0;
            ptd_graph_add_edge(
                    vertex,
                    ptd_find_or_create_vertex(graph, avl_tree, child_state),
                    flooding_right
            );
        }
    }
    free(child_state);
    ptdalgorithms::Graph *result = new ptdalgorithms::Graph(graph, avl_tree);
    return *result;
}

To access the function from python, you need to put it a separate file (`rabbit_state_space.cpp`) with the header and footer shown below:

```{c}
#include &lt;pybind11/pybind11.h&gt;
#include &lt;ptdalgorithms.h&gt;
#include "stdint.h"
#include "stdlib.h"

namespace py = pybind11;
using namespace pybind11::literals;
/*******************************************/


/* Your build function goes here */


/********************************************/
PYBIND11_MODULE(rabbit_state_space, m) {     /* &lt;- NB: the model name must match the file name */
     m.def("build", &amp;build);
}

/*
&lt;%
setup_pybind11(cfg)
%&gt;
*/</code></pre>
<p>You can see the complete code in <a href="rabbit_state_space.cpp">rabbit_state_space.cpp</a>.</p>
<p>Then all you need to do is install cppimport</p>
<div id="cell-161" class="cell" data-execution_count="79">
<div class="sourceCode cell-code" id="cb128"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb128-1"><a href="#cb128-1" aria-hidden="true" tabindex="-1"></a><span class="op">!</span> pip install cppimport</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Requirement already satisfied: cppimport in /Users/kmt/miniconda3/envs/ptd/lib/python3.11/site-packages (22.8.2)
Requirement already satisfied: mako in /Users/kmt/miniconda3/envs/ptd/lib/python3.11/site-packages (from cppimport) (1.3.9)
Requirement already satisfied: pybind11 in /Users/kmt/miniconda3/envs/ptd/lib/python3.11/site-packages (from cppimport) (2.13.6)
Requirement already satisfied: filelock in /Users/kmt/miniconda3/envs/ptd/lib/python3.11/site-packages (from cppimport) (3.13.1)
Requirement already satisfied: MarkupSafe&gt;=0.9.2 in /Users/kmt/miniconda3/envs/ptd/lib/python3.11/site-packages (from mako-&gt;cppimport) (2.1.5)</code></pre>
</div>
</div>
<p>and then run this code to import your build function.</p>
<div id="cell-163" class="cell" data-execution_count="80">
<div class="sourceCode cell-code" id="cb130"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb130-1"><a href="#cb130-1" aria-hidden="true" tabindex="-1"></a><span class="co"># import ptdalgorithms</span></span>
<span id="cb130-2"><a href="#cb130-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> cppimport.import_hook</span>
<span id="cb130-3"><a href="#cb130-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> rabbit_state_space <span class="co"># this will pause for a moment to compile the module</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Then you can use it to construct your graph like this:</p>
<div id="cell-165" class="cell" data-execution_count="81">
<div class="sourceCode cell-code" id="cb131"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb131-1"><a href="#cb131-1" aria-hidden="true" tabindex="-1"></a>graph <span class="op">=</span> ptd.Graph(rabbit_state_space.build(<span class="dv">2</span>, <span class="dv">2</span>, <span class="dv">4</span>))</span>
<span id="cb131-2"><a href="#cb131-2" aria-hidden="true" tabindex="-1"></a>graph.plot()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="81">
<div>
<figure class="figure">
<p><a href="rabbits_full_py_api_example_files/figure-html/cell-82-output-1.svg" class="lightbox" data-gallery="quarto-lightbox-gallery-11"><img src="rabbits_full_py_api_example_files/figure-html/cell-82-output-1.svg" class="img-fluid figure-img"></a></p>
</figure>
</div>
</div>
</div>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/munch-group\.github\.io\/PtDAlgorithms\/");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->
<script>var lightboxQuarto = GLightbox({"closeEffect":"zoom","descPosition":"bottom","loop":false,"openEffect":"zoom","selector":".lightbox"});
(function() {
  let previousOnload = window.onload;
  window.onload = () => {
    if (previousOnload) {
      previousOnload();
    }
    lightboxQuarto.on('slide_before_load', (data) => {
      const { slideIndex, slideNode, slideConfig, player, trigger } = data;
      const href = trigger.getAttribute('href');
      if (href !== null) {
        const imgEl = window.document.querySelector(`a[href="${href}"] img`);
        if (imgEl !== null) {
          const srcAttr = imgEl.getAttribute("src");
          if (srcAttr && srcAttr.startsWith("data:")) {
            slideConfig.href = srcAttr;
          }
        }
      } 
    });
  
    lightboxQuarto.on('slide_after_load', (data) => {
      const { slideIndex, slideNode, slideConfig, player, trigger } = data;
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(slideNode);
      }
    });
  
  };
  
})();
          </script>




</body></html>