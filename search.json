[
  {
    "objectID": "c_api/index.html",
    "href": "c_api/index.html",
    "title": "ptdalgorithms",
    "section": "",
    "text": "These pages are under construction"
  },
  {
    "objectID": "api/Edge.html",
    "href": "api/Edge.html",
    "title": "Edge",
    "section": "",
    "text": "ptdalgorithms.Edge()\n\n\n\n\n\nName\nDescription\n\n\n\n\nto\nto(self: ptdalgorithms.ptdalgorithmscpp_pybind.Edge) -&gt; ptdalgorithms.ptdalgorithmscpp_pybind.Vertex\n\n\nupdate_weight\nupdate_weight(self: ptdalgorithms.ptdalgorithmscpp_pybind.Edge, arg0: float) -&gt; None\n\n\nweight\nweight(self: ptdalgorithms.ptdalgorithmscpp_pybind.Edge) -&gt; float\n\n\n\n\n\nptdalgorithms.Edge.to()\nto(self: ptdalgorithms.ptdalgorithmscpp_pybind.Edge) -&gt; ptdalgorithms.ptdalgorithmscpp_pybind.Vertex\n\n\n\nptdalgorithms.Edge.update_weight()\nupdate_weight(self: ptdalgorithms.ptdalgorithmscpp_pybind.Edge, arg0: float) -&gt; None\n\n\n\nptdalgorithms.Edge.weight()\nweight(self: ptdalgorithms.ptdalgorithmscpp_pybind.Edge) -&gt; float",
    "crumbs": [
      "Some section",
      "Edge"
    ]
  },
  {
    "objectID": "api/Edge.html#methods",
    "href": "api/Edge.html#methods",
    "title": "Edge",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nto\nto(self: ptdalgorithms.ptdalgorithmscpp_pybind.Edge) -&gt; ptdalgorithms.ptdalgorithmscpp_pybind.Vertex\n\n\nupdate_weight\nupdate_weight(self: ptdalgorithms.ptdalgorithmscpp_pybind.Edge, arg0: float) -&gt; None\n\n\nweight\nweight(self: ptdalgorithms.ptdalgorithmscpp_pybind.Edge) -&gt; float\n\n\n\n\n\nptdalgorithms.Edge.to()\nto(self: ptdalgorithms.ptdalgorithmscpp_pybind.Edge) -&gt; ptdalgorithms.ptdalgorithmscpp_pybind.Vertex\n\n\n\nptdalgorithms.Edge.update_weight()\nupdate_weight(self: ptdalgorithms.ptdalgorithmscpp_pybind.Edge, arg0: float) -&gt; None\n\n\n\nptdalgorithms.Edge.weight()\nweight(self: ptdalgorithms.ptdalgorithmscpp_pybind.Edge) -&gt; float",
    "crumbs": [
      "Some section",
      "Edge"
    ]
  },
  {
    "objectID": "api/index.html",
    "href": "api/index.html",
    "title": "Function reference",
    "section": "",
    "text": "Some description…\n\n\n\nGraph\n\n\n\nVertex\n\n\n\nEdge",
    "crumbs": [
      "Function reference"
    ]
  },
  {
    "objectID": "api/index.html#some-section",
    "href": "api/index.html#some-section",
    "title": "Function reference",
    "section": "",
    "text": "Some description…\n\n\n\nGraph\n\n\n\nVertex\n\n\n\nEdge",
    "crumbs": [
      "Function reference"
    ]
  },
  {
    "objectID": "pages/tutorial.html",
    "href": "pages/tutorial.html",
    "title": "ptdalgorithms",
    "section": "",
    "text": "PythonRC\n\n\nprint(\"Hello world\")\n\n\ncat(\"Hello world\")\n\n\nprintf(\"Hello World\");"
  },
  {
    "objectID": "pages/moments.html",
    "href": "pages/moments.html",
    "title": "Moments",
    "section": "",
    "text": "This pages is under construction",
    "crumbs": [
      "Basics",
      "Moments"
    ]
  },
  {
    "objectID": "pages/state_space.html",
    "href": "pages/state_space.html",
    "title": "State space",
    "section": "",
    "text": "The state-space is built as a graph using an simple API and take up very little space compared to a matrix representation. It handles millions of vertices (states) and edges (transitions) and is munch faster than the traditional matrix-based computation relying on (sparse) matrix inversion and exponentiation.\nConsider this model: Rabbits jump between two islands at a rate of one. The two islands are flooded at rates 2 and 4 drowning all rabbits on the flooded island. The end (absorbing) is when no more rabbits are left.\nIn ptdalgorithms, each state is represented by a sequence of integers. To represent states in the rabbit model, we only need two such integer to represent the number of rabbits on the left and right islands. Laid out as in the above picture, the states are:\nTo skip some of the boilerplate you can pass a callback function and an initial state to Graph. The callback function must take as the only argument a list of int representing a state, and return: a list of tuples that each represent reachable child state and the associated transition rate. To create a callback function, just think of rules of your model and ask yourself:\nHere is an example for our rabbit model: If the current state is “two rabbits on the left island” ([2, 0]), the reachable states are: “one rabbit on each island” ([1, 1]) if one rabbit jumps and and “no rabbits” ([0, 0]) if the island is flodded. So if the callback function is called like this:\nit should return\nTogether, the callback and initial state fully specifies the model. Here is what they look like for the rabbit model:\nnr_rabbits, flood_left, flood_right = 2, 2, 4\n\ndef rabbit_islands(state):\n    nr_left, nr_right = state\n    reachable = []\n    if state[0] &gt; 0:\n        reachable.append(([nr_left-1, nr_right+1], 1))\n        reachable.append(([0,         nr_right  ], flood_left))\n    if state[1] &gt; 0:   \n        reachable.append(([nr_left+1, nr_right-1], 1))\n        reachable.append(([nr_left,   0         ], flood_right))\n    return reachable\n\ninitial_state = [nr_rabbits, 0]\nTo then build the state space all you need to do is:\nimport ptdalgorithms as ptd\n\ngraph = ptd.Graph(callback=rabbit_islands, initial=initial_state)\nPlot it to make sure it looks as expected. The gray S state is the “starting state” immediately transiting one or more model states where the model is allowed to begin. In the rabbit model, S goes to state 2,0 with probability 1 because the model can only begin there. The end (absorbing) state 0,0 is also colored gray.\ngraph.plot()",
    "crumbs": [
      "Basics",
      "State space"
    ]
  },
  {
    "objectID": "pages/state_space.html#off-to-the-races",
    "href": "pages/state_space.html#off-to-the-races",
    "title": "State space",
    "section": "Off to the races",
    "text": "Off to the races\nNow the world is at your command. To scratch the surfance you can compute the expected time to rabbit extinction:\n\ngraph.expectation()\n\n0.5038265306122448\n\n\nbut there is so much more you can do to explore your rabbit model. For a full exposé of the API using the rabbit example see the full python API example.\n\n\n\n\n\n\nThis pages is under construction",
    "crumbs": [
      "Basics",
      "State space"
    ]
  },
  {
    "objectID": "pages/state_space.html#learning-more",
    "href": "pages/state_space.html#learning-more",
    "title": "State space",
    "section": "Learning more",
    "text": "Learning more\n\nSee Python API walk through for a full example of the Python API.\nSee R API walk through for a full example of the R API.",
    "crumbs": [
      "Basics",
      "State space"
    ]
  },
  {
    "objectID": "pages/state_space.html#citing-ptdalgorithms",
    "href": "pages/state_space.html#citing-ptdalgorithms",
    "title": "State space",
    "section": "Citing ptdalgorithms",
    "text": "Citing ptdalgorithms\nGraph-based algorithms for phase-type distributions, Statistics and Computing (2022)",
    "crumbs": [
      "Basics",
      "State space"
    ]
  },
  {
    "objectID": "pages/getting_started.html",
    "href": "pages/getting_started.html",
    "title": "Getting started",
    "section": "",
    "text": "The ptdalgorithms library provides fast and scalable algorithms for constructing and computing properties of phase-type distributions with support for both continuous and discrete, unrewarded and rewarded, univariate and multivariate distributions. For sparse models, it can be orders of magnitude faster. The code is written in C, but exposes an interface to both C, R and Python through a C++ layer.\nThe library computes moments (e.g. expectation, variance, covariance), distribution functions (pdf, cdf, pmf), laplace transform, and Markov chain stopping time probabilities. Although phase-type distributions are time-homogeneous, the library also computes moments and univariate distributions for epoch-wise time-inhomogeneous models as well as full joint probability distributions.",
    "crumbs": [
      "Getting started"
    ]
  },
  {
    "objectID": "pages/getting_started.html#installation",
    "href": "pages/getting_started.html#installation",
    "title": "Getting started",
    "section": "Installation",
    "text": "Installation\nconda install -c munch-group -c conda-forge ptdalgorithms",
    "crumbs": [
      "Getting started"
    ]
  },
  {
    "objectID": "pages/getting_started.html#quickstart",
    "href": "pages/getting_started.html#quickstart",
    "title": "Getting started",
    "section": "Quickstart",
    "text": "Quickstart\n\n\n\n\n\n\nThis pages is under construction",
    "crumbs": [
      "Getting started"
    ]
  },
  {
    "objectID": "pages/epochs.html",
    "href": "pages/epochs.html",
    "title": "Epochs",
    "section": "",
    "text": "This pages is under construction",
    "crumbs": [
      "Advanced",
      "Epochs"
    ]
  },
  {
    "objectID": "r_api/index.html",
    "href": "r_api/index.html",
    "title": "ptdalgorithms",
    "section": "",
    "text": "These pages are under construction"
  },
  {
    "objectID": "pages/state_lumping.html",
    "href": "pages/state_lumping.html",
    "title": "State lumping",
    "section": "",
    "text": "This pages is under construction",
    "crumbs": [
      "Advanced",
      "State lumping"
    ]
  },
  {
    "objectID": "pages/laplace.html",
    "href": "pages/laplace.html",
    "title": "Laplace transform",
    "section": "",
    "text": "These pages are under construction",
    "crumbs": [
      "Basics",
      "Laplace transform"
    ]
  },
  {
    "objectID": "pages/distributions.html",
    "href": "pages/distributions.html",
    "title": "Distributions",
    "section": "",
    "text": "This pages is under construction",
    "crumbs": [
      "Basics",
      "Distributions"
    ]
  },
  {
    "objectID": "pages/coalescent_showcase.html",
    "href": "pages/coalescent_showcase.html",
    "title": "The coalescent",
    "section": "",
    "text": "import ptdalgorithms as ptd\n\nAnother example is the Coalescent, fully specified with only the code below:\n\ndef coalescent(state):\n    transitions = []\n    for i in range(nr_samples):\n        for j in range(i, nr_samples):            \n            same = int(i == j)\n            if same and state[i] &lt; 2:\n                continue\n            if not same and (state[i] &lt; 1 or state[j] &lt; 1):\n                continue \n            new = state[:]\n            new[i] -= 1\n            new[j] -= 1\n            new[i+j+1] += 1\n            transitions.append((new, state[i]*(state[j]-same)/(1+same)))\n    return transitions\n\nnr_samples = 4\ngraph = ptd.Graph(callback=coalescent, initial=[nr_samples]+[0]*nr_samples)\ngraph.plot()\n\n\n\n\n\n\n\n\nComputing the expected TMRCA is then just:\n\ngraph.expectation()\n\nINFO: building reward compute graph...\n\n\n1.5\n\n\nThe graph grows quickly with the number of samples:\n\nnr_samples = 15\ngraph = ptd.Graph(callback=coalescent, initial=[nr_samples]+[0]*nr_samples)\ngraph.plot()\n\n\n\n\n\n\n\n\n\ngraph.expectation()\n\nINFO: building reward compute graph...\n\n\n1.866666666666666\n\n\n\n\n\n\n\n\nThis pages is under construction"
  },
  {
    "objectID": "pages/joint_prob.html",
    "href": "pages/joint_prob.html",
    "title": "Joint probabilities",
    "section": "",
    "text": "This pages is under construction",
    "crumbs": [
      "Advanced",
      "Joint probabilities"
    ]
  },
  {
    "objectID": "api/Vertex.html",
    "href": "api/Vertex.html",
    "title": "Vertex",
    "section": "",
    "text": "ptdalgorithms.Vertex()\n\n\n\n\n\nName\nDescription\n\n\n\n\nadd_edge\nadd_edge(self: ptdalgorithms.ptdalgorithmscpp_pybind.Vertex, to: ptdalgorithms.ptdalgorithmscpp_pybind.Vertex, weight: float) -&gt; None\n\n\nadd_edge_parameterized\nadd_edge_parameterized(self: ptdalgorithms.ptdalgorithmscpp_pybind.Vertex, to: ptdalgorithms.ptdalgorithmscpp_pybind.Vertex, weight: float, edge_state: list[float]) -&gt; None\n\n\nae\nae(self: ptdalgorithms.ptdalgorithmscpp_pybind.Vertex, to: ptdalgorithms.ptdalgorithmscpp_pybind.Vertex, weight: float) -&gt; None\n\n\nedges\nedges(self: ptdalgorithms.ptdalgorithmscpp_pybind.Vertex) -&gt; list[ptdalgorithms::Edge]\n\n\nindex\nindex(self: ptdalgorithms.ptdalgorithmscpp_pybind.Vertex) -&gt; int\n\n\nrate\nrate(self: ptdalgorithms.ptdalgorithmscpp_pybind.Vertex) -&gt; float\n\n\nstate\nstate(self: ptdalgorithms.ptdalgorithmscpp_pybind.Vertex) -&gt; list[int]\n\n\n\n\n\nptdalgorithms.Vertex.add_edge()\nadd_edge(self: ptdalgorithms.ptdalgorithmscpp_pybind.Vertex, to: ptdalgorithms.ptdalgorithmscpp_pybind.Vertex, weight: float) -&gt; None\n//’ Adds an edge between two vertices in the graph //’ //’ @description //’ The graph represents transitions between states as //’ a weighted direction edge between two vertices. //’ //’ @seealso [ptdalgorithms::expected_waiting_time()] //’ @seealso [ptdalgorithms::moments()] //’ @seealso [ptdalgorithms::variance()] //’ @seealso [ptdalgorithms::covariance()] //’ @seealso [ptdalgorithms::graph_update_weights_parameterized()] //’ //’ @param phase_type_vertex_from The vertex that transitions from //’ @param phase_type_vertex_to The vertex that transitions to //’ @param weight The weight of the edge, i.e. the transition rate //’ @param parameterized_edge_state Optional. Associate a numeric vector to an edge, for faster computations of moments when weights are changed. //’ //’ @examples //’ graph &lt;- create_graph(4) //’ vertex_a &lt;- find_or_create_vertex(graph, c(1,2,1,0)) //’ vertex_b &lt;- find_or_create_vertex(graph, c(2,0,1,0)) //’ add_edge(vertex_a, vertex_b, 1.5)\n\n\n\nptdalgorithms.Vertex.add_edge_parameterized()\nadd_edge_parameterized(self: ptdalgorithms.ptdalgorithmscpp_pybind.Vertex, to: ptdalgorithms.ptdalgorithmscpp_pybind.Vertex, weight: float, edge_state: list[float]) -&gt; None\n\n\n\nptdalgorithms.Vertex.ae()\nae(self: ptdalgorithms.ptdalgorithmscpp_pybind.Vertex, to: ptdalgorithms.ptdalgorithmscpp_pybind.Vertex, weight: float) -&gt; None\nAlias for add_edge\n\n\n\nptdalgorithms.Vertex.edges()\nedges(self: ptdalgorithms.ptdalgorithmscpp_pybind.Vertex) -&gt; list[ptdalgorithms::Edge]\n\n\n\nptdalgorithms.Vertex.index()\nindex(self: ptdalgorithms.ptdalgorithmscpp_pybind.Vertex) -&gt; int\n\n\n\nptdalgorithms.Vertex.rate()\nrate(self: ptdalgorithms.ptdalgorithmscpp_pybind.Vertex) -&gt; float\n\n\n\nptdalgorithms.Vertex.state()\nstate(self: ptdalgorithms.ptdalgorithmscpp_pybind.Vertex) -&gt; list[int]",
    "crumbs": [
      "Some section",
      "Vertex"
    ]
  },
  {
    "objectID": "api/Vertex.html#methods",
    "href": "api/Vertex.html#methods",
    "title": "Vertex",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nadd_edge\nadd_edge(self: ptdalgorithms.ptdalgorithmscpp_pybind.Vertex, to: ptdalgorithms.ptdalgorithmscpp_pybind.Vertex, weight: float) -&gt; None\n\n\nadd_edge_parameterized\nadd_edge_parameterized(self: ptdalgorithms.ptdalgorithmscpp_pybind.Vertex, to: ptdalgorithms.ptdalgorithmscpp_pybind.Vertex, weight: float, edge_state: list[float]) -&gt; None\n\n\nae\nae(self: ptdalgorithms.ptdalgorithmscpp_pybind.Vertex, to: ptdalgorithms.ptdalgorithmscpp_pybind.Vertex, weight: float) -&gt; None\n\n\nedges\nedges(self: ptdalgorithms.ptdalgorithmscpp_pybind.Vertex) -&gt; list[ptdalgorithms::Edge]\n\n\nindex\nindex(self: ptdalgorithms.ptdalgorithmscpp_pybind.Vertex) -&gt; int\n\n\nrate\nrate(self: ptdalgorithms.ptdalgorithmscpp_pybind.Vertex) -&gt; float\n\n\nstate\nstate(self: ptdalgorithms.ptdalgorithmscpp_pybind.Vertex) -&gt; list[int]\n\n\n\n\n\nptdalgorithms.Vertex.add_edge()\nadd_edge(self: ptdalgorithms.ptdalgorithmscpp_pybind.Vertex, to: ptdalgorithms.ptdalgorithmscpp_pybind.Vertex, weight: float) -&gt; None\n//’ Adds an edge between two vertices in the graph //’ //’ @description //’ The graph represents transitions between states as //’ a weighted direction edge between two vertices. //’ //’ @seealso [ptdalgorithms::expected_waiting_time()] //’ @seealso [ptdalgorithms::moments()] //’ @seealso [ptdalgorithms::variance()] //’ @seealso [ptdalgorithms::covariance()] //’ @seealso [ptdalgorithms::graph_update_weights_parameterized()] //’ //’ @param phase_type_vertex_from The vertex that transitions from //’ @param phase_type_vertex_to The vertex that transitions to //’ @param weight The weight of the edge, i.e. the transition rate //’ @param parameterized_edge_state Optional. Associate a numeric vector to an edge, for faster computations of moments when weights are changed. //’ //’ @examples //’ graph &lt;- create_graph(4) //’ vertex_a &lt;- find_or_create_vertex(graph, c(1,2,1,0)) //’ vertex_b &lt;- find_or_create_vertex(graph, c(2,0,1,0)) //’ add_edge(vertex_a, vertex_b, 1.5)\n\n\n\nptdalgorithms.Vertex.add_edge_parameterized()\nadd_edge_parameterized(self: ptdalgorithms.ptdalgorithmscpp_pybind.Vertex, to: ptdalgorithms.ptdalgorithmscpp_pybind.Vertex, weight: float, edge_state: list[float]) -&gt; None\n\n\n\nptdalgorithms.Vertex.ae()\nae(self: ptdalgorithms.ptdalgorithmscpp_pybind.Vertex, to: ptdalgorithms.ptdalgorithmscpp_pybind.Vertex, weight: float) -&gt; None\nAlias for add_edge\n\n\n\nptdalgorithms.Vertex.edges()\nedges(self: ptdalgorithms.ptdalgorithmscpp_pybind.Vertex) -&gt; list[ptdalgorithms::Edge]\n\n\n\nptdalgorithms.Vertex.index()\nindex(self: ptdalgorithms.ptdalgorithmscpp_pybind.Vertex) -&gt; int\n\n\n\nptdalgorithms.Vertex.rate()\nrate(self: ptdalgorithms.ptdalgorithmscpp_pybind.Vertex) -&gt; float\n\n\n\nptdalgorithms.Vertex.state()\nstate(self: ptdalgorithms.ptdalgorithmscpp_pybind.Vertex) -&gt; list[int]",
    "crumbs": [
      "Some section",
      "Vertex"
    ]
  },
  {
    "objectID": "api/Graph.html",
    "href": "api/Graph.html",
    "title": "Graph",
    "section": "",
    "text": "ptdalgorithms.Graph(\n    self,\n    state_length=None,\n    callback=None,\n    initial=None,\n    trans_as_dict=False,\n)\n\n\n\n\n\nName\nDescription\n\n\n\n\naccumulated_visiting_time\naccumulated_visiting_time(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, time: float, granularity: int = 0) -&gt; list[float]\n\n\naccumulated_visits_discrete\naccumulated_visits_discrete(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, jumps: int) -&gt; list[float]\n\n\nas_matrices\nas_matrices(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph) -&gt; ptdalgorithms.ptdalgorithmscpp_pybind.MatrixRepresentation\n\n\ncdf\ncdf(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, time: numpy.ndarray[numpy.float32], granularity: numpy.ndarray[numpy.int32] = 0) -&gt; object\n\n\ncdf_discrete\ncdf_discrete(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, jumps: numpy.ndarray[numpy.int32]) -&gt; object\n\n\nclone\nclone(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph) -&gt; ptdalgorithms.ptdalgorithmscpp_pybind.Graph\n\n\ncovariance\ncovariance(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, rewards1: list[float], rewards2: list[float]) -&gt; float\n\n\ncovariance_discrete\ncovariance_discrete(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, rewards1: list[float], rewards2: list[float]) -&gt; float\n\n\ncreate_vertex\ncreate_vertex(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, state: list[int]) -&gt; ptdalgorithms::Vertex\n\n\ndefect\ndefect(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph) -&gt; float\n\n\ndistribution_context\ndistribution_context(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, granularity: int = 0) -&gt; ptdalgorithms::ProbabilityDistributionContext\n\n\ndistribution_context_discrete\ndistribution_context_discrete(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph) -&gt; ptdalgorithms::DPHProbabilityDistributionContext\n\n\nexpectation\nexpectation(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, rewards: list[float] = []) -&gt; float\n\n\nexpectation_dag\nexpectation_dag(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, rewards: list[float]) -&gt; ptdalgorithms.ptdalgorithmscpp_pybind.Graph\n\n\nexpectation_discrete\nexpectation_discrete(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, arg0: list[float]) -&gt; float\n\n\nexpected_residence_time\nexpected_residence_time(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, rewards: list[float] = []) -&gt; list[float]\n\n\nexpected_visits_discrete\nexpected_visits_discrete(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, jumps: int) -&gt; list[float]\n\n\nexpected_waiting_time\nexpected_waiting_time(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, rewards: list[float] = []) -&gt; list[float]\n\n\nfind_or_create_vertex\nfind_or_create_vertex(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, state: list[int]) -&gt; ptdalgorithms::Vertex\n\n\nfind_vertex\nfind_vertex(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, state: list[int]) -&gt; ptdalgorithms::Vertex\n\n\nfocv\nfocv(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, state: list[int]) -&gt; ptdalgorithms::Vertex\n\n\nis_acyclic\nis_acyclic(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph) -&gt; bool\n\n\nmoments\nmoments(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, power: int, rewards: list[float] = []) -&gt; list[float]\n\n\nnormalize\nnormalize(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph) -&gt; list[float]\n\n\nnormalize_discrete\nnormalize_discrete(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph) -&gt; list[float]\n\n\nnotify_change\nnotify_change(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph) -&gt; None\n\n\npdf\npdf(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, time: numpy.ndarray[numpy.float32], granularity: numpy.ndarray[numpy.int32] = 0) -&gt; object\n\n\npmf_discrete\npmf_discrete(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, jumps: numpy.ndarray[numpy.int32]) -&gt; object\n\n\nrandom_sample_discrete_stop_vertex\nrandom_sample_discrete_stop_vertex(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, jumps: int) -&gt; int\n\n\nrandom_sample_stop_vertex\nrandom_sample_stop_vertex(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, time: float) -&gt; int\n\n\nreward_transform\nreward_transform(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, rewards: list[float]) -&gt; ptdalgorithms.ptdalgorithmscpp_pybind.Graph\n\n\nreward_transform_discrete\nreward_transform_discrete(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, rewards: list[int]) -&gt; ptdalgorithms.ptdalgorithmscpp_pybind.Graph\n\n\nsample\nsample(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, n: int = 1, rewards: list[float] = []) -&gt; list[float]\n\n\nsample_discrete\nsample_discrete(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, n: int = 1, rewards: list[float] = []) -&gt; list[float]\n\n\nsample_multivariate\nsample_multivariate(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, n: int = 1, rewards: numpy.ndarray[numpy.float64[m, n]] = []) -&gt; numpy.ndarray[numpy.float64[m, n]]\n\n\nsample_multivariate_discrete\nsample_multivariate_discrete(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, n: int = 1, rewards: numpy.ndarray[numpy.float64[m, n]] = []) -&gt; numpy.ndarray[numpy.float64[m, n]]\n\n\nstarting_vertex\nstarting_vertex(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph) -&gt; ptdalgorithms::Vertex\n\n\nstate_length\nstate_length(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph) -&gt; int\n\n\nstates\nstates(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph) -&gt; numpy.ndarray[numpy.int32[m, n]]\n\n\nstop_probability\nstop_probability(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, time: float, granularity: int = 0) -&gt; list[float]\n\n\nstop_probability_discrete\nstop_probability_discrete(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, jumps: int) -&gt; list[float]\n\n\nupdate_parameterized_weights\nupdate_parameterized_weights(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, rewards: list[float]) -&gt; None\n\n\nvalidate\nvalidate(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph) -&gt; None\n\n\nvariance\nvariance(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, rewards: list[float] = []) -&gt; float\n\n\nvariance_discrete\nvariance_discrete(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, arg0: list[float]) -&gt; float\n\n\nvertex_at\nvertex_at(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, index: int) -&gt; ptdalgorithms::Vertex\n\n\nvertex_exists\nvertex_exists(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, state: list[int]) -&gt; bool\n\n\nvertices\nvertices(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph) -&gt; list[ptdalgorithms::Vertex]\n\n\nvertices_length\nvertices_length(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph) -&gt; int\n\n\n\n\n\nptdalgorithms.Graph.accumulated_visiting_time()\naccumulated_visiting_time(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, time: float, granularity: int = 0) -&gt; list[float]\n\n\n\nptdalgorithms.Graph.accumulated_visits_discrete()\naccumulated_visits_discrete(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, jumps: int) -&gt; list[float]\n\n\n\nptdalgorithms.Graph.as_matrices()\nas_matrices(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph) -&gt; ptdalgorithms.ptdalgorithmscpp_pybind.MatrixRepresentation\n\n\n\nptdalgorithms.Graph.cdf()\ncdf(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, time: numpy.ndarray[numpy.float32], granularity: numpy.ndarray[numpy.int32] = 0) -&gt; object\n\n\n\nptdalgorithms.Graph.cdf_discrete()\ncdf_discrete(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, jumps: numpy.ndarray[numpy.int32]) -&gt; object\n\n\n\nptdalgorithms.Graph.clone()\nclone(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph) -&gt; ptdalgorithms.ptdalgorithmscpp_pybind.Graph\n\n\n\nptdalgorithms.Graph.covariance()\ncovariance(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, rewards1: list[float], rewards2: list[float]) -&gt; float\n\n\n\nptdalgorithms.Graph.covariance_discrete()\ncovariance_discrete(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, rewards1: list[float], rewards2: list[float]) -&gt; float\n\n\n\nptdalgorithms.Graph.create_vertex()\ncreate_vertex(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, state: list[int]) -&gt; ptdalgorithms::Vertex\n\n\n\nptdalgorithms.Graph.defect()\ndefect(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph) -&gt; float\n\n\n\nptdalgorithms.Graph.distribution_context()\ndistribution_context(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, granularity: int = 0) -&gt; ptdalgorithms::ProbabilityDistributionContext\n\n\n\nptdalgorithms.Graph.distribution_context_discrete()\ndistribution_context_discrete(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph) -&gt; ptdalgorithms::DPHProbabilityDistributionContext\n\n\n\nptdalgorithms.Graph.expectation()\nexpectation(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, rewards: list[float] = []) -&gt; float\n//’ Computes the expectation (mean) of the phase-type distribution //’ //’ @description //’ This function invokes [ptdalgorithms::expected_waiting_times()] //’ and takes the first entry (from starting vertex) //’ //’ @return The expectation of the distribution //’ //’ @param phase_type_graph A reference to the graph created by [ptdalgorithms::create_graph()] //’ @param rewards Optional rewards, which should be applied to the phase-type distribution. Must have length equal to [ptdalgorithms::vertices_length()] //’ //’ @seealso [ptdalgorithms::expected_waiting_time()] //’ @seealso [ptdalgorithms::moments()] //’ @seealso [ptdalgorithms::variance()] //’ @seealso [ptdalgorithms::covariance()] //’ //’ @examples //’ graph &lt;- ptdalgorithms::create_graph(4) //’ v1 &lt;- ptdalgorithms::create_vertex(graph, c(1,2,3,4)) //’ v2 &lt;- ptdalgorithms::create_vertex(graph, c(4,0,3,3)) //’ a &lt;- ptdalgorithms::create_vertex(graph, c(0,0,0,0)) //’ ptdalgorithms::add_edge(ptdalgorithms::starting_vertex(graph), v1, 1) //’ ptdalgorithms::add_edge(v1, v2, 4) //’ ptdalgorithms::add_edge(v2, a, 10) //’ ptdalgorithms::expectation(graph) # =&gt; //’ 0.35 //’ ptdalgorithms::expectation(graph, c(0,2,1,0)) # =&gt; //’ 0.6 //’ ph &lt;- ptdalgorithms::graph_as_matrix(graph) //’ # This is a much faster version of //’ ph\\(IPV%*%solve(-ph\\)SIM) %% rep(1, length(ph\\(IPV)) # =&gt;\n//'   0.35\n//' ph\\)IPV%%solve(-ph\\(SIM) %*% diag(c(2,1))%*% rep(1, length(ph\\)IPV)) # =&gt; //’ 0.35\n\n\n\nptdalgorithms.Graph.expectation_dag()\nexpectation_dag(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, rewards: list[float]) -&gt; ptdalgorithms.ptdalgorithmscpp_pybind.Graph\n\n\n\nptdalgorithms.Graph.expectation_discrete()\nexpectation_discrete(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, arg0: list[float]) -&gt; float\n\n\n\nptdalgorithms.Graph.expected_residence_time()\nexpected_residence_time(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, rewards: list[float] = []) -&gt; list[float]\n\n\n\nptdalgorithms.Graph.expected_visits_discrete()\nexpected_visits_discrete(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, jumps: int) -&gt; list[float]\n\n\n\nptdalgorithms.Graph.expected_waiting_time()\nexpected_waiting_time(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, rewards: list[float] = []) -&gt; list[float]\n\n\n\nptdalgorithms.Graph.find_or_create_vertex()\nfind_or_create_vertex(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, state: list[int]) -&gt; ptdalgorithms::Vertex\n//’ Find or create a vertex matching state //’ //’ @description //’ Finds a vertex by the state parameter. If no such //’ vertex exists, it creates the vertex and adds it to //’ the graph object instead. //’ //’ @details //’ A faster and simpler version of calling [ptdalgorithms::find_vertex()] and [ptdalgorithms::create_vertex()] //’ //’ @return The newly found or inserted vertex in the graph //’ //’ @param phase_type_graph A reference to the graph created by [ptdalgorithms::create_graph()] //’ @param state An integer vector of what vertex to look for. Has length as given by state_length in [ptdalgorithms::create_graph()] //’ //’ @examples //’ graph &lt;- create_graph(4) //’ find_or_create_vertex(graph, c(1,2,1,0)) # Adds and returns the vertex //’ find_or_create_vertex(graph, c(1,2,1,0)) # Only returns the vertex //’ # graph is now changed permanently\n\n\n\nptdalgorithms.Graph.find_vertex()\nfind_vertex(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, state: list[int]) -&gt; ptdalgorithms::Vertex\n\n\n\nptdalgorithms.Graph.focv()\nfocv(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, state: list[int]) -&gt; ptdalgorithms::Vertex\nAlias for find_or_create_vertex\n\n\n\nptdalgorithms.Graph.is_acyclic()\nis_acyclic(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph) -&gt; bool\n\n\n\nptdalgorithms.Graph.moments()\nmoments(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, power: int, rewards: list[float] = []) -&gt; list[float]\n//’ Computes the first k moments of the phase-type distribution //’ //’ @description //’ This function invokes [ptdalgorithms::expected_waiting_times()] consequtively to find the first moments, //’ given by the power argument //’ //’ @return A numeric vector of the first k moments. The first entry is the first moment (mean) //’ //’ @param phase_type_graph A reference to the graph created by [ptdalgorithms::create_graph()] //’ @param power An integer of the first k moments. //’ @param rewards Optional rewards, which should be applied to the phase-type distribution. Must have length equal to [ptdalgorithms::vertices_length()] //’ //’ @seealso [ptdalgorithms::expected_waiting_time()] //’ @seealso [ptdalgorithms::expectation()] //’ @seealso [ptdalgorithms::variance()] //’ @seealso [ptdalgorithms::covariance()] //’ //’ @examples //’ graph &lt;- ptdalgorithms::create_graph(4) //’ v1 &lt;- ptdalgorithms::create_vertex(graph, c(1,2,3,4)) //’ v2 &lt;- ptdalgorithms::create_vertex(graph, c(4,0,3,3)) //’ a &lt;- ptdalgorithms::create_vertex(graph, c(0,0,0,0)) //’ ptdalgorithms::add_edge(ptdalgorithms::starting_vertex(graph), v1, 1) //’ ptdalgorithms::add_edge(v1, v2, 4) //’ ptdalgorithms::add_edge(v2, a, 10) //’ ptdalgorithms::moments(graph, 3) # =&gt; //’ (0.350000 0.097500 0.025375) //’ ptdalgorithms::moments(graph, 3, c(0,2,1,0)) # =&gt; //’ (0.600 0.160 0.041)\n\n\n\nptdalgorithms.Graph.normalize()\nnormalize(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph) -&gt; list[float]\n\n\n\nptdalgorithms.Graph.normalize_discrete()\nnormalize_discrete(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph) -&gt; list[float]\n\n\n\nptdalgorithms.Graph.notify_change()\nnotify_change(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph) -&gt; None\n\n\n\nptdalgorithms.Graph.pdf()\npdf(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, time: numpy.ndarray[numpy.float32], granularity: numpy.ndarray[numpy.int32] = 0) -&gt; object\n\n\n\nptdalgorithms.Graph.pmf_discrete()\npmf_discrete(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, jumps: numpy.ndarray[numpy.int32]) -&gt; object\n\n\n\nptdalgorithms.Graph.random_sample_discrete_stop_vertex()\nrandom_sample_discrete_stop_vertex(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, jumps: int) -&gt; int\n\n\n\nptdalgorithms.Graph.random_sample_stop_vertex()\nrandom_sample_stop_vertex(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, time: float) -&gt; int\n\n\n\nptdalgorithms.Graph.reward_transform()\nreward_transform(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, rewards: list[float]) -&gt; ptdalgorithms.ptdalgorithmscpp_pybind.Graph\n\n\n\nptdalgorithms.Graph.reward_transform_discrete()\nreward_transform_discrete(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, rewards: list[int]) -&gt; ptdalgorithms.ptdalgorithmscpp_pybind.Graph\n\n\n\nptdalgorithms.Graph.sample()\nsample(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, n: int = 1, rewards: list[float] = []) -&gt; list[float]\n\n\n\nptdalgorithms.Graph.sample_discrete()\nsample_discrete(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, n: int = 1, rewards: list[float] = []) -&gt; list[float]\n\n\n\nptdalgorithms.Graph.sample_multivariate()\nsample_multivariate(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, n: int = 1, rewards: numpy.ndarray[numpy.float64[m, n]] = []) -&gt; numpy.ndarray[numpy.float64[m, n]]\n\n\n\nptdalgorithms.Graph.sample_multivariate_discrete()\nsample_multivariate_discrete(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, n: int = 1, rewards: numpy.ndarray[numpy.float64[m, n]] = []) -&gt; numpy.ndarray[numpy.float64[m, n]]\n\n\n\nptdalgorithms.Graph.starting_vertex()\nstarting_vertex(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph) -&gt; ptdalgorithms::Vertex\n\n\n\nptdalgorithms.Graph.state_length()\nstate_length(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph) -&gt; int\n\n\n\nptdalgorithms.Graph.states()\nstates(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph) -&gt; numpy.ndarray[numpy.int32[m, n]]\n//’ Returns a matrix where each row is the state of the vertex at that index //’ //’ @return A matrix of size [ptdalgorithms::vertices_length()] where the rows match the state of the vertex at that index //’ //’ @param phase_type_graph A reference to the graph created by [ptdalgorithms::create_graph()] //’ //’ @examples //’ graph &lt;- ptdalgorithms::create_graph(4) //’ ptdalgorithms::create_vertex(graph, c(1,2,3,4)) //’ ptdalgorithms::create_vertex(graph, c(4,3,3,3)) //’ ptdalgorithms::states(graph) # =&gt; //’ # 0 0 0 0 //’ # 1 2 3 4 //’ # 4 3 3 3\n\n\n\nptdalgorithms.Graph.stop_probability()\nstop_probability(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, time: float, granularity: int = 0) -&gt; list[float]\n\n\n\nptdalgorithms.Graph.stop_probability_discrete()\nstop_probability_discrete(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, jumps: int) -&gt; list[float]\n\n\n\nptdalgorithms.Graph.update_parameterized_weights()\nupdate_parameterized_weights(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, rewards: list[float]) -&gt; None\n//’ Updates all parameterized edges of the graph by given scalars. //’ //’ @description //’ Given a vector of scalars, computes a new weight of //’ the parameterized edges in the graph by a simple inner //’ product of the edge state vector and the scalar vector. //’ //’ @details //’ A faster and simpler version to compute new moments, when //’ the user wants to try multiple different weights. //’ //’ //’ @param phase_type_graph A reference to the graph created by [ptdalgorithms::create_graph()] //’ @param scalars A numeric vector of multiplies for the edge states. //’ //’ @seealso [ptdalgorithms::expected_waiting_time()] //’ @seealso [ptdalgorithms::add_edge()] //’ //’ @examples //’ graph &lt;- create_graph(4) //’ v1 &lt;- find_or_create_vertex(graph, c(1,2,1,0)) //’ v2 &lt;- find_or_create_vertex(graph, c(2,0,1,0)) //’ add_edge(starting_vertex(graph), v1, 5) //’ add_edge(v1, v2, 0, c(5,2)) //’ edges(starting_vertex(graph))[[1]]\\(weight # =&gt; 5\n//' edges(v1)[[1]]\\)weight # =&gt; 0 //’ graph_update_weights_parameterized(graph, c(9,7)) //’ edges(starting_vertex(graph))[[1]]\\(weight # =&gt; 5\n//' edges(v1)[[1]]\\)weight # =&gt; 59\n\n\n\nptdalgorithms.Graph.validate()\nvalidate(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph) -&gt; None\n\n\n\nptdalgorithms.Graph.variance()\nvariance(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, rewards: list[float] = []) -&gt; float\n//’ Computes the variance of the phase-type distribution //’ //’ @description //’ This function invokes [ptdalgorithms::expected_waiting_times()] //’ twice to find the first and second moment //’ //’ @return The variance of the distribution //’ //’ @param phase_type_graph A reference to the graph created by [ptdalgorithms::create_graph()] //’ @param rewards Optional rewards, which should be applied to the phase-type distribution. Must have length equal to [ptdalgorithms::vertices_length()] //’ //’ @seealso [ptdalgorithms::expected_waiting_time()] //’ @seealso [ptdalgorithms::expectation()] //’ @seealso [ptdalgorithms::moments()] //’ @seealso [ptdalgorithms::covariance()] //’ //’ @examples //’ graph &lt;- ptdalgorithms::create_graph(4) //’ v1 &lt;- ptdalgorithms::create_vertex(graph, c(1,2,3,4)) //’ v2 &lt;- ptdalgorithms::create_vertex(graph, c(4,0,3,3)) //’ a &lt;- ptdalgorithms::create_vertex(graph, c(0,0,0,0)) //’ ptdalgorithms::add_edge(ptdalgorithms::starting_vertex(graph), v1, 1) //’ ptdalgorithms::add_edge(v1, v2, 4) //’ ptdalgorithms::add_edge(v2, a, 10) //’ ptdalgorithms::variance(graph) # =&gt; //’ 0.0725 //’ ptdalgorithms::variance(graph, c(0,2,1,0)) # =&gt; //’ 0.26 //’ ph &lt;- ptdalgorithms::graph_as_matrix(graph) //’ # This is a much faster version of //’ 2ph\\(IPV%*%solve(-ph\\)SIM)%%solve(-ph\\(SIM) %*% rep(1, length(ph\\)IPV)) - ph\\(IPV%*%solve(-ph\\)SIM) %% rep(1, length(ph\\(IPV)) %*% ph\\)IPV%%solve(-ph\\(SIM) %*% rep(1, length(ph\\)IPV)) # =&gt; //’ 0.0725 //’ 2ph\\(IPV%*%solve(-ph\\)SIM)%%diag(c(2,1))%%solve(-ph\\(SIM)%*%diag(c(2,1)) %*% rep(1, length(ph\\)IPV)) - ph\\(IPV%*%solve(-ph\\)SIM)%%diag(c(2,1)) %% rep(1, length(ph\\(IPV)) %*% ph\\)IPV%%solve(-ph\\(SIM)%*%diag(c(2,1)) %*% rep(1, length(ph\\)IPV)) # =&gt; //’ 0.26\n\n\n\nptdalgorithms.Graph.variance_discrete()\nvariance_discrete(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, arg0: list[float]) -&gt; float\n\n\n\nptdalgorithms.Graph.vertex_at()\nvertex_at(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, index: int) -&gt; ptdalgorithms::Vertex\n\n\n\nptdalgorithms.Graph.vertex_exists()\nvertex_exists(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, state: list[int]) -&gt; bool\n\n\n\nptdalgorithms.Graph.vertices()\nvertices(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph) -&gt; list[ptdalgorithms::Vertex]\n//’ Obtain a list of all vertices in the graph //’ //’ @description //’ Returns all vertices that have been added to the //’ graph from either calling find_or_create_vertex or //’ create_vertex. The first vertex in the list is //’ always the starting vertex [ptdalgorithms::starting_vertex()]. //’ Importantly, for speed, use [ptdalgorithms::vertices_length()] to get the number //’ of added vertices, and use [ptdalgorithms::vertex_at()] to //’ get a vertex at a particular index. //’ //’ @details //’ The list of vertices contains any added vertex, even //’ if it does not have any in-going / out-going edges. //’ //’ @param phase_type_graph A reference to the graph created by [ptdalgorithms::create_graph()] //’ //’ @seealso [ptdalgorithms::starting_vertex()] //’ @seealso [ptdalgorithms::vertices_length()] //’ @seealso [ptdalgorithms::vertex_at()] //’ //’ @examples //’ graph &lt;- create_graph(4) //’ vertex_a &lt;- find_or_create_vertex(graph, c(1,2,1,0)) //’ vertex_b &lt;- find_or_create_vertex(graph, c(2,0,1,0)) //’ vertices(graph)[[1]] == starting_vertex(graph) //’ vertices(graph)[[2]] == vertex_at(graph, 2) //’ vertices_length(graph) == 3\n\n\n\nptdalgorithms.Graph.vertices_length()\nvertices_length(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph) -&gt; int",
    "crumbs": [
      "Some section",
      "Graph"
    ]
  },
  {
    "objectID": "api/Graph.html#methods",
    "href": "api/Graph.html#methods",
    "title": "Graph",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\naccumulated_visiting_time\naccumulated_visiting_time(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, time: float, granularity: int = 0) -&gt; list[float]\n\n\naccumulated_visits_discrete\naccumulated_visits_discrete(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, jumps: int) -&gt; list[float]\n\n\nas_matrices\nas_matrices(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph) -&gt; ptdalgorithms.ptdalgorithmscpp_pybind.MatrixRepresentation\n\n\ncdf\ncdf(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, time: numpy.ndarray[numpy.float32], granularity: numpy.ndarray[numpy.int32] = 0) -&gt; object\n\n\ncdf_discrete\ncdf_discrete(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, jumps: numpy.ndarray[numpy.int32]) -&gt; object\n\n\nclone\nclone(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph) -&gt; ptdalgorithms.ptdalgorithmscpp_pybind.Graph\n\n\ncovariance\ncovariance(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, rewards1: list[float], rewards2: list[float]) -&gt; float\n\n\ncovariance_discrete\ncovariance_discrete(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, rewards1: list[float], rewards2: list[float]) -&gt; float\n\n\ncreate_vertex\ncreate_vertex(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, state: list[int]) -&gt; ptdalgorithms::Vertex\n\n\ndefect\ndefect(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph) -&gt; float\n\n\ndistribution_context\ndistribution_context(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, granularity: int = 0) -&gt; ptdalgorithms::ProbabilityDistributionContext\n\n\ndistribution_context_discrete\ndistribution_context_discrete(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph) -&gt; ptdalgorithms::DPHProbabilityDistributionContext\n\n\nexpectation\nexpectation(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, rewards: list[float] = []) -&gt; float\n\n\nexpectation_dag\nexpectation_dag(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, rewards: list[float]) -&gt; ptdalgorithms.ptdalgorithmscpp_pybind.Graph\n\n\nexpectation_discrete\nexpectation_discrete(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, arg0: list[float]) -&gt; float\n\n\nexpected_residence_time\nexpected_residence_time(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, rewards: list[float] = []) -&gt; list[float]\n\n\nexpected_visits_discrete\nexpected_visits_discrete(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, jumps: int) -&gt; list[float]\n\n\nexpected_waiting_time\nexpected_waiting_time(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, rewards: list[float] = []) -&gt; list[float]\n\n\nfind_or_create_vertex\nfind_or_create_vertex(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, state: list[int]) -&gt; ptdalgorithms::Vertex\n\n\nfind_vertex\nfind_vertex(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, state: list[int]) -&gt; ptdalgorithms::Vertex\n\n\nfocv\nfocv(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, state: list[int]) -&gt; ptdalgorithms::Vertex\n\n\nis_acyclic\nis_acyclic(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph) -&gt; bool\n\n\nmoments\nmoments(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, power: int, rewards: list[float] = []) -&gt; list[float]\n\n\nnormalize\nnormalize(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph) -&gt; list[float]\n\n\nnormalize_discrete\nnormalize_discrete(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph) -&gt; list[float]\n\n\nnotify_change\nnotify_change(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph) -&gt; None\n\n\npdf\npdf(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, time: numpy.ndarray[numpy.float32], granularity: numpy.ndarray[numpy.int32] = 0) -&gt; object\n\n\npmf_discrete\npmf_discrete(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, jumps: numpy.ndarray[numpy.int32]) -&gt; object\n\n\nrandom_sample_discrete_stop_vertex\nrandom_sample_discrete_stop_vertex(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, jumps: int) -&gt; int\n\n\nrandom_sample_stop_vertex\nrandom_sample_stop_vertex(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, time: float) -&gt; int\n\n\nreward_transform\nreward_transform(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, rewards: list[float]) -&gt; ptdalgorithms.ptdalgorithmscpp_pybind.Graph\n\n\nreward_transform_discrete\nreward_transform_discrete(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, rewards: list[int]) -&gt; ptdalgorithms.ptdalgorithmscpp_pybind.Graph\n\n\nsample\nsample(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, n: int = 1, rewards: list[float] = []) -&gt; list[float]\n\n\nsample_discrete\nsample_discrete(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, n: int = 1, rewards: list[float] = []) -&gt; list[float]\n\n\nsample_multivariate\nsample_multivariate(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, n: int = 1, rewards: numpy.ndarray[numpy.float64[m, n]] = []) -&gt; numpy.ndarray[numpy.float64[m, n]]\n\n\nsample_multivariate_discrete\nsample_multivariate_discrete(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, n: int = 1, rewards: numpy.ndarray[numpy.float64[m, n]] = []) -&gt; numpy.ndarray[numpy.float64[m, n]]\n\n\nstarting_vertex\nstarting_vertex(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph) -&gt; ptdalgorithms::Vertex\n\n\nstate_length\nstate_length(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph) -&gt; int\n\n\nstates\nstates(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph) -&gt; numpy.ndarray[numpy.int32[m, n]]\n\n\nstop_probability\nstop_probability(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, time: float, granularity: int = 0) -&gt; list[float]\n\n\nstop_probability_discrete\nstop_probability_discrete(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, jumps: int) -&gt; list[float]\n\n\nupdate_parameterized_weights\nupdate_parameterized_weights(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, rewards: list[float]) -&gt; None\n\n\nvalidate\nvalidate(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph) -&gt; None\n\n\nvariance\nvariance(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, rewards: list[float] = []) -&gt; float\n\n\nvariance_discrete\nvariance_discrete(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, arg0: list[float]) -&gt; float\n\n\nvertex_at\nvertex_at(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, index: int) -&gt; ptdalgorithms::Vertex\n\n\nvertex_exists\nvertex_exists(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, state: list[int]) -&gt; bool\n\n\nvertices\nvertices(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph) -&gt; list[ptdalgorithms::Vertex]\n\n\nvertices_length\nvertices_length(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph) -&gt; int\n\n\n\n\n\nptdalgorithms.Graph.accumulated_visiting_time()\naccumulated_visiting_time(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, time: float, granularity: int = 0) -&gt; list[float]\n\n\n\nptdalgorithms.Graph.accumulated_visits_discrete()\naccumulated_visits_discrete(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, jumps: int) -&gt; list[float]\n\n\n\nptdalgorithms.Graph.as_matrices()\nas_matrices(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph) -&gt; ptdalgorithms.ptdalgorithmscpp_pybind.MatrixRepresentation\n\n\n\nptdalgorithms.Graph.cdf()\ncdf(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, time: numpy.ndarray[numpy.float32], granularity: numpy.ndarray[numpy.int32] = 0) -&gt; object\n\n\n\nptdalgorithms.Graph.cdf_discrete()\ncdf_discrete(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, jumps: numpy.ndarray[numpy.int32]) -&gt; object\n\n\n\nptdalgorithms.Graph.clone()\nclone(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph) -&gt; ptdalgorithms.ptdalgorithmscpp_pybind.Graph\n\n\n\nptdalgorithms.Graph.covariance()\ncovariance(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, rewards1: list[float], rewards2: list[float]) -&gt; float\n\n\n\nptdalgorithms.Graph.covariance_discrete()\ncovariance_discrete(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, rewards1: list[float], rewards2: list[float]) -&gt; float\n\n\n\nptdalgorithms.Graph.create_vertex()\ncreate_vertex(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, state: list[int]) -&gt; ptdalgorithms::Vertex\n\n\n\nptdalgorithms.Graph.defect()\ndefect(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph) -&gt; float\n\n\n\nptdalgorithms.Graph.distribution_context()\ndistribution_context(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, granularity: int = 0) -&gt; ptdalgorithms::ProbabilityDistributionContext\n\n\n\nptdalgorithms.Graph.distribution_context_discrete()\ndistribution_context_discrete(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph) -&gt; ptdalgorithms::DPHProbabilityDistributionContext\n\n\n\nptdalgorithms.Graph.expectation()\nexpectation(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, rewards: list[float] = []) -&gt; float\n//’ Computes the expectation (mean) of the phase-type distribution //’ //’ @description //’ This function invokes [ptdalgorithms::expected_waiting_times()] //’ and takes the first entry (from starting vertex) //’ //’ @return The expectation of the distribution //’ //’ @param phase_type_graph A reference to the graph created by [ptdalgorithms::create_graph()] //’ @param rewards Optional rewards, which should be applied to the phase-type distribution. Must have length equal to [ptdalgorithms::vertices_length()] //’ //’ @seealso [ptdalgorithms::expected_waiting_time()] //’ @seealso [ptdalgorithms::moments()] //’ @seealso [ptdalgorithms::variance()] //’ @seealso [ptdalgorithms::covariance()] //’ //’ @examples //’ graph &lt;- ptdalgorithms::create_graph(4) //’ v1 &lt;- ptdalgorithms::create_vertex(graph, c(1,2,3,4)) //’ v2 &lt;- ptdalgorithms::create_vertex(graph, c(4,0,3,3)) //’ a &lt;- ptdalgorithms::create_vertex(graph, c(0,0,0,0)) //’ ptdalgorithms::add_edge(ptdalgorithms::starting_vertex(graph), v1, 1) //’ ptdalgorithms::add_edge(v1, v2, 4) //’ ptdalgorithms::add_edge(v2, a, 10) //’ ptdalgorithms::expectation(graph) # =&gt; //’ 0.35 //’ ptdalgorithms::expectation(graph, c(0,2,1,0)) # =&gt; //’ 0.6 //’ ph &lt;- ptdalgorithms::graph_as_matrix(graph) //’ # This is a much faster version of //’ ph\\(IPV%*%solve(-ph\\)SIM) %% rep(1, length(ph\\(IPV)) # =&gt;\n//'   0.35\n//' ph\\)IPV%%solve(-ph\\(SIM) %*% diag(c(2,1))%*% rep(1, length(ph\\)IPV)) # =&gt; //’ 0.35\n\n\n\nptdalgorithms.Graph.expectation_dag()\nexpectation_dag(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, rewards: list[float]) -&gt; ptdalgorithms.ptdalgorithmscpp_pybind.Graph\n\n\n\nptdalgorithms.Graph.expectation_discrete()\nexpectation_discrete(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, arg0: list[float]) -&gt; float\n\n\n\nptdalgorithms.Graph.expected_residence_time()\nexpected_residence_time(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, rewards: list[float] = []) -&gt; list[float]\n\n\n\nptdalgorithms.Graph.expected_visits_discrete()\nexpected_visits_discrete(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, jumps: int) -&gt; list[float]\n\n\n\nptdalgorithms.Graph.expected_waiting_time()\nexpected_waiting_time(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, rewards: list[float] = []) -&gt; list[float]\n\n\n\nptdalgorithms.Graph.find_or_create_vertex()\nfind_or_create_vertex(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, state: list[int]) -&gt; ptdalgorithms::Vertex\n//’ Find or create a vertex matching state //’ //’ @description //’ Finds a vertex by the state parameter. If no such //’ vertex exists, it creates the vertex and adds it to //’ the graph object instead. //’ //’ @details //’ A faster and simpler version of calling [ptdalgorithms::find_vertex()] and [ptdalgorithms::create_vertex()] //’ //’ @return The newly found or inserted vertex in the graph //’ //’ @param phase_type_graph A reference to the graph created by [ptdalgorithms::create_graph()] //’ @param state An integer vector of what vertex to look for. Has length as given by state_length in [ptdalgorithms::create_graph()] //’ //’ @examples //’ graph &lt;- create_graph(4) //’ find_or_create_vertex(graph, c(1,2,1,0)) # Adds and returns the vertex //’ find_or_create_vertex(graph, c(1,2,1,0)) # Only returns the vertex //’ # graph is now changed permanently\n\n\n\nptdalgorithms.Graph.find_vertex()\nfind_vertex(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, state: list[int]) -&gt; ptdalgorithms::Vertex\n\n\n\nptdalgorithms.Graph.focv()\nfocv(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, state: list[int]) -&gt; ptdalgorithms::Vertex\nAlias for find_or_create_vertex\n\n\n\nptdalgorithms.Graph.is_acyclic()\nis_acyclic(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph) -&gt; bool\n\n\n\nptdalgorithms.Graph.moments()\nmoments(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, power: int, rewards: list[float] = []) -&gt; list[float]\n//’ Computes the first k moments of the phase-type distribution //’ //’ @description //’ This function invokes [ptdalgorithms::expected_waiting_times()] consequtively to find the first moments, //’ given by the power argument //’ //’ @return A numeric vector of the first k moments. The first entry is the first moment (mean) //’ //’ @param phase_type_graph A reference to the graph created by [ptdalgorithms::create_graph()] //’ @param power An integer of the first k moments. //’ @param rewards Optional rewards, which should be applied to the phase-type distribution. Must have length equal to [ptdalgorithms::vertices_length()] //’ //’ @seealso [ptdalgorithms::expected_waiting_time()] //’ @seealso [ptdalgorithms::expectation()] //’ @seealso [ptdalgorithms::variance()] //’ @seealso [ptdalgorithms::covariance()] //’ //’ @examples //’ graph &lt;- ptdalgorithms::create_graph(4) //’ v1 &lt;- ptdalgorithms::create_vertex(graph, c(1,2,3,4)) //’ v2 &lt;- ptdalgorithms::create_vertex(graph, c(4,0,3,3)) //’ a &lt;- ptdalgorithms::create_vertex(graph, c(0,0,0,0)) //’ ptdalgorithms::add_edge(ptdalgorithms::starting_vertex(graph), v1, 1) //’ ptdalgorithms::add_edge(v1, v2, 4) //’ ptdalgorithms::add_edge(v2, a, 10) //’ ptdalgorithms::moments(graph, 3) # =&gt; //’ (0.350000 0.097500 0.025375) //’ ptdalgorithms::moments(graph, 3, c(0,2,1,0)) # =&gt; //’ (0.600 0.160 0.041)\n\n\n\nptdalgorithms.Graph.normalize()\nnormalize(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph) -&gt; list[float]\n\n\n\nptdalgorithms.Graph.normalize_discrete()\nnormalize_discrete(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph) -&gt; list[float]\n\n\n\nptdalgorithms.Graph.notify_change()\nnotify_change(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph) -&gt; None\n\n\n\nptdalgorithms.Graph.pdf()\npdf(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, time: numpy.ndarray[numpy.float32], granularity: numpy.ndarray[numpy.int32] = 0) -&gt; object\n\n\n\nptdalgorithms.Graph.pmf_discrete()\npmf_discrete(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, jumps: numpy.ndarray[numpy.int32]) -&gt; object\n\n\n\nptdalgorithms.Graph.random_sample_discrete_stop_vertex()\nrandom_sample_discrete_stop_vertex(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, jumps: int) -&gt; int\n\n\n\nptdalgorithms.Graph.random_sample_stop_vertex()\nrandom_sample_stop_vertex(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, time: float) -&gt; int\n\n\n\nptdalgorithms.Graph.reward_transform()\nreward_transform(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, rewards: list[float]) -&gt; ptdalgorithms.ptdalgorithmscpp_pybind.Graph\n\n\n\nptdalgorithms.Graph.reward_transform_discrete()\nreward_transform_discrete(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, rewards: list[int]) -&gt; ptdalgorithms.ptdalgorithmscpp_pybind.Graph\n\n\n\nptdalgorithms.Graph.sample()\nsample(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, n: int = 1, rewards: list[float] = []) -&gt; list[float]\n\n\n\nptdalgorithms.Graph.sample_discrete()\nsample_discrete(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, n: int = 1, rewards: list[float] = []) -&gt; list[float]\n\n\n\nptdalgorithms.Graph.sample_multivariate()\nsample_multivariate(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, n: int = 1, rewards: numpy.ndarray[numpy.float64[m, n]] = []) -&gt; numpy.ndarray[numpy.float64[m, n]]\n\n\n\nptdalgorithms.Graph.sample_multivariate_discrete()\nsample_multivariate_discrete(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, n: int = 1, rewards: numpy.ndarray[numpy.float64[m, n]] = []) -&gt; numpy.ndarray[numpy.float64[m, n]]\n\n\n\nptdalgorithms.Graph.starting_vertex()\nstarting_vertex(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph) -&gt; ptdalgorithms::Vertex\n\n\n\nptdalgorithms.Graph.state_length()\nstate_length(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph) -&gt; int\n\n\n\nptdalgorithms.Graph.states()\nstates(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph) -&gt; numpy.ndarray[numpy.int32[m, n]]\n//’ Returns a matrix where each row is the state of the vertex at that index //’ //’ @return A matrix of size [ptdalgorithms::vertices_length()] where the rows match the state of the vertex at that index //’ //’ @param phase_type_graph A reference to the graph created by [ptdalgorithms::create_graph()] //’ //’ @examples //’ graph &lt;- ptdalgorithms::create_graph(4) //’ ptdalgorithms::create_vertex(graph, c(1,2,3,4)) //’ ptdalgorithms::create_vertex(graph, c(4,3,3,3)) //’ ptdalgorithms::states(graph) # =&gt; //’ # 0 0 0 0 //’ # 1 2 3 4 //’ # 4 3 3 3\n\n\n\nptdalgorithms.Graph.stop_probability()\nstop_probability(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, time: float, granularity: int = 0) -&gt; list[float]\n\n\n\nptdalgorithms.Graph.stop_probability_discrete()\nstop_probability_discrete(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, jumps: int) -&gt; list[float]\n\n\n\nptdalgorithms.Graph.update_parameterized_weights()\nupdate_parameterized_weights(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, rewards: list[float]) -&gt; None\n//’ Updates all parameterized edges of the graph by given scalars. //’ //’ @description //’ Given a vector of scalars, computes a new weight of //’ the parameterized edges in the graph by a simple inner //’ product of the edge state vector and the scalar vector. //’ //’ @details //’ A faster and simpler version to compute new moments, when //’ the user wants to try multiple different weights. //’ //’ //’ @param phase_type_graph A reference to the graph created by [ptdalgorithms::create_graph()] //’ @param scalars A numeric vector of multiplies for the edge states. //’ //’ @seealso [ptdalgorithms::expected_waiting_time()] //’ @seealso [ptdalgorithms::add_edge()] //’ //’ @examples //’ graph &lt;- create_graph(4) //’ v1 &lt;- find_or_create_vertex(graph, c(1,2,1,0)) //’ v2 &lt;- find_or_create_vertex(graph, c(2,0,1,0)) //’ add_edge(starting_vertex(graph), v1, 5) //’ add_edge(v1, v2, 0, c(5,2)) //’ edges(starting_vertex(graph))[[1]]\\(weight # =&gt; 5\n//' edges(v1)[[1]]\\)weight # =&gt; 0 //’ graph_update_weights_parameterized(graph, c(9,7)) //’ edges(starting_vertex(graph))[[1]]\\(weight # =&gt; 5\n//' edges(v1)[[1]]\\)weight # =&gt; 59\n\n\n\nptdalgorithms.Graph.validate()\nvalidate(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph) -&gt; None\n\n\n\nptdalgorithms.Graph.variance()\nvariance(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, rewards: list[float] = []) -&gt; float\n//’ Computes the variance of the phase-type distribution //’ //’ @description //’ This function invokes [ptdalgorithms::expected_waiting_times()] //’ twice to find the first and second moment //’ //’ @return The variance of the distribution //’ //’ @param phase_type_graph A reference to the graph created by [ptdalgorithms::create_graph()] //’ @param rewards Optional rewards, which should be applied to the phase-type distribution. Must have length equal to [ptdalgorithms::vertices_length()] //’ //’ @seealso [ptdalgorithms::expected_waiting_time()] //’ @seealso [ptdalgorithms::expectation()] //’ @seealso [ptdalgorithms::moments()] //’ @seealso [ptdalgorithms::covariance()] //’ //’ @examples //’ graph &lt;- ptdalgorithms::create_graph(4) //’ v1 &lt;- ptdalgorithms::create_vertex(graph, c(1,2,3,4)) //’ v2 &lt;- ptdalgorithms::create_vertex(graph, c(4,0,3,3)) //’ a &lt;- ptdalgorithms::create_vertex(graph, c(0,0,0,0)) //’ ptdalgorithms::add_edge(ptdalgorithms::starting_vertex(graph), v1, 1) //’ ptdalgorithms::add_edge(v1, v2, 4) //’ ptdalgorithms::add_edge(v2, a, 10) //’ ptdalgorithms::variance(graph) # =&gt; //’ 0.0725 //’ ptdalgorithms::variance(graph, c(0,2,1,0)) # =&gt; //’ 0.26 //’ ph &lt;- ptdalgorithms::graph_as_matrix(graph) //’ # This is a much faster version of //’ 2ph\\(IPV%*%solve(-ph\\)SIM)%%solve(-ph\\(SIM) %*% rep(1, length(ph\\)IPV)) - ph\\(IPV%*%solve(-ph\\)SIM) %% rep(1, length(ph\\(IPV)) %*% ph\\)IPV%%solve(-ph\\(SIM) %*% rep(1, length(ph\\)IPV)) # =&gt; //’ 0.0725 //’ 2ph\\(IPV%*%solve(-ph\\)SIM)%%diag(c(2,1))%%solve(-ph\\(SIM)%*%diag(c(2,1)) %*% rep(1, length(ph\\)IPV)) - ph\\(IPV%*%solve(-ph\\)SIM)%%diag(c(2,1)) %% rep(1, length(ph\\(IPV)) %*% ph\\)IPV%%solve(-ph\\(SIM)%*%diag(c(2,1)) %*% rep(1, length(ph\\)IPV)) # =&gt; //’ 0.26\n\n\n\nptdalgorithms.Graph.variance_discrete()\nvariance_discrete(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, arg0: list[float]) -&gt; float\n\n\n\nptdalgorithms.Graph.vertex_at()\nvertex_at(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, index: int) -&gt; ptdalgorithms::Vertex\n\n\n\nptdalgorithms.Graph.vertex_exists()\nvertex_exists(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, state: list[int]) -&gt; bool\n\n\n\nptdalgorithms.Graph.vertices()\nvertices(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph) -&gt; list[ptdalgorithms::Vertex]\n//’ Obtain a list of all vertices in the graph //’ //’ @description //’ Returns all vertices that have been added to the //’ graph from either calling find_or_create_vertex or //’ create_vertex. The first vertex in the list is //’ always the starting vertex [ptdalgorithms::starting_vertex()]. //’ Importantly, for speed, use [ptdalgorithms::vertices_length()] to get the number //’ of added vertices, and use [ptdalgorithms::vertex_at()] to //’ get a vertex at a particular index. //’ //’ @details //’ The list of vertices contains any added vertex, even //’ if it does not have any in-going / out-going edges. //’ //’ @param phase_type_graph A reference to the graph created by [ptdalgorithms::create_graph()] //’ //’ @seealso [ptdalgorithms::starting_vertex()] //’ @seealso [ptdalgorithms::vertices_length()] //’ @seealso [ptdalgorithms::vertex_at()] //’ //’ @examples //’ graph &lt;- create_graph(4) //’ vertex_a &lt;- find_or_create_vertex(graph, c(1,2,1,0)) //’ vertex_b &lt;- find_or_create_vertex(graph, c(2,0,1,0)) //’ vertices(graph)[[1]] == starting_vertex(graph) //’ vertices(graph)[[2]] == vertex_at(graph, 2) //’ vertices_length(graph) == 3\n\n\n\nptdalgorithms.Graph.vertices_length()\nvertices_length(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph) -&gt; int",
    "crumbs": [
      "Some section",
      "Graph"
    ]
  }
]