[
  {
    "objectID": "api/Graph.html",
    "href": "api/Graph.html",
    "title": "Graph",
    "section": "",
    "text": "ptdalgorithms.Graph(\n    self,\n    state_length=None,\n    callback=None,\n    initial=None,\n    trans_as_dict=False,\n)\n\n\n\n\n\nName\nDescription\n\n\n\n\naccumulated_visiting_time\naccumulated_visiting_time(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, time: float, granularity: int = 0) -&gt; list[float]\n\n\naccumulated_visits_discrete\naccumulated_visits_discrete(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, jumps: int) -&gt; list[float]\n\n\nas_matrices\nas_matrices(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph) -&gt; ptdalgorithms.ptdalgorithmscpp_pybind.MatrixRepresentation\n\n\ncdf\ncdf(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, time: numpy.ndarray[numpy.float32], granularity: numpy.ndarray[numpy.int32] = 0) -&gt; object\n\n\ncdf_discrete\ncdf_discrete(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, jumps: numpy.ndarray[numpy.int32]) -&gt; object\n\n\nclone\nclone(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph) -&gt; ptdalgorithms.ptdalgorithmscpp_pybind.Graph\n\n\ncovariance\ncovariance(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, rewards1: list[float], rewards2: list[float]) -&gt; float\n\n\ncovariance_discrete\ncovariance_discrete(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, rewards1: list[float], rewards2: list[float]) -&gt; float\n\n\ncreate_vertex\ncreate_vertex(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, state: list[int]) -&gt; ptdalgorithms::Vertex\n\n\ndefect\ndefect(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph) -&gt; float\n\n\ndistribution_context\ndistribution_context(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, granularity: int = 0) -&gt; ptdalgorithms::ProbabilityDistributionContext\n\n\ndistribution_context_discrete\ndistribution_context_discrete(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph) -&gt; ptdalgorithms::DPHProbabilityDistributionContext\n\n\nexpectation\nexpectation(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, rewards: list[float] = []) -&gt; float\n\n\nexpectation_dag\nexpectation_dag(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, rewards: list[float]) -&gt; ptdalgorithms.ptdalgorithmscpp_pybind.Graph\n\n\nexpectation_discrete\nexpectation_discrete(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, arg0: list[float]) -&gt; float\n\n\nexpected_residence_time\nexpected_residence_time(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, rewards: list[float] = []) -&gt; list[float]\n\n\nexpected_visits_discrete\nexpected_visits_discrete(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, jumps: int) -&gt; list[float]\n\n\nexpected_waiting_time\nexpected_waiting_time(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, rewards: list[float] = []) -&gt; list[float]\n\n\nfind_or_create_vertex\nfind_or_create_vertex(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, state: list[int]) -&gt; ptdalgorithms::Vertex\n\n\nfind_vertex\nfind_vertex(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, state: list[int]) -&gt; ptdalgorithms::Vertex\n\n\nfocv\nfocv(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, state: list[int]) -&gt; ptdalgorithms::Vertex\n\n\nis_acyclic\nis_acyclic(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph) -&gt; bool\n\n\nmoments\nmoments(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, power: int, rewards: list[float] = []) -&gt; list[float]\n\n\nnormalize\nnormalize(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph) -&gt; list[float]\n\n\nnormalize_discrete\nnormalize_discrete(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph) -&gt; list[float]\n\n\nnotify_change\nnotify_change(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph) -&gt; None\n\n\npdf\npdf(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, time: numpy.ndarray[numpy.float32], granularity: numpy.ndarray[numpy.int32] = 0) -&gt; object\n\n\npmf_discrete\npmf_discrete(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, jumps: numpy.ndarray[numpy.int32]) -&gt; object\n\n\nrandom_sample_discrete_stop_vertex\nrandom_sample_discrete_stop_vertex(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, jumps: int) -&gt; int\n\n\nrandom_sample_stop_vertex\nrandom_sample_stop_vertex(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, time: float) -&gt; int\n\n\nreward_transform\nreward_transform(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, rewards: list[float]) -&gt; ptdalgorithms.ptdalgorithmscpp_pybind.Graph\n\n\nreward_transform_discrete\nreward_transform_discrete(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, rewards: list[int]) -&gt; ptdalgorithms.ptdalgorithmscpp_pybind.Graph\n\n\nsample\nsample(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, n: int = 1, rewards: list[float] = []) -&gt; list[float]\n\n\nsample_discrete\nsample_discrete(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, n: int = 1, rewards: list[float] = []) -&gt; list[float]\n\n\nsample_multivariate\nsample_multivariate(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, n: int = 1, rewards: numpy.ndarray[numpy.float64[m, n]] = []) -&gt; numpy.ndarray[numpy.float64[m, n]]\n\n\nsample_multivariate_discrete\nsample_multivariate_discrete(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, n: int = 1, rewards: numpy.ndarray[numpy.float64[m, n]] = []) -&gt; numpy.ndarray[numpy.float64[m, n]]\n\n\nstarting_vertex\nstarting_vertex(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph) -&gt; ptdalgorithms::Vertex\n\n\nstate_length\nstate_length(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph) -&gt; int\n\n\nstates\nstates(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph) -&gt; numpy.ndarray[numpy.int32[m, n]]\n\n\nstop_probability\nstop_probability(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, time: float, granularity: int = 0) -&gt; list[float]\n\n\nstop_probability_discrete\nstop_probability_discrete(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, jumps: int) -&gt; list[float]\n\n\nupdate_parameterized_weights\nupdate_parameterized_weights(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, rewards: list[float]) -&gt; None\n\n\nvalidate\nvalidate(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph) -&gt; None\n\n\nvariance\nvariance(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, rewards: list[float] = []) -&gt; float\n\n\nvariance_discrete\nvariance_discrete(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, arg0: list[float]) -&gt; float\n\n\nvertex_at\nvertex_at(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, index: int) -&gt; ptdalgorithms::Vertex\n\n\nvertex_exists\nvertex_exists(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, state: list[int]) -&gt; bool\n\n\nvertices\nvertices(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph) -&gt; list[ptdalgorithms::Vertex]\n\n\nvertices_length\nvertices_length(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph) -&gt; int\n\n\n\n\n\nptdalgorithms.Graph.accumulated_visiting_time()\naccumulated_visiting_time(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, time: float, granularity: int = 0) -&gt; list[float]\n\n\n\nptdalgorithms.Graph.accumulated_visits_discrete()\naccumulated_visits_discrete(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, jumps: int) -&gt; list[float]\n\n\n\nptdalgorithms.Graph.as_matrices()\nas_matrices(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph) -&gt; ptdalgorithms.ptdalgorithmscpp_pybind.MatrixRepresentation\n\n\n\nptdalgorithms.Graph.cdf()\ncdf(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, time: numpy.ndarray[numpy.float32], granularity: numpy.ndarray[numpy.int32] = 0) -&gt; object\n\n\n\nptdalgorithms.Graph.cdf_discrete()\ncdf_discrete(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, jumps: numpy.ndarray[numpy.int32]) -&gt; object\n\n\n\nptdalgorithms.Graph.clone()\nclone(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph) -&gt; ptdalgorithms.ptdalgorithmscpp_pybind.Graph\n\n\n\nptdalgorithms.Graph.covariance()\ncovariance(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, rewards1: list[float], rewards2: list[float]) -&gt; float\n\n\n\nptdalgorithms.Graph.covariance_discrete()\ncovariance_discrete(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, rewards1: list[float], rewards2: list[float]) -&gt; float\n\n\n\nptdalgorithms.Graph.create_vertex()\ncreate_vertex(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, state: list[int]) -&gt; ptdalgorithms::Vertex\n\n\n\nptdalgorithms.Graph.defect()\ndefect(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph) -&gt; float\n\n\n\nptdalgorithms.Graph.distribution_context()\ndistribution_context(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, granularity: int = 0) -&gt; ptdalgorithms::ProbabilityDistributionContext\n\n\n\nptdalgorithms.Graph.distribution_context_discrete()\ndistribution_context_discrete(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph) -&gt; ptdalgorithms::DPHProbabilityDistributionContext\n\n\n\nptdalgorithms.Graph.expectation()\nexpectation(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, rewards: list[float] = []) -&gt; float\n//’ Computes the expectation (mean) of the phase-type distribution //’ //’ @description //’ This function invokes [ptdalgorithms::expected_waiting_times()] //’ and takes the first entry (from starting vertex) //’ //’ @return The expectation of the distribution //’ //’ @param phase_type_graph A reference to the graph created by [ptdalgorithms::create_graph()] //’ @param rewards Optional rewards, which should be applied to the phase-type distribution. Must have length equal to [ptdalgorithms::vertices_length()] //’ //’ @seealso [ptdalgorithms::expected_waiting_time()] //’ @seealso [ptdalgorithms::moments()] //’ @seealso [ptdalgorithms::variance()] //’ @seealso [ptdalgorithms::covariance()] //’ //’ @examples //’ graph &lt;- ptdalgorithms::create_graph(4) //’ v1 &lt;- ptdalgorithms::create_vertex(graph, c(1,2,3,4)) //’ v2 &lt;- ptdalgorithms::create_vertex(graph, c(4,0,3,3)) //’ a &lt;- ptdalgorithms::create_vertex(graph, c(0,0,0,0)) //’ ptdalgorithms::add_edge(ptdalgorithms::starting_vertex(graph), v1, 1) //’ ptdalgorithms::add_edge(v1, v2, 4) //’ ptdalgorithms::add_edge(v2, a, 10) //’ ptdalgorithms::expectation(graph) # =&gt; //’ 0.35 //’ ptdalgorithms::expectation(graph, c(0,2,1,0)) # =&gt; //’ 0.6 //’ ph &lt;- ptdalgorithms::graph_as_matrix(graph) //’ # This is a much faster version of //’ ph\\(IPV%*%solve(-ph\\)SIM) %% rep(1, length(ph\\(IPV)) # =&gt;\n//'   0.35\n//' ph\\)IPV%%solve(-ph\\(SIM) %*% diag(c(2,1))%*% rep(1, length(ph\\)IPV)) # =&gt; //’ 0.35\n\n\n\nptdalgorithms.Graph.expectation_dag()\nexpectation_dag(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, rewards: list[float]) -&gt; ptdalgorithms.ptdalgorithmscpp_pybind.Graph\n\n\n\nptdalgorithms.Graph.expectation_discrete()\nexpectation_discrete(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, arg0: list[float]) -&gt; float\n\n\n\nptdalgorithms.Graph.expected_residence_time()\nexpected_residence_time(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, rewards: list[float] = []) -&gt; list[float]\n\n\n\nptdalgorithms.Graph.expected_visits_discrete()\nexpected_visits_discrete(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, jumps: int) -&gt; list[float]\n\n\n\nptdalgorithms.Graph.expected_waiting_time()\nexpected_waiting_time(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, rewards: list[float] = []) -&gt; list[float]\n\n\n\nptdalgorithms.Graph.find_or_create_vertex()\nfind_or_create_vertex(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, state: list[int]) -&gt; ptdalgorithms::Vertex\n//’ Find or create a vertex matching state //’ //’ @description //’ Finds a vertex by the state parameter. If no such //’ vertex exists, it creates the vertex and adds it to //’ the graph object instead. //’ //’ @details //’ A faster and simpler version of calling [ptdalgorithms::find_vertex()] and [ptdalgorithms::create_vertex()] //’ //’ @return The newly found or inserted vertex in the graph //’ //’ @param phase_type_graph A reference to the graph created by [ptdalgorithms::create_graph()] //’ @param state An integer vector of what vertex to look for. Has length as given by state_length in [ptdalgorithms::create_graph()] //’ //’ @examples //’ graph &lt;- create_graph(4) //’ find_or_create_vertex(graph, c(1,2,1,0)) # Adds and returns the vertex //’ find_or_create_vertex(graph, c(1,2,1,0)) # Only returns the vertex //’ # graph is now changed permanently\n\n\n\nptdalgorithms.Graph.find_vertex()\nfind_vertex(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, state: list[int]) -&gt; ptdalgorithms::Vertex\n\n\n\nptdalgorithms.Graph.focv()\nfocv(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, state: list[int]) -&gt; ptdalgorithms::Vertex\nAlias for find_or_create_vertex\n\n\n\nptdalgorithms.Graph.is_acyclic()\nis_acyclic(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph) -&gt; bool\n\n\n\nptdalgorithms.Graph.moments()\nmoments(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, power: int, rewards: list[float] = []) -&gt; list[float]\n//’ Computes the first k moments of the phase-type distribution //’ //’ @description //’ This function invokes [ptdalgorithms::expected_waiting_times()] consequtively to find the first moments, //’ given by the power argument //’ //’ @return A numeric vector of the first k moments. The first entry is the first moment (mean) //’ //’ @param phase_type_graph A reference to the graph created by [ptdalgorithms::create_graph()] //’ @param power An integer of the first k moments. //’ @param rewards Optional rewards, which should be applied to the phase-type distribution. Must have length equal to [ptdalgorithms::vertices_length()] //’ //’ @seealso [ptdalgorithms::expected_waiting_time()] //’ @seealso [ptdalgorithms::expectation()] //’ @seealso [ptdalgorithms::variance()] //’ @seealso [ptdalgorithms::covariance()] //’ //’ @examples //’ graph &lt;- ptdalgorithms::create_graph(4) //’ v1 &lt;- ptdalgorithms::create_vertex(graph, c(1,2,3,4)) //’ v2 &lt;- ptdalgorithms::create_vertex(graph, c(4,0,3,3)) //’ a &lt;- ptdalgorithms::create_vertex(graph, c(0,0,0,0)) //’ ptdalgorithms::add_edge(ptdalgorithms::starting_vertex(graph), v1, 1) //’ ptdalgorithms::add_edge(v1, v2, 4) //’ ptdalgorithms::add_edge(v2, a, 10) //’ ptdalgorithms::moments(graph, 3) # =&gt; //’ (0.350000 0.097500 0.025375) //’ ptdalgorithms::moments(graph, 3, c(0,2,1,0)) # =&gt; //’ (0.600 0.160 0.041)\n\n\n\nptdalgorithms.Graph.normalize()\nnormalize(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph) -&gt; list[float]\n\n\n\nptdalgorithms.Graph.normalize_discrete()\nnormalize_discrete(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph) -&gt; list[float]\n\n\n\nptdalgorithms.Graph.notify_change()\nnotify_change(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph) -&gt; None\n\n\n\nptdalgorithms.Graph.pdf()\npdf(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, time: numpy.ndarray[numpy.float32], granularity: numpy.ndarray[numpy.int32] = 0) -&gt; object\n\n\n\nptdalgorithms.Graph.pmf_discrete()\npmf_discrete(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, jumps: numpy.ndarray[numpy.int32]) -&gt; object\n\n\n\nptdalgorithms.Graph.random_sample_discrete_stop_vertex()\nrandom_sample_discrete_stop_vertex(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, jumps: int) -&gt; int\n\n\n\nptdalgorithms.Graph.random_sample_stop_vertex()\nrandom_sample_stop_vertex(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, time: float) -&gt; int\n\n\n\nptdalgorithms.Graph.reward_transform()\nreward_transform(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, rewards: list[float]) -&gt; ptdalgorithms.ptdalgorithmscpp_pybind.Graph\n\n\n\nptdalgorithms.Graph.reward_transform_discrete()\nreward_transform_discrete(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, rewards: list[int]) -&gt; ptdalgorithms.ptdalgorithmscpp_pybind.Graph\n\n\n\nptdalgorithms.Graph.sample()\nsample(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, n: int = 1, rewards: list[float] = []) -&gt; list[float]\n\n\n\nptdalgorithms.Graph.sample_discrete()\nsample_discrete(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, n: int = 1, rewards: list[float] = []) -&gt; list[float]\n\n\n\nptdalgorithms.Graph.sample_multivariate()\nsample_multivariate(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, n: int = 1, rewards: numpy.ndarray[numpy.float64[m, n]] = []) -&gt; numpy.ndarray[numpy.float64[m, n]]\n\n\n\nptdalgorithms.Graph.sample_multivariate_discrete()\nsample_multivariate_discrete(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, n: int = 1, rewards: numpy.ndarray[numpy.float64[m, n]] = []) -&gt; numpy.ndarray[numpy.float64[m, n]]\n\n\n\nptdalgorithms.Graph.starting_vertex()\nstarting_vertex(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph) -&gt; ptdalgorithms::Vertex\n\n\n\nptdalgorithms.Graph.state_length()\nstate_length(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph) -&gt; int\n\n\n\nptdalgorithms.Graph.states()\nstates(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph) -&gt; numpy.ndarray[numpy.int32[m, n]]\n//’ Returns a matrix where each row is the state of the vertex at that index //’ //’ @return A matrix of size [ptdalgorithms::vertices_length()] where the rows match the state of the vertex at that index //’ //’ @param phase_type_graph A reference to the graph created by [ptdalgorithms::create_graph()] //’ //’ @examples //’ graph &lt;- ptdalgorithms::create_graph(4) //’ ptdalgorithms::create_vertex(graph, c(1,2,3,4)) //’ ptdalgorithms::create_vertex(graph, c(4,3,3,3)) //’ ptdalgorithms::states(graph) # =&gt; //’ # 0 0 0 0 //’ # 1 2 3 4 //’ # 4 3 3 3\n\n\n\nptdalgorithms.Graph.stop_probability()\nstop_probability(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, time: float, granularity: int = 0) -&gt; list[float]\n\n\n\nptdalgorithms.Graph.stop_probability_discrete()\nstop_probability_discrete(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, jumps: int) -&gt; list[float]\n\n\n\nptdalgorithms.Graph.update_parameterized_weights()\nupdate_parameterized_weights(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, rewards: list[float]) -&gt; None\n//’ Updates all parameterized edges of the graph by given scalars. //’ //’ @description //’ Given a vector of scalars, computes a new weight of //’ the parameterized edges in the graph by a simple inner //’ product of the edge state vector and the scalar vector. //’ //’ @details //’ A faster and simpler version to compute new moments, when //’ the user wants to try multiple different weights. //’ //’ //’ @param phase_type_graph A reference to the graph created by [ptdalgorithms::create_graph()] //’ @param scalars A numeric vector of multiplies for the edge states. //’ //’ @seealso [ptdalgorithms::expected_waiting_time()] //’ @seealso [ptdalgorithms::add_edge()] //’ //’ @examples //’ graph &lt;- create_graph(4) //’ v1 &lt;- find_or_create_vertex(graph, c(1,2,1,0)) //’ v2 &lt;- find_or_create_vertex(graph, c(2,0,1,0)) //’ add_edge(starting_vertex(graph), v1, 5) //’ add_edge(v1, v2, 0, c(5,2)) //’ edges(starting_vertex(graph))[[1]]\\(weight # =&gt; 5\n//' edges(v1)[[1]]\\)weight # =&gt; 0 //’ graph_update_weights_parameterized(graph, c(9,7)) //’ edges(starting_vertex(graph))[[1]]\\(weight # =&gt; 5\n//' edges(v1)[[1]]\\)weight # =&gt; 59\n\n\n\nptdalgorithms.Graph.validate()\nvalidate(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph) -&gt; None\n\n\n\nptdalgorithms.Graph.variance()\nvariance(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, rewards: list[float] = []) -&gt; float\n//’ Computes the variance of the phase-type distribution //’ //’ @description //’ This function invokes [ptdalgorithms::expected_waiting_times()] //’ twice to find the first and second moment //’ //’ @return The variance of the distribution //’ //’ @param phase_type_graph A reference to the graph created by [ptdalgorithms::create_graph()] //’ @param rewards Optional rewards, which should be applied to the phase-type distribution. Must have length equal to [ptdalgorithms::vertices_length()] //’ //’ @seealso [ptdalgorithms::expected_waiting_time()] //’ @seealso [ptdalgorithms::expectation()] //’ @seealso [ptdalgorithms::moments()] //’ @seealso [ptdalgorithms::covariance()] //’ //’ @examples //’ graph &lt;- ptdalgorithms::create_graph(4) //’ v1 &lt;- ptdalgorithms::create_vertex(graph, c(1,2,3,4)) //’ v2 &lt;- ptdalgorithms::create_vertex(graph, c(4,0,3,3)) //’ a &lt;- ptdalgorithms::create_vertex(graph, c(0,0,0,0)) //’ ptdalgorithms::add_edge(ptdalgorithms::starting_vertex(graph), v1, 1) //’ ptdalgorithms::add_edge(v1, v2, 4) //’ ptdalgorithms::add_edge(v2, a, 10) //’ ptdalgorithms::variance(graph) # =&gt; //’ 0.0725 //’ ptdalgorithms::variance(graph, c(0,2,1,0)) # =&gt; //’ 0.26 //’ ph &lt;- ptdalgorithms::graph_as_matrix(graph) //’ # This is a much faster version of //’ 2ph\\(IPV%*%solve(-ph\\)SIM)%%solve(-ph\\(SIM) %*% rep(1, length(ph\\)IPV)) - ph\\(IPV%*%solve(-ph\\)SIM) %% rep(1, length(ph\\(IPV)) %*% ph\\)IPV%%solve(-ph\\(SIM) %*% rep(1, length(ph\\)IPV)) # =&gt; //’ 0.0725 //’ 2ph\\(IPV%*%solve(-ph\\)SIM)%%diag(c(2,1))%%solve(-ph\\(SIM)%*%diag(c(2,1)) %*% rep(1, length(ph\\)IPV)) - ph\\(IPV%*%solve(-ph\\)SIM)%%diag(c(2,1)) %% rep(1, length(ph\\(IPV)) %*% ph\\)IPV%%solve(-ph\\(SIM)%*%diag(c(2,1)) %*% rep(1, length(ph\\)IPV)) # =&gt; //’ 0.26\n\n\n\nptdalgorithms.Graph.variance_discrete()\nvariance_discrete(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, arg0: list[float]) -&gt; float\n\n\n\nptdalgorithms.Graph.vertex_at()\nvertex_at(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, index: int) -&gt; ptdalgorithms::Vertex\n\n\n\nptdalgorithms.Graph.vertex_exists()\nvertex_exists(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, state: list[int]) -&gt; bool\n\n\n\nptdalgorithms.Graph.vertices()\nvertices(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph) -&gt; list[ptdalgorithms::Vertex]\n//’ Obtain a list of all vertices in the graph //’ //’ @description //’ Returns all vertices that have been added to the //’ graph from either calling find_or_create_vertex or //’ create_vertex. The first vertex in the list is //’ always the starting vertex [ptdalgorithms::starting_vertex()]. //’ Importantly, for speed, use [ptdalgorithms::vertices_length()] to get the number //’ of added vertices, and use [ptdalgorithms::vertex_at()] to //’ get a vertex at a particular index. //’ //’ @details //’ The list of vertices contains any added vertex, even //’ if it does not have any in-going / out-going edges. //’ //’ @param phase_type_graph A reference to the graph created by [ptdalgorithms::create_graph()] //’ //’ @seealso [ptdalgorithms::starting_vertex()] //’ @seealso [ptdalgorithms::vertices_length()] //’ @seealso [ptdalgorithms::vertex_at()] //’ //’ @examples //’ graph &lt;- create_graph(4) //’ vertex_a &lt;- find_or_create_vertex(graph, c(1,2,1,0)) //’ vertex_b &lt;- find_or_create_vertex(graph, c(2,0,1,0)) //’ vertices(graph)[[1]] == starting_vertex(graph) //’ vertices(graph)[[2]] == vertex_at(graph, 2) //’ vertices_length(graph) == 3\n\n\n\nptdalgorithms.Graph.vertices_length()\nvertices_length(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph) -&gt; int",
    "crumbs": [
      "Some section",
      "Graph"
    ]
  },
  {
    "objectID": "api/Graph.html#methods",
    "href": "api/Graph.html#methods",
    "title": "Graph",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\naccumulated_visiting_time\naccumulated_visiting_time(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, time: float, granularity: int = 0) -&gt; list[float]\n\n\naccumulated_visits_discrete\naccumulated_visits_discrete(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, jumps: int) -&gt; list[float]\n\n\nas_matrices\nas_matrices(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph) -&gt; ptdalgorithms.ptdalgorithmscpp_pybind.MatrixRepresentation\n\n\ncdf\ncdf(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, time: numpy.ndarray[numpy.float32], granularity: numpy.ndarray[numpy.int32] = 0) -&gt; object\n\n\ncdf_discrete\ncdf_discrete(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, jumps: numpy.ndarray[numpy.int32]) -&gt; object\n\n\nclone\nclone(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph) -&gt; ptdalgorithms.ptdalgorithmscpp_pybind.Graph\n\n\ncovariance\ncovariance(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, rewards1: list[float], rewards2: list[float]) -&gt; float\n\n\ncovariance_discrete\ncovariance_discrete(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, rewards1: list[float], rewards2: list[float]) -&gt; float\n\n\ncreate_vertex\ncreate_vertex(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, state: list[int]) -&gt; ptdalgorithms::Vertex\n\n\ndefect\ndefect(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph) -&gt; float\n\n\ndistribution_context\ndistribution_context(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, granularity: int = 0) -&gt; ptdalgorithms::ProbabilityDistributionContext\n\n\ndistribution_context_discrete\ndistribution_context_discrete(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph) -&gt; ptdalgorithms::DPHProbabilityDistributionContext\n\n\nexpectation\nexpectation(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, rewards: list[float] = []) -&gt; float\n\n\nexpectation_dag\nexpectation_dag(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, rewards: list[float]) -&gt; ptdalgorithms.ptdalgorithmscpp_pybind.Graph\n\n\nexpectation_discrete\nexpectation_discrete(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, arg0: list[float]) -&gt; float\n\n\nexpected_residence_time\nexpected_residence_time(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, rewards: list[float] = []) -&gt; list[float]\n\n\nexpected_visits_discrete\nexpected_visits_discrete(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, jumps: int) -&gt; list[float]\n\n\nexpected_waiting_time\nexpected_waiting_time(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, rewards: list[float] = []) -&gt; list[float]\n\n\nfind_or_create_vertex\nfind_or_create_vertex(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, state: list[int]) -&gt; ptdalgorithms::Vertex\n\n\nfind_vertex\nfind_vertex(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, state: list[int]) -&gt; ptdalgorithms::Vertex\n\n\nfocv\nfocv(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, state: list[int]) -&gt; ptdalgorithms::Vertex\n\n\nis_acyclic\nis_acyclic(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph) -&gt; bool\n\n\nmoments\nmoments(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, power: int, rewards: list[float] = []) -&gt; list[float]\n\n\nnormalize\nnormalize(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph) -&gt; list[float]\n\n\nnormalize_discrete\nnormalize_discrete(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph) -&gt; list[float]\n\n\nnotify_change\nnotify_change(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph) -&gt; None\n\n\npdf\npdf(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, time: numpy.ndarray[numpy.float32], granularity: numpy.ndarray[numpy.int32] = 0) -&gt; object\n\n\npmf_discrete\npmf_discrete(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, jumps: numpy.ndarray[numpy.int32]) -&gt; object\n\n\nrandom_sample_discrete_stop_vertex\nrandom_sample_discrete_stop_vertex(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, jumps: int) -&gt; int\n\n\nrandom_sample_stop_vertex\nrandom_sample_stop_vertex(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, time: float) -&gt; int\n\n\nreward_transform\nreward_transform(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, rewards: list[float]) -&gt; ptdalgorithms.ptdalgorithmscpp_pybind.Graph\n\n\nreward_transform_discrete\nreward_transform_discrete(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, rewards: list[int]) -&gt; ptdalgorithms.ptdalgorithmscpp_pybind.Graph\n\n\nsample\nsample(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, n: int = 1, rewards: list[float] = []) -&gt; list[float]\n\n\nsample_discrete\nsample_discrete(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, n: int = 1, rewards: list[float] = []) -&gt; list[float]\n\n\nsample_multivariate\nsample_multivariate(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, n: int = 1, rewards: numpy.ndarray[numpy.float64[m, n]] = []) -&gt; numpy.ndarray[numpy.float64[m, n]]\n\n\nsample_multivariate_discrete\nsample_multivariate_discrete(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, n: int = 1, rewards: numpy.ndarray[numpy.float64[m, n]] = []) -&gt; numpy.ndarray[numpy.float64[m, n]]\n\n\nstarting_vertex\nstarting_vertex(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph) -&gt; ptdalgorithms::Vertex\n\n\nstate_length\nstate_length(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph) -&gt; int\n\n\nstates\nstates(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph) -&gt; numpy.ndarray[numpy.int32[m, n]]\n\n\nstop_probability\nstop_probability(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, time: float, granularity: int = 0) -&gt; list[float]\n\n\nstop_probability_discrete\nstop_probability_discrete(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, jumps: int) -&gt; list[float]\n\n\nupdate_parameterized_weights\nupdate_parameterized_weights(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, rewards: list[float]) -&gt; None\n\n\nvalidate\nvalidate(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph) -&gt; None\n\n\nvariance\nvariance(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, rewards: list[float] = []) -&gt; float\n\n\nvariance_discrete\nvariance_discrete(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, arg0: list[float]) -&gt; float\n\n\nvertex_at\nvertex_at(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, index: int) -&gt; ptdalgorithms::Vertex\n\n\nvertex_exists\nvertex_exists(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, state: list[int]) -&gt; bool\n\n\nvertices\nvertices(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph) -&gt; list[ptdalgorithms::Vertex]\n\n\nvertices_length\nvertices_length(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph) -&gt; int\n\n\n\n\n\nptdalgorithms.Graph.accumulated_visiting_time()\naccumulated_visiting_time(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, time: float, granularity: int = 0) -&gt; list[float]\n\n\n\nptdalgorithms.Graph.accumulated_visits_discrete()\naccumulated_visits_discrete(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, jumps: int) -&gt; list[float]\n\n\n\nptdalgorithms.Graph.as_matrices()\nas_matrices(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph) -&gt; ptdalgorithms.ptdalgorithmscpp_pybind.MatrixRepresentation\n\n\n\nptdalgorithms.Graph.cdf()\ncdf(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, time: numpy.ndarray[numpy.float32], granularity: numpy.ndarray[numpy.int32] = 0) -&gt; object\n\n\n\nptdalgorithms.Graph.cdf_discrete()\ncdf_discrete(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, jumps: numpy.ndarray[numpy.int32]) -&gt; object\n\n\n\nptdalgorithms.Graph.clone()\nclone(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph) -&gt; ptdalgorithms.ptdalgorithmscpp_pybind.Graph\n\n\n\nptdalgorithms.Graph.covariance()\ncovariance(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, rewards1: list[float], rewards2: list[float]) -&gt; float\n\n\n\nptdalgorithms.Graph.covariance_discrete()\ncovariance_discrete(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, rewards1: list[float], rewards2: list[float]) -&gt; float\n\n\n\nptdalgorithms.Graph.create_vertex()\ncreate_vertex(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, state: list[int]) -&gt; ptdalgorithms::Vertex\n\n\n\nptdalgorithms.Graph.defect()\ndefect(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph) -&gt; float\n\n\n\nptdalgorithms.Graph.distribution_context()\ndistribution_context(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, granularity: int = 0) -&gt; ptdalgorithms::ProbabilityDistributionContext\n\n\n\nptdalgorithms.Graph.distribution_context_discrete()\ndistribution_context_discrete(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph) -&gt; ptdalgorithms::DPHProbabilityDistributionContext\n\n\n\nptdalgorithms.Graph.expectation()\nexpectation(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, rewards: list[float] = []) -&gt; float\n//’ Computes the expectation (mean) of the phase-type distribution //’ //’ @description //’ This function invokes [ptdalgorithms::expected_waiting_times()] //’ and takes the first entry (from starting vertex) //’ //’ @return The expectation of the distribution //’ //’ @param phase_type_graph A reference to the graph created by [ptdalgorithms::create_graph()] //’ @param rewards Optional rewards, which should be applied to the phase-type distribution. Must have length equal to [ptdalgorithms::vertices_length()] //’ //’ @seealso [ptdalgorithms::expected_waiting_time()] //’ @seealso [ptdalgorithms::moments()] //’ @seealso [ptdalgorithms::variance()] //’ @seealso [ptdalgorithms::covariance()] //’ //’ @examples //’ graph &lt;- ptdalgorithms::create_graph(4) //’ v1 &lt;- ptdalgorithms::create_vertex(graph, c(1,2,3,4)) //’ v2 &lt;- ptdalgorithms::create_vertex(graph, c(4,0,3,3)) //’ a &lt;- ptdalgorithms::create_vertex(graph, c(0,0,0,0)) //’ ptdalgorithms::add_edge(ptdalgorithms::starting_vertex(graph), v1, 1) //’ ptdalgorithms::add_edge(v1, v2, 4) //’ ptdalgorithms::add_edge(v2, a, 10) //’ ptdalgorithms::expectation(graph) # =&gt; //’ 0.35 //’ ptdalgorithms::expectation(graph, c(0,2,1,0)) # =&gt; //’ 0.6 //’ ph &lt;- ptdalgorithms::graph_as_matrix(graph) //’ # This is a much faster version of //’ ph\\(IPV%*%solve(-ph\\)SIM) %% rep(1, length(ph\\(IPV)) # =&gt;\n//'   0.35\n//' ph\\)IPV%%solve(-ph\\(SIM) %*% diag(c(2,1))%*% rep(1, length(ph\\)IPV)) # =&gt; //’ 0.35\n\n\n\nptdalgorithms.Graph.expectation_dag()\nexpectation_dag(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, rewards: list[float]) -&gt; ptdalgorithms.ptdalgorithmscpp_pybind.Graph\n\n\n\nptdalgorithms.Graph.expectation_discrete()\nexpectation_discrete(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, arg0: list[float]) -&gt; float\n\n\n\nptdalgorithms.Graph.expected_residence_time()\nexpected_residence_time(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, rewards: list[float] = []) -&gt; list[float]\n\n\n\nptdalgorithms.Graph.expected_visits_discrete()\nexpected_visits_discrete(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, jumps: int) -&gt; list[float]\n\n\n\nptdalgorithms.Graph.expected_waiting_time()\nexpected_waiting_time(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, rewards: list[float] = []) -&gt; list[float]\n\n\n\nptdalgorithms.Graph.find_or_create_vertex()\nfind_or_create_vertex(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, state: list[int]) -&gt; ptdalgorithms::Vertex\n//’ Find or create a vertex matching state //’ //’ @description //’ Finds a vertex by the state parameter. If no such //’ vertex exists, it creates the vertex and adds it to //’ the graph object instead. //’ //’ @details //’ A faster and simpler version of calling [ptdalgorithms::find_vertex()] and [ptdalgorithms::create_vertex()] //’ //’ @return The newly found or inserted vertex in the graph //’ //’ @param phase_type_graph A reference to the graph created by [ptdalgorithms::create_graph()] //’ @param state An integer vector of what vertex to look for. Has length as given by state_length in [ptdalgorithms::create_graph()] //’ //’ @examples //’ graph &lt;- create_graph(4) //’ find_or_create_vertex(graph, c(1,2,1,0)) # Adds and returns the vertex //’ find_or_create_vertex(graph, c(1,2,1,0)) # Only returns the vertex //’ # graph is now changed permanently\n\n\n\nptdalgorithms.Graph.find_vertex()\nfind_vertex(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, state: list[int]) -&gt; ptdalgorithms::Vertex\n\n\n\nptdalgorithms.Graph.focv()\nfocv(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, state: list[int]) -&gt; ptdalgorithms::Vertex\nAlias for find_or_create_vertex\n\n\n\nptdalgorithms.Graph.is_acyclic()\nis_acyclic(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph) -&gt; bool\n\n\n\nptdalgorithms.Graph.moments()\nmoments(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, power: int, rewards: list[float] = []) -&gt; list[float]\n//’ Computes the first k moments of the phase-type distribution //’ //’ @description //’ This function invokes [ptdalgorithms::expected_waiting_times()] consequtively to find the first moments, //’ given by the power argument //’ //’ @return A numeric vector of the first k moments. The first entry is the first moment (mean) //’ //’ @param phase_type_graph A reference to the graph created by [ptdalgorithms::create_graph()] //’ @param power An integer of the first k moments. //’ @param rewards Optional rewards, which should be applied to the phase-type distribution. Must have length equal to [ptdalgorithms::vertices_length()] //’ //’ @seealso [ptdalgorithms::expected_waiting_time()] //’ @seealso [ptdalgorithms::expectation()] //’ @seealso [ptdalgorithms::variance()] //’ @seealso [ptdalgorithms::covariance()] //’ //’ @examples //’ graph &lt;- ptdalgorithms::create_graph(4) //’ v1 &lt;- ptdalgorithms::create_vertex(graph, c(1,2,3,4)) //’ v2 &lt;- ptdalgorithms::create_vertex(graph, c(4,0,3,3)) //’ a &lt;- ptdalgorithms::create_vertex(graph, c(0,0,0,0)) //’ ptdalgorithms::add_edge(ptdalgorithms::starting_vertex(graph), v1, 1) //’ ptdalgorithms::add_edge(v1, v2, 4) //’ ptdalgorithms::add_edge(v2, a, 10) //’ ptdalgorithms::moments(graph, 3) # =&gt; //’ (0.350000 0.097500 0.025375) //’ ptdalgorithms::moments(graph, 3, c(0,2,1,0)) # =&gt; //’ (0.600 0.160 0.041)\n\n\n\nptdalgorithms.Graph.normalize()\nnormalize(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph) -&gt; list[float]\n\n\n\nptdalgorithms.Graph.normalize_discrete()\nnormalize_discrete(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph) -&gt; list[float]\n\n\n\nptdalgorithms.Graph.notify_change()\nnotify_change(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph) -&gt; None\n\n\n\nptdalgorithms.Graph.pdf()\npdf(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, time: numpy.ndarray[numpy.float32], granularity: numpy.ndarray[numpy.int32] = 0) -&gt; object\n\n\n\nptdalgorithms.Graph.pmf_discrete()\npmf_discrete(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, jumps: numpy.ndarray[numpy.int32]) -&gt; object\n\n\n\nptdalgorithms.Graph.random_sample_discrete_stop_vertex()\nrandom_sample_discrete_stop_vertex(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, jumps: int) -&gt; int\n\n\n\nptdalgorithms.Graph.random_sample_stop_vertex()\nrandom_sample_stop_vertex(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, time: float) -&gt; int\n\n\n\nptdalgorithms.Graph.reward_transform()\nreward_transform(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, rewards: list[float]) -&gt; ptdalgorithms.ptdalgorithmscpp_pybind.Graph\n\n\n\nptdalgorithms.Graph.reward_transform_discrete()\nreward_transform_discrete(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, rewards: list[int]) -&gt; ptdalgorithms.ptdalgorithmscpp_pybind.Graph\n\n\n\nptdalgorithms.Graph.sample()\nsample(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, n: int = 1, rewards: list[float] = []) -&gt; list[float]\n\n\n\nptdalgorithms.Graph.sample_discrete()\nsample_discrete(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, n: int = 1, rewards: list[float] = []) -&gt; list[float]\n\n\n\nptdalgorithms.Graph.sample_multivariate()\nsample_multivariate(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, n: int = 1, rewards: numpy.ndarray[numpy.float64[m, n]] = []) -&gt; numpy.ndarray[numpy.float64[m, n]]\n\n\n\nptdalgorithms.Graph.sample_multivariate_discrete()\nsample_multivariate_discrete(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, n: int = 1, rewards: numpy.ndarray[numpy.float64[m, n]] = []) -&gt; numpy.ndarray[numpy.float64[m, n]]\n\n\n\nptdalgorithms.Graph.starting_vertex()\nstarting_vertex(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph) -&gt; ptdalgorithms::Vertex\n\n\n\nptdalgorithms.Graph.state_length()\nstate_length(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph) -&gt; int\n\n\n\nptdalgorithms.Graph.states()\nstates(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph) -&gt; numpy.ndarray[numpy.int32[m, n]]\n//’ Returns a matrix where each row is the state of the vertex at that index //’ //’ @return A matrix of size [ptdalgorithms::vertices_length()] where the rows match the state of the vertex at that index //’ //’ @param phase_type_graph A reference to the graph created by [ptdalgorithms::create_graph()] //’ //’ @examples //’ graph &lt;- ptdalgorithms::create_graph(4) //’ ptdalgorithms::create_vertex(graph, c(1,2,3,4)) //’ ptdalgorithms::create_vertex(graph, c(4,3,3,3)) //’ ptdalgorithms::states(graph) # =&gt; //’ # 0 0 0 0 //’ # 1 2 3 4 //’ # 4 3 3 3\n\n\n\nptdalgorithms.Graph.stop_probability()\nstop_probability(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, time: float, granularity: int = 0) -&gt; list[float]\n\n\n\nptdalgorithms.Graph.stop_probability_discrete()\nstop_probability_discrete(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, jumps: int) -&gt; list[float]\n\n\n\nptdalgorithms.Graph.update_parameterized_weights()\nupdate_parameterized_weights(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, rewards: list[float]) -&gt; None\n//’ Updates all parameterized edges of the graph by given scalars. //’ //’ @description //’ Given a vector of scalars, computes a new weight of //’ the parameterized edges in the graph by a simple inner //’ product of the edge state vector and the scalar vector. //’ //’ @details //’ A faster and simpler version to compute new moments, when //’ the user wants to try multiple different weights. //’ //’ //’ @param phase_type_graph A reference to the graph created by [ptdalgorithms::create_graph()] //’ @param scalars A numeric vector of multiplies for the edge states. //’ //’ @seealso [ptdalgorithms::expected_waiting_time()] //’ @seealso [ptdalgorithms::add_edge()] //’ //’ @examples //’ graph &lt;- create_graph(4) //’ v1 &lt;- find_or_create_vertex(graph, c(1,2,1,0)) //’ v2 &lt;- find_or_create_vertex(graph, c(2,0,1,0)) //’ add_edge(starting_vertex(graph), v1, 5) //’ add_edge(v1, v2, 0, c(5,2)) //’ edges(starting_vertex(graph))[[1]]\\(weight # =&gt; 5\n//' edges(v1)[[1]]\\)weight # =&gt; 0 //’ graph_update_weights_parameterized(graph, c(9,7)) //’ edges(starting_vertex(graph))[[1]]\\(weight # =&gt; 5\n//' edges(v1)[[1]]\\)weight # =&gt; 59\n\n\n\nptdalgorithms.Graph.validate()\nvalidate(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph) -&gt; None\n\n\n\nptdalgorithms.Graph.variance()\nvariance(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, rewards: list[float] = []) -&gt; float\n//’ Computes the variance of the phase-type distribution //’ //’ @description //’ This function invokes [ptdalgorithms::expected_waiting_times()] //’ twice to find the first and second moment //’ //’ @return The variance of the distribution //’ //’ @param phase_type_graph A reference to the graph created by [ptdalgorithms::create_graph()] //’ @param rewards Optional rewards, which should be applied to the phase-type distribution. Must have length equal to [ptdalgorithms::vertices_length()] //’ //’ @seealso [ptdalgorithms::expected_waiting_time()] //’ @seealso [ptdalgorithms::expectation()] //’ @seealso [ptdalgorithms::moments()] //’ @seealso [ptdalgorithms::covariance()] //’ //’ @examples //’ graph &lt;- ptdalgorithms::create_graph(4) //’ v1 &lt;- ptdalgorithms::create_vertex(graph, c(1,2,3,4)) //’ v2 &lt;- ptdalgorithms::create_vertex(graph, c(4,0,3,3)) //’ a &lt;- ptdalgorithms::create_vertex(graph, c(0,0,0,0)) //’ ptdalgorithms::add_edge(ptdalgorithms::starting_vertex(graph), v1, 1) //’ ptdalgorithms::add_edge(v1, v2, 4) //’ ptdalgorithms::add_edge(v2, a, 10) //’ ptdalgorithms::variance(graph) # =&gt; //’ 0.0725 //’ ptdalgorithms::variance(graph, c(0,2,1,0)) # =&gt; //’ 0.26 //’ ph &lt;- ptdalgorithms::graph_as_matrix(graph) //’ # This is a much faster version of //’ 2ph\\(IPV%*%solve(-ph\\)SIM)%%solve(-ph\\(SIM) %*% rep(1, length(ph\\)IPV)) - ph\\(IPV%*%solve(-ph\\)SIM) %% rep(1, length(ph\\(IPV)) %*% ph\\)IPV%%solve(-ph\\(SIM) %*% rep(1, length(ph\\)IPV)) # =&gt; //’ 0.0725 //’ 2ph\\(IPV%*%solve(-ph\\)SIM)%%diag(c(2,1))%%solve(-ph\\(SIM)%*%diag(c(2,1)) %*% rep(1, length(ph\\)IPV)) - ph\\(IPV%*%solve(-ph\\)SIM)%%diag(c(2,1)) %% rep(1, length(ph\\(IPV)) %*% ph\\)IPV%%solve(-ph\\(SIM)%*%diag(c(2,1)) %*% rep(1, length(ph\\)IPV)) # =&gt; //’ 0.26\n\n\n\nptdalgorithms.Graph.variance_discrete()\nvariance_discrete(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, arg0: list[float]) -&gt; float\n\n\n\nptdalgorithms.Graph.vertex_at()\nvertex_at(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, index: int) -&gt; ptdalgorithms::Vertex\n\n\n\nptdalgorithms.Graph.vertex_exists()\nvertex_exists(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph, state: list[int]) -&gt; bool\n\n\n\nptdalgorithms.Graph.vertices()\nvertices(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph) -&gt; list[ptdalgorithms::Vertex]\n//’ Obtain a list of all vertices in the graph //’ //’ @description //’ Returns all vertices that have been added to the //’ graph from either calling find_or_create_vertex or //’ create_vertex. The first vertex in the list is //’ always the starting vertex [ptdalgorithms::starting_vertex()]. //’ Importantly, for speed, use [ptdalgorithms::vertices_length()] to get the number //’ of added vertices, and use [ptdalgorithms::vertex_at()] to //’ get a vertex at a particular index. //’ //’ @details //’ The list of vertices contains any added vertex, even //’ if it does not have any in-going / out-going edges. //’ //’ @param phase_type_graph A reference to the graph created by [ptdalgorithms::create_graph()] //’ //’ @seealso [ptdalgorithms::starting_vertex()] //’ @seealso [ptdalgorithms::vertices_length()] //’ @seealso [ptdalgorithms::vertex_at()] //’ //’ @examples //’ graph &lt;- create_graph(4) //’ vertex_a &lt;- find_or_create_vertex(graph, c(1,2,1,0)) //’ vertex_b &lt;- find_or_create_vertex(graph, c(2,0,1,0)) //’ vertices(graph)[[1]] == starting_vertex(graph) //’ vertices(graph)[[2]] == vertex_at(graph, 2) //’ vertices_length(graph) == 3\n\n\n\nptdalgorithms.Graph.vertices_length()\nvertices_length(self: ptdalgorithms.ptdalgorithmscpp_pybind.Graph) -&gt; int",
    "crumbs": [
      "Some section",
      "Graph"
    ]
  },
  {
    "objectID": "api/Vertex.html",
    "href": "api/Vertex.html",
    "title": "Vertex",
    "section": "",
    "text": "ptdalgorithms.Vertex()\n\n\n\n\n\nName\nDescription\n\n\n\n\nadd_edge\nadd_edge(self: ptdalgorithms.ptdalgorithmscpp_pybind.Vertex, to: ptdalgorithms.ptdalgorithmscpp_pybind.Vertex, weight: float) -&gt; None\n\n\nadd_edge_parameterized\nadd_edge_parameterized(self: ptdalgorithms.ptdalgorithmscpp_pybind.Vertex, to: ptdalgorithms.ptdalgorithmscpp_pybind.Vertex, weight: float, edge_state: list[float]) -&gt; None\n\n\nae\nae(self: ptdalgorithms.ptdalgorithmscpp_pybind.Vertex, to: ptdalgorithms.ptdalgorithmscpp_pybind.Vertex, weight: float) -&gt; None\n\n\nedges\nedges(self: ptdalgorithms.ptdalgorithmscpp_pybind.Vertex) -&gt; list[ptdalgorithms::Edge]\n\n\nindex\nindex(self: ptdalgorithms.ptdalgorithmscpp_pybind.Vertex) -&gt; int\n\n\nrate\nrate(self: ptdalgorithms.ptdalgorithmscpp_pybind.Vertex) -&gt; float\n\n\nstate\nstate(self: ptdalgorithms.ptdalgorithmscpp_pybind.Vertex) -&gt; list[int]\n\n\n\n\n\nptdalgorithms.Vertex.add_edge()\nadd_edge(self: ptdalgorithms.ptdalgorithmscpp_pybind.Vertex, to: ptdalgorithms.ptdalgorithmscpp_pybind.Vertex, weight: float) -&gt; None\n//’ Adds an edge between two vertices in the graph //’ //’ @description //’ The graph represents transitions between states as //’ a weighted direction edge between two vertices. //’ //’ @seealso [ptdalgorithms::expected_waiting_time()] //’ @seealso [ptdalgorithms::moments()] //’ @seealso [ptdalgorithms::variance()] //’ @seealso [ptdalgorithms::covariance()] //’ @seealso [ptdalgorithms::graph_update_weights_parameterized()] //’ //’ @param phase_type_vertex_from The vertex that transitions from //’ @param phase_type_vertex_to The vertex that transitions to //’ @param weight The weight of the edge, i.e. the transition rate //’ @param parameterized_edge_state Optional. Associate a numeric vector to an edge, for faster computations of moments when weights are changed. //’ //’ @examples //’ graph &lt;- create_graph(4) //’ vertex_a &lt;- find_or_create_vertex(graph, c(1,2,1,0)) //’ vertex_b &lt;- find_or_create_vertex(graph, c(2,0,1,0)) //’ add_edge(vertex_a, vertex_b, 1.5)\n\n\n\nptdalgorithms.Vertex.add_edge_parameterized()\nadd_edge_parameterized(self: ptdalgorithms.ptdalgorithmscpp_pybind.Vertex, to: ptdalgorithms.ptdalgorithmscpp_pybind.Vertex, weight: float, edge_state: list[float]) -&gt; None\n\n\n\nptdalgorithms.Vertex.ae()\nae(self: ptdalgorithms.ptdalgorithmscpp_pybind.Vertex, to: ptdalgorithms.ptdalgorithmscpp_pybind.Vertex, weight: float) -&gt; None\nAlias for add_edge\n\n\n\nptdalgorithms.Vertex.edges()\nedges(self: ptdalgorithms.ptdalgorithmscpp_pybind.Vertex) -&gt; list[ptdalgorithms::Edge]\n\n\n\nptdalgorithms.Vertex.index()\nindex(self: ptdalgorithms.ptdalgorithmscpp_pybind.Vertex) -&gt; int\n\n\n\nptdalgorithms.Vertex.rate()\nrate(self: ptdalgorithms.ptdalgorithmscpp_pybind.Vertex) -&gt; float\n\n\n\nptdalgorithms.Vertex.state()\nstate(self: ptdalgorithms.ptdalgorithmscpp_pybind.Vertex) -&gt; list[int]",
    "crumbs": [
      "Some section",
      "Vertex"
    ]
  },
  {
    "objectID": "api/Vertex.html#methods",
    "href": "api/Vertex.html#methods",
    "title": "Vertex",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nadd_edge\nadd_edge(self: ptdalgorithms.ptdalgorithmscpp_pybind.Vertex, to: ptdalgorithms.ptdalgorithmscpp_pybind.Vertex, weight: float) -&gt; None\n\n\nadd_edge_parameterized\nadd_edge_parameterized(self: ptdalgorithms.ptdalgorithmscpp_pybind.Vertex, to: ptdalgorithms.ptdalgorithmscpp_pybind.Vertex, weight: float, edge_state: list[float]) -&gt; None\n\n\nae\nae(self: ptdalgorithms.ptdalgorithmscpp_pybind.Vertex, to: ptdalgorithms.ptdalgorithmscpp_pybind.Vertex, weight: float) -&gt; None\n\n\nedges\nedges(self: ptdalgorithms.ptdalgorithmscpp_pybind.Vertex) -&gt; list[ptdalgorithms::Edge]\n\n\nindex\nindex(self: ptdalgorithms.ptdalgorithmscpp_pybind.Vertex) -&gt; int\n\n\nrate\nrate(self: ptdalgorithms.ptdalgorithmscpp_pybind.Vertex) -&gt; float\n\n\nstate\nstate(self: ptdalgorithms.ptdalgorithmscpp_pybind.Vertex) -&gt; list[int]\n\n\n\n\n\nptdalgorithms.Vertex.add_edge()\nadd_edge(self: ptdalgorithms.ptdalgorithmscpp_pybind.Vertex, to: ptdalgorithms.ptdalgorithmscpp_pybind.Vertex, weight: float) -&gt; None\n//’ Adds an edge between two vertices in the graph //’ //’ @description //’ The graph represents transitions between states as //’ a weighted direction edge between two vertices. //’ //’ @seealso [ptdalgorithms::expected_waiting_time()] //’ @seealso [ptdalgorithms::moments()] //’ @seealso [ptdalgorithms::variance()] //’ @seealso [ptdalgorithms::covariance()] //’ @seealso [ptdalgorithms::graph_update_weights_parameterized()] //’ //’ @param phase_type_vertex_from The vertex that transitions from //’ @param phase_type_vertex_to The vertex that transitions to //’ @param weight The weight of the edge, i.e. the transition rate //’ @param parameterized_edge_state Optional. Associate a numeric vector to an edge, for faster computations of moments when weights are changed. //’ //’ @examples //’ graph &lt;- create_graph(4) //’ vertex_a &lt;- find_or_create_vertex(graph, c(1,2,1,0)) //’ vertex_b &lt;- find_or_create_vertex(graph, c(2,0,1,0)) //’ add_edge(vertex_a, vertex_b, 1.5)\n\n\n\nptdalgorithms.Vertex.add_edge_parameterized()\nadd_edge_parameterized(self: ptdalgorithms.ptdalgorithmscpp_pybind.Vertex, to: ptdalgorithms.ptdalgorithmscpp_pybind.Vertex, weight: float, edge_state: list[float]) -&gt; None\n\n\n\nptdalgorithms.Vertex.ae()\nae(self: ptdalgorithms.ptdalgorithmscpp_pybind.Vertex, to: ptdalgorithms.ptdalgorithmscpp_pybind.Vertex, weight: float) -&gt; None\nAlias for add_edge\n\n\n\nptdalgorithms.Vertex.edges()\nedges(self: ptdalgorithms.ptdalgorithmscpp_pybind.Vertex) -&gt; list[ptdalgorithms::Edge]\n\n\n\nptdalgorithms.Vertex.index()\nindex(self: ptdalgorithms.ptdalgorithmscpp_pybind.Vertex) -&gt; int\n\n\n\nptdalgorithms.Vertex.rate()\nrate(self: ptdalgorithms.ptdalgorithmscpp_pybind.Vertex) -&gt; float\n\n\n\nptdalgorithms.Vertex.state()\nstate(self: ptdalgorithms.ptdalgorithmscpp_pybind.Vertex) -&gt; list[int]",
    "crumbs": [
      "Some section",
      "Vertex"
    ]
  },
  {
    "objectID": "pages/joint_prob.html",
    "href": "pages/joint_prob.html",
    "title": "Joint probabilities",
    "section": "",
    "text": "This pages is under construction",
    "crumbs": [
      "Advanced",
      "Joint probabilities"
    ]
  },
  {
    "objectID": "pages/coalescent_showcase.html",
    "href": "pages/coalescent_showcase.html",
    "title": "The coalescent",
    "section": "",
    "text": "import ptdalgorithms as ptd\n\nAnother example is the Coalescent, fully specified with only the code below:\n\ndef coalescent(state):\n    transitions = []\n    for i in range(nr_samples):\n        for j in range(i, nr_samples):            \n            same = int(i == j)\n            if same and state[i] &lt; 2:\n                continue\n            if not same and (state[i] &lt; 1 or state[j] &lt; 1):\n                continue \n            new = state[:]\n            new[i] -= 1\n            new[j] -= 1\n            new[i+j+1] += 1\n            transitions.append((new, state[i]*(state[j]-same)/(1+same)))\n    return transitions\n\nnr_samples = 4\ngraph = ptd.Graph(callback=coalescent, initial=[nr_samples]+[0]*nr_samples)\ngraph.plot()\n\n\n\n\n\n\n\n\nComputing the expected TMRCA is then just:\n\ngraph.expectation()\n\nINFO: building reward compute graph...\n\n\n1.5\n\n\nThe graph grows quickly with the number of samples:\n\nnr_samples = 15\ngraph = ptd.Graph(callback=coalescent, initial=[nr_samples]+[0]*nr_samples)\ngraph.plot()\n\n\n\n\n\n\n\n\n\ngraph.expectation()\n\nINFO: building reward compute graph...\n\n\n1.866666666666666\n\n\n\n\n\n\n\n\nThis pages is under construction"
  },
  {
    "objectID": "pages/distributions.html",
    "href": "pages/distributions.html",
    "title": "Distributions",
    "section": "",
    "text": "This pages is under construction",
    "crumbs": [
      "Basics",
      "Distributions"
    ]
  },
  {
    "objectID": "pages/laplace.html",
    "href": "pages/laplace.html",
    "title": "Laplace transform",
    "section": "",
    "text": "This pages is under construction",
    "crumbs": [
      "Basics",
      "Laplace transform"
    ]
  },
  {
    "objectID": "pages/full_python_api_example.html",
    "href": "pages/full_python_api_example.html",
    "title": "Full Python API example of ptdalgorithms",
    "section": "",
    "text": "This notebook will describe almost all functions of the ptdalgorithms Python package. The core functionality is implemented in C, with a binding layer to Python through C++ and pybind11. Except for the specified construction code of the state space, most code will be almost equally fast to invoking the C api directly (maybe twice as slow). The package is based on graph algorithms published in (…), and is many orders of magnitude faster than matrix-based equations which are usually applied. We do not recommend using the C++ api directly.\nWe will show how to install the package and construct a state space through the Python api. We will then show how to compute the moments (expectation, variance) through the ptdalgorithms package, and how to compute the distribution functions. This means that you can make discrete and continuous phase-type distributions, compute their moments, distribution functions, sample from them, compute rewards and multivariate distributions, and time inhomogenous distributions.\nWe will also show how easy it is to create the state-space in C and return it to Python, to make large graphs!\n%load_ext autoreload\n%autoreload 2"
  },
  {
    "objectID": "pages/full_python_api_example.html#installing-the-ptdalgorithms-library",
    "href": "pages/full_python_api_example.html#installing-the-ptdalgorithms-library",
    "title": "Full Python API example of ptdalgorithms",
    "section": "Installing the ptdalgorithms library",
    "text": "Installing the ptdalgorithms library\nUsing conda (recommended):\nconda install -c conda-forge -c munch-group ptdalgorithms\nUsing pip:\npip install ptdalgorithms\n\nimport pandas as pd\nimport numpy as np\nnp.random.seed(42)\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\n# plt.style.use('dark_background')\n# import matplotlib\n# matplotlib.rcParams['axes.facecolor'] = '#1F1F1F'\n# matplotlib.rcParams['figure.facecolor'] = '#1F1F1F'\n\n\n#%matplotlib widget\n\n%config InlineBackend.figure_format = 'retina'\n\nimport ptdalgorithms as ptd"
  },
  {
    "objectID": "pages/full_python_api_example.html#continuous-phase-type-distribution",
    "href": "pages/full_python_api_example.html#continuous-phase-type-distribution",
    "title": "Full Python API example of ptdalgorithms",
    "section": "Continuous phase-type distribution",
    "text": "Continuous phase-type distribution\nWe can now construct the graphs by the function. The flooding rates are set to 2 and 4\n\ngraph = construct_rabbit_graph(2, 2, 4)\n\nGet the number of vertices in the graph:\n\ngraph.vertices_length()\n\n7\n\n\nas well as integer vector states that those vertices represent:\n\nM = graph.states()\nM\n\narray([[0, 0],\n       [2, 0],\n       [1, 1],\n       [0, 0],\n       [0, 2],\n       [0, 1],\n       [1, 0]], dtype=int32)\n\n\n(or nicely as a dataframe):\n\npd.DataFrame(M, columns=[\"Rabbits left\", \"Rabbits right\"]).style.hide()\n\n\n\n\n\n\nRabbits left\nRabbits right\n\n\n\n\n0\n0\n\n\n2\n0\n\n\n1\n1\n\n\n0\n0\n\n\n0\n2\n\n\n0\n1\n\n\n1\n0\n\n\n\n\n\nThis phase-type distribution models the time until all rabits have died. For convenience, we can get its expectation and variance like this:\n\ngraph.expectation()\n\nINFO: building reward compute graph...\n\n\n0.5038265306122448\n\n\n\ngraph.variance()\n\n0.2264567497917534\n\n\nBut if you want you can get any number of moments like this (here three):\n\ngraph.moments(3)\n\n[0.5038265306122448, 0.48029792274052463, 0.6559101757731152]\n\n\nWe can find the expected waiting time given that we start in any of the states, not just the starting state:\n\ngraph.expected_waiting_time()\n\n[0.5038265306122448,\n 0.5038265306122448,\n 0.5114795918367346,\n 0.0,\n 0.30229591836734687,\n 0.28571428571428564,\n 0.4285714285714285]\n\n\nIf needed for downstream analysis, matrix-based representation of the phase-type distribution can be extracted. Note that the indices in this representatoin do not correspond to vertex indicies in the graph."
  },
  {
    "objectID": "pages/full_python_api_example.html#rewards",
    "href": "pages/full_python_api_example.html#rewards",
    "title": "Full Python API example of ptdalgorithms",
    "section": "Rewards",
    "text": "Rewards\nWe can add rewards which are based on the number of rabbits on the second island.\n\nrewards = graph.states()[:, 1]\n\nCan also be computed like this:\n\nrewards = np.array([graph.vertex_at(i).state()[1] for i in range(graph.vertices_length())])\n\nAdding these rewards, the phase-type distribution now represent the total accumulated time that any rabbits spends on the right island.\nUsing rewards to the moment functions etc. is much faster than changing the graph.\nThe expectation and variance are now:\n\ngraph.expectation(rewards), graph.variance(rewards)\n\n(0.09438775510204081, 0.04634787588504789)\n\n\nUsing rewards to the moment functions etc. is much faster than actually changing the graph, but sometimes we might want to be interested in reward transforming the phase-type distribution, giving us the full distribution of accumulated rewards. For example if we want the pdf/cdf.\n\nright_graph = graph.reward_transform(rewards)\n\nNow we get the expectation and variance from before without adding any rewards:\n\nright_graph.expectation(), right_graph.variance()\n\nINFO: building reward compute graph...\n\n\n(0.09438775510204081, 0.04634787588504791)\n\n\nWe can find the distribution function for the the total accumulate time spent by any rabbit on an island. We show here the PDF and CDF\n\naccumulated_rewards = np.arange(0, 2, 0.01)\n\npdf = right_graph.pdf(accumulated_rewards)\ncdf = right_graph.cdf(accumulated_rewards)\n\nPDF and CDF of distribution. Notice how we have a “defect” i.e. a probability of obtaining no rewards:\n\nright_graph.defect()\n\n0.6666666666666666\n\n\nThe defect is shown with a dotted line below. Remember to always consider this defect.\n\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(8, 3), sharey=True)\nax1.plot(accumulated_rewards, pdf)\nax1.set_title(\"PDF\")\nax1.set_ylim(bottom=0)\nax2.plot(accumulated_rewards, cdf)\nax2.set_title(\"CDF\")\nax2.set_ylim(bottom=0)\nax2.axhline(y=right_graph.defect(), linestyle='dotted', color='black')\nsns.despine()\n\n\n\n\n\n\n\n\nThere are also utility methods to get the stop probability i.e. probabilities of occupying each state at time t.\n\ngraph.stop_probability(0.2)\n\n[0.0,\n 0.5561531639166896,\n 0.07040541534825098,\n 0.0,\n 0.007095725804629082,\n 0.016348108066650276,\n 0.03374890558205247]\n\n\nWe can use that to compute the expected number of rabbits across time:\n\ntimes = np.arange(0, 2, 0.05)\nexpected_rabbits_left = [\n    np.sum(graph.stop_probability(i) \n           * np.sum(graph.states(), axis=1)) \n    for i in times\n    ]\n\nfig, ax = plt.subplots(1, 1, figsize=(4, 3))\nax.plot(times, expected_rabbits_left)\nax.set_xlabel('time')\nax.set_ylabel(\"Expected nr rabbits\")\nsns.despine()\n\n\n\n\n\n\n\n\nWe can also get the accumulated visiting time of a particular state. E.g. the total time before time t=0.5 where there was a rabbit on the right island:\n\nrewards = (graph.states()[:,1]&gt;0).astype(int)\nnp.sum(graph.accumulated_visiting_time(time=0.5) * rewards)\n\nnp.float64(0.04053231796047568)\n\n\n\ngraph.expected_residence_time()\n\n[0.0, 0.5038265306122448, 0.0, 0.0, 0.0, 0.0, 0.0]"
  },
  {
    "objectID": "pages/full_python_api_example.html#discrete-phase-type-distributions",
    "href": "pages/full_python_api_example.html#discrete-phase-type-distributions",
    "title": "Full Python API example of ptdalgorithms",
    "section": "Discrete phase-type distributions",
    "text": "Discrete phase-type distributions\nWe can also work with discrete phase-type distributions. This is the number of jumps in a Markov Chain before absorption. We will model that any rabbit can find a carrot at each time with rate 0.1 and see how many carrots the rabbits will have found. We could of course just make a new state-space creation function, but we can also manipulate existing.\n\ncarrot_graph = graph.clone()\nvlength = carrot_graph.vertices_length()\ncarrot_vertices = np.repeat(False, vlength*2)\n\n\nfor i in range(vlength):\n    vertex = carrot_graph.vertex_at(i)\n    rabbits = sum(vertex.state())\n    \n    if rabbits &gt; 0:\n        obtained_carrot_vertex = carrot_graph.create_vertex([0])\n        # Go directly back to the state we came from\n        obtained_carrot_vertex.add_edge(vertex, 1)\n        # Rate of finding carrot\n        vertex.add_edge(obtained_carrot_vertex, rabbits * 0.1)\n        carrot_vertices[obtained_carrot_vertex.index()] = True\n\n\n\n\n\nvlength = carrot_graph.vertices_length()\ncarrot_vertices = np.repeat(False, vlength*2)\n\nfor i in range(vlength):\n    vertex = carrot_graph.vertex_at(i)\n    rabbits = sum(vertex.state())\n    \n    if rabbits &gt; 0:\n        obtained_carrot_vertex = carrot_graph.create_vertex([0])\n        # Go directly back to the state we came from\n        obtained_carrot_vertex.add_edge(vertex, 1)\n        # Rate of finding carrot\n        vertex.add_edge(obtained_carrot_vertex, rabbits * 0.1)\n        carrot_vertices[obtained_carrot_vertex.index()] = True\n\ncarrot_vertices = carrot_vertices[np.arange(carrot_graph.vertices_length())]\n\n# We now want to make the graph discrete. We do this by 'normalizing' the edges\n# This is imply scaling the vertices such that the total out-going rate is 1\n# As it is now the probability of transitions\nweights_were_multiplied_with = carrot_graph.normalize()\n\nprint(\"This is the discrete state space as a sub-transition matrix:\")\n#carrot_graph.as_matrices()\n\nThis is the discrete state space as a sub-transition matrix:\n\n\n\nfor vertex in carrot_graph.vertices():\n    print(vertex.index(),vertex.state(), vertex.edges())\n\n0 [0, 0] [1-(2,0)]\n1 [2, 0] [0.294118-(1,1), 0.588235-(0,0), 0.0588235-(0,0), 0.0588235-(0,0)]\n2 [1, 1] [0.119048-(0,2), 0.238095-(0,1), 0.119048-(2,0), 0.47619-(1,0), 0.0238095-(0,0), 0.0238095-(0,0)]\n3 [0, 0] []\n4 [0, 2] [0.185185-(1,1), 0.740741-(0,0), 0.037037-(0,0), 0.037037-(0,0)]\n5 [0, 1] [0.192308-(1,0), 0.769231-(0,0), 0.0192308-(0,0), 0.0192308-(0,0)]\n6 [1, 0] [0.3125-(0,1), 0.625-(0,0), 0.03125-(0,0), 0.03125-(0,0)]\n7 [0, 0] [1-(2,0)]\n8 [0, 0] [1-(1,1)]\n9 [0, 0] [1-(0,2)]\n10 [0, 0] [1-(0,1)]\n11 [0, 0] [1-(1,0)]\n12 [0, 0] [1-(2,0)]\n13 [0, 0] [1-(1,1)]\n14 [0, 0] [1-(0,2)]\n15 [0, 0] [1-(0,1)]\n16 [0, 0] [1-(1,0)]\n\n\n\nfor vertex in carrot_graph.vertices():\n    print(vertex)\n    for edge in vertex.edges():\n        print(\"  \", edge)\n\n(0,0)\n   1-(2,0)\n(2,0)\n   0.294118-(1,1)\n   0.588235-(0,0)\n   0.0588235-(0,0)\n   0.0588235-(0,0)\n(1,1)\n   0.119048-(0,2)\n   0.238095-(0,1)\n   0.119048-(2,0)\n   0.47619-(1,0)\n   0.0238095-(0,0)\n   0.0238095-(0,0)\n(0,0)\n(0,2)\n   0.185185-(1,1)\n   0.740741-(0,0)\n   0.037037-(0,0)\n   0.037037-(0,0)\n(0,1)\n   0.192308-(1,0)\n   0.769231-(0,0)\n   0.0192308-(0,0)\n   0.0192308-(0,0)\n(1,0)\n   0.3125-(0,1)\n   0.625-(0,0)\n   0.03125-(0,0)\n   0.03125-(0,0)\n(0,0)\n   1-(2,0)\n(0,0)\n   1-(1,1)\n(0,0)\n   1-(0,2)\n(0,0)\n   1-(0,1)\n(0,0)\n   1-(1,0)\n(0,0)\n   1-(2,0)\n(0,0)\n   1-(1,1)\n(0,0)\n   1-(0,2)\n(0,0)\n   1-(0,1)\n(0,0)\n   1-(1,0)\n\n\n\ncarrot_vertices.astype(int)\n\narray([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1])\n\n\nWe now want to find the expected number of eaten carrots. We set the reward such that the carrot vertex has a reward of ‘1’.\n\nrewards = carrot_vertices.astype(int)\ncarrot_graph.expectation_discrete(rewards)\n\nINFO: building reward compute graph...\n\n\n0.09056122448979592\n\n\nWe can verify that the number of carrots correspond to scaling the continuous graph:\n\ngraph.expectation(graph.states().sum(axis=1)) * 0.1\n\n0.09056122448979591\n\n\nOf course we cannot do this for other moments:\n\ncarrot_graph.variance_discrete(rewards)\n\n0.09723142700957937\n\n\nVerified by sampling:\n\nsamples = carrot_graph.sample_discrete(1000000, rewards)\nsamples = np.array(samples)\nnp.sum(samples**2) / 1000000 - ((np.sum(samples)) / 1000000)**2\n\nnp.float64(0.097734344375)\n\n\n\n# We can find the distribution function for the the total number of carrots found\ncarrots = np.arange(10)\n# Notice that with this reward transformation the graph is no longer sparse, as all paths through\n# the graph are represented!!\nfound_carrots_graph  = carrot_graph.reward_transform_discrete(rewards)\npmf = found_carrots_graph.pmf_discrete(carrots)\ncdf = found_carrots_graph.cdf_discrete(carrots)\n\n\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(8, 3), sharey=True)\nx = np.arange(0, 10, 1)\nax1.plot(x, pmf)\nax1.set_title(\"PDF\")\nax1.set_xlabel('Total number of carrots found')\n# ax1.set_ylim(bottom=0)\nax2.plot(x, cdf)\nax2.set_title(\"CDF\")\n# ax2.set_ylim(bottom=0)\nax2.set_xlabel('Total number of carrots found')\nax2.axhline(y=right_graph.defect(), linestyle='dotted', color='black')\nsns.despine()"
  },
  {
    "objectID": "pages/full_python_api_example.html#parameterized-edges",
    "href": "pages/full_python_api_example.html#parameterized-edges",
    "title": "Full Python API example of ptdalgorithms",
    "section": "Parameterized edges",
    "text": "Parameterized edges\nWe can parameterize the edges to easily update the weights of the edge\nWe do this by assigning a state to the edge.\nWe will now also say that the rate of rabbits jumping is proportional to the number of rabbits on the island.\nOur state is [rabbits able to jump, left flooding, right flooding]\n\n\ndef construct_rabbit_graph_params(nr_rabbits):\n    # We represent the vector as two integers, the number of rabbits on the left and right island\n    state_vector_length = 2\n    graph = ptd.Graph(state_vector_length)\n    initial_state = [nr_rabbits, 0]\n    # The initial state is the only starting state, with 100% starting probability\n    graph.starting_vertex().add_edge(\n      graph.find_or_create_vertex(initial_state),\n      1\n    )\n    index = 1\n    # Iterate over all unvisited vertices\n    while index &lt; graph.vertices_length():\n      vertex = graph.vertex_at(index)\n      state = vertex.state()\n      if state[0] &gt; 0:\n        # Rabbit jump left to right\n        child_state = [state[0] - 1, state[1] + 1]\n        vertex.add_edge_parameterized(\n          graph.find_or_create_vertex(child_state),\n          0,\n          [state[0],0,0]\n        )\n        # Left island flooding\n        child_state = c(0, state[1])\n        vertex.add_edge_parameterized(\n          graph.find_or_create_vertex(child_state),\n          0,\n          [0,1,0]\n        )\n      if state[1] &gt; 0:\n        # Rabbit jump right to left\n        child_state = [state[0] + 1, state[1] - 1]\n        vertex.add_edge_parameterized(\n          graph.find_or_create_vertex(child_state),\n          0, \n          [state[1],0,0]\n        )\n        # Right island flooding with rate of 4\n        child_state = [state[0], 0]\n        vertex.add_edge_parameterized(\n          graph.find_or_create_vertex(child_state),\n          0,\n          [0,0,1]\n        )\n      index = index + 1\n\n    return(graph)\n\nThe parameterized edges have what ever weight is assigned to them, and the state does not by itself mean anything.\n\nparam_graph = construct_rabbit_graph_params(2)\n\nIf we let the edge have a state, this gives us an easy way of changing the weights based on some model parameters. In this case, it is the rate of jumping left rate of flooding and right rate of flooding.\nThe update simply takes the inner product of the state vector and the model parameters, e.g. if the state is x1, x2 and the parameters are p1, p2, then the weight of the edge becomed x1p1+x2p2\n\nparam_graph.update_parameterized_weights([1, 2, 4])\nprint(\"Expectation (1,2,4):\", param_graph.expectation())\n\nparam_graph.update_parameterized_weights([2, 2, 4])\nprint(\"Expectation (1,2,4):\", param_graph.expectation())\n\nparam_graph.update_parameterized_weights([2, 4, 4])\nprint(\"Expectation (1,2,4):\", param_graph.expectation())\n\nparam_graph.update_parameterized_weights([2, 4, 18])\nprint(\"Expectation (1,2,4):\", param_graph.expectation())\n\nparam_graph.update_parameterized_weights([8, 4, 18])\nprint(\"Expectation (1,2,4):\", param_graph.expectation())\n\nExpectation (1,2,4): 0.5083056478405314\nExpectation (1,2,4): 0.49565217391304334\nExpectation (1,2,4): 0.30000000000000004\nExpectation (1,2,4): 0.22709632268736477\nExpectation (1,2,4): 0.17719439369563442\n\n\nINFO: building reward compute graph...\nINFO: building reward compute graph...\nINFO: building reward compute graph...\nINFO: building reward compute graph...\nINFO: building reward compute graph...\n\n\nNote that the moment graph has to be recalculated after updating weights\n\nparam_graph.update_parameterized_weights([1, 2, 4])\n#param_graph.as_matrices()\n      \nparam_graph.update_parameterized_weights([8, 4, 18])\n#param_graph.as_matrices()"
  },
  {
    "objectID": "pages/full_python_api_example.html#time-inhomogeneity",
    "href": "pages/full_python_api_example.html#time-inhomogeneity",
    "title": "Full Python API example of ptdalgorithms",
    "section": "Time inhomogeneity",
    "text": "Time inhomogeneity\nIf the weights change over time - or new edges are added!\nThen the distribution is time inhomogeneous. The api also supports such distributions, but in limited manner.\nLike the pph, dph, etc. functions, it is a (very good) approximation based on very small steps. If the rates change dramatically, set the granularity as an argument to the functions!! E.g. set it to a high enough value.\nIf we pick a time far into the future, we can integrate under the pdf to find the expectation!\nIntegrating over accumulated visiting time:\n\nsum(graph.accumulated_visiting_time(10))\n\n0.5038265306014538\n\n\nThe first moment (expectation):\n\ngraph.expectation()\n\n0.5038265306122448\n\n\nSay at a certain point in time, the flooding starts!\nIn the beginning, there is no flooding\n\nparam_graph.update_parameterized_weights([1, 0, 0])\n\nWe can build a context to step over the distribution. Weights can be freely changed and edges added in such a context\n\n# import ptdalgorithms as ptd\n# import numpy as np\n\n# def c(*args):\n#     elem = []\n#     for arg in args:\n#         if hasattr(arg, '__len__') and len(arg) &gt; 1:\n#             elem.extend(arg)\n#         else:\n#             elem.append(arg)\n#     return np.array(elem)\n\n\n# nr_rabbits, flood_left, flood_right = 2, 2, 4\n\n# # we represent the vector as two integers, the number of \n# # rabbits on the left and right island\n# state_vector_length = 2\n# graph = ptd.Graph(state_vector_length)\n\n# # the initial state is the only starting state, with probability 1\n# initial_state = c(nr_rabbits, 0)\n# vertex = graph.find_or_create_vertex(initial_state)\n# graph.starting_vertex().add_edge(vertex, 1)\n\n# index = 1\n# # iterate over all unvisited vertices\n# while index &lt; graph.vertices_length():\n#     vertex = graph.vertex_at(index)\n#     state = vertex.state()\n    \n#     if state[0] &gt; 0:\n#         # rabbit jump left to right\n#         child_state = c(state[0] - 1, state[1] + 1)\n#         vertex.add_edge(\n#             graph.find_or_create_vertex(child_state),\n#             weight=1\n#         )\n#         # left island flooding\n#         child_state = c(0, state[1])\n#         vertex.add_edge(\n#             graph.find_or_create_vertex(child_state), \n#             weight=flood_left\n#         )\n#     if state[1] &gt; 0:   \n#         child_state = c(state[0] + 1, state[1] - 1)\n#         vertex.add_edge(\n#             graph.find_or_create_vertex(child_state),\n#             weight=1\n#         )\n#         # right island flooding\n#         child_state = c(state[0], 0)\n#         vertex.add_edge(\n#             graph.find_or_create_vertex(child_state), \n#             weight=flood_right\n#         )\n\n#     index += 1\n    \n# # graph.plot(nodesep=1, ranksep=0.1)\n\n\n\n# ctx = graph.distribution_context()\n# cdfs = []\n# times = []\n\n# # while ctx.time() &lt; 1.5:\n# while ctx.cdf() &lt; 0.999:\n\n#     cdfs.append(ctx.cdf())\n#     times.append(ctx.time())\n#     param_graph.update_parameterized_weights(\n#         [1,\n#         ctx.time() - 1.5, \n#         2 * ctx.time() - 1.5\n#         ]\n#     )\n#     ctx.step()\n\nIt increases by every time step. Time until all rabbits are dead. Flooding increases linearly after 1.5 time units:\n\nparam_graph.update_parameterized_weights([1, 0, 0])\n\nctx = param_graph.distribution_context()\ncdfs = []\ntimes = []\n\nwhile ctx.time() &lt; 1.5:\n    cdfs.append(ctx.cdf())\n    times.append(ctx.time())\n    ctx.step()\n\n#param_graph.update_parameterized_weights([1, 1, 1])\n\n# at time 1.5, the flooding starts!\nwhile ctx.cdf() &lt; 0.999:\n    cdfs.append(ctx.cdf())\n    times.append(ctx.time())\n    param_graph.update_parameterized_weights(\n        [1,\n        ctx.time() - 1.5, \n        2 * ctx.time() - 1.5\n        ]\n    )\n    ctx.step()\n\nfig, ax = plt.subplots(1, 1, figsize=(4, 3))\nax.plot(times, cdfs)\nsns.despine()\n\n\n\n\n\n\n\n\nIf we pick a time far into the future, we can integrate under it to find the expectation. This means that we can scale by a reward, and thereby find the marginal expectation.\nSumming over accumulated visiting time (with reward):\n\nnp.sum(graph.accumulated_visiting_time(10)*graph.states()[:,1])\n\nnp.float64(0.09438775509887067)\n\n\nThe first moment (expectation) (with reward):\n\ngraph.expectation(graph.states()[:,1])\n\n0.09438775510204081\n\n\nBut if the time is not far into the future, we get the expectation up to a certain point in time.\nExpectation (rewarded) when truncating at 0.05 time:\n\nnp.sum(graph.accumulated_visiting_time(0.05)*graph.states()[:,1])\n\nnp.float64(0.0011713234985744549)\n\n\nUntruncated expectation:\n\ngraph.expectation(graph.states()[:,1])\n\n0.09438775510204081\n\n\nExpectation (rewarded) when starting at 0.05 time:\n\ngraph.expected_waiting_time(graph.states()[:,1])\n\n[0.09438775510204081,\n 0.09438775510204081,\n 0.28316326530612246,\n 0.0,\n 0.4566326530612244,\n 0.21428571428571422,\n 0.0714285714285714]\n\n\n\nnp.sum(graph.stop_probability(0.05)*np.array(graph.expected_waiting_time(graph.states()[:,1])))\n\nnp.float64(0.09325811466426455)\n\n\nSubtracting these gives the same value:\n\n(graph.expectation(graph.states()[:,1]) \\\n     - np.sum(graph.stop_probability(0.05) \\\n              * np.array(graph.expected_waiting_time(graph.states()[:,1])))\n)\n\nnp.float64(0.0011296404377762609)\n\n\nWe can increase granularity for better performance:\n\nnp.sum(graph.accumulated_visiting_time(0.05, granularity=1000000)*graph.states()[:,1])\n\nnp.float64(0.0011138317897953385)"
  },
  {
    "objectID": "pages/epochs.html",
    "href": "pages/epochs.html",
    "title": "Epochs",
    "section": "",
    "text": "This pages is under construction",
    "crumbs": [
      "Advanced",
      "Epochs"
    ]
  },
  {
    "objectID": "pages/state_lumping.html",
    "href": "pages/state_lumping.html",
    "title": "State lumping",
    "section": "",
    "text": "This pages is under construction",
    "crumbs": [
      "Advanced",
      "State lumping"
    ]
  },
  {
    "objectID": "pages/getting_started.html",
    "href": "pages/getting_started.html",
    "title": "Getting started",
    "section": "",
    "text": "The ptdalgorithms library provides fast and scalable algorithms for constructing and computing properties of phase-type distributions with support for both continuous and discrete, unrewarded and rewarded, univariate and multivariate distributions. For sparse models, it can be orders of magnitude faster. The code is written in C, but exposes an interface to both C, R and Python through a C++ layer.\nThe library computes moments (e.g. expectation, variance, covariance), distribution functions (pdf, cdf, pmf), laplace transform, and Markov chain stopping time probabilities. Although phase-type distributions are time-homogeneous, the library also computes moments and univariate distributions for epoch-wise time-inhomogeneous models as well as full joint probability distributions.",
    "crumbs": [
      "Getting started"
    ]
  },
  {
    "objectID": "pages/getting_started.html#installation",
    "href": "pages/getting_started.html#installation",
    "title": "Getting started",
    "section": "Installation",
    "text": "Installation\nconda install -c munch-group -c conda-forge ptdalgorithms",
    "crumbs": [
      "Getting started"
    ]
  },
  {
    "objectID": "pages/getting_started.html#quickstart",
    "href": "pages/getting_started.html#quickstart",
    "title": "Getting started",
    "section": "Quickstart",
    "text": "Quickstart\n\n\n\n\n\n\nThis pages is under construction",
    "crumbs": [
      "Getting started"
    ]
  },
  {
    "objectID": "pages/state_space.html",
    "href": "pages/state_space.html",
    "title": "State space",
    "section": "",
    "text": "The state-space is built as a graph using an simple API and take up very little space compared to a matrix representation. It handles millions of vertices (states) and edges (transitions) and is munch faster than the traditional matrix-based computation relying on (sparse) matrix inversion and exponentiation.\nConsider this model: Rabbits jump between two islands at a rate of one. The two islands are flooded at rates 2 and 4 drowning all rabbits on the flooded island. The end (absorbing) is when no more rabbits are left.\nIn ptdalgorithms, each state is represented by a sequence of integers. To represent states in the rabbit model, we only need two such integer to represent the number of rabbits on the left and right islands. Laid out as in the above picture, the states are:\nTo skip some of the boilerplate you can pass a callback function and an initial state to Graph. The callback function must take as the only argument a list of int representing a state, and return: a list of tuples that each represent reachable child state and the associated transition rate. To create a callback function, just think of rules of your model and ask yourself:\nHere is an example for our rabbit model: If the current state is “two rabbits on the left island” ([2, 0]), the reachable states are: “one rabbit on each island” ([1, 1]) if one rabbit jumps and and “no rabbits” ([0, 0]) if the island is flodded. So if the callback function is called like this:\nit should return\nTogether, the callback and initial state fully specifies the model. Here is what they look like for the rabbit model:\nnr_rabbits, flood_left, flood_right = 2, 2, 4\n\ndef rabbit_islands(state):\n    nr_left, nr_right = state\n    reachable = []\n    if state[0] &gt; 0:\n        reachable.append(([nr_left-1, nr_right+1], 1))\n        reachable.append(([0,         nr_right  ], flood_left))\n    if state[1] &gt; 0:   \n        reachable.append(([nr_left+1, nr_right-1], 1))\n        reachable.append(([nr_left,   0         ], flood_right))\n    return reachable\n\ninitial_state = [nr_rabbits, 0]\nTo then build the state space all you need to do is:\nimport ptdalgorithms as ptd\n\ngraph = ptd.Graph(callback=rabbit_islands, initial=initial_state)\nPlot it to make sure it looks as expected. The gray S state is the “starting state” immediately transiting one or more model states where the model is allowed to begin. In the rabbit model, S goes to state 2,0 with probability 1 because the model can only begin there. The end (absorbing) state 0,0 is also colored gray.\ngraph.plot()",
    "crumbs": [
      "Basics",
      "State space"
    ]
  },
  {
    "objectID": "pages/state_space.html#off-to-the-races",
    "href": "pages/state_space.html#off-to-the-races",
    "title": "State space",
    "section": "Off to the races",
    "text": "Off to the races\nNow the world is at your command. To scratch the surfance you can compute the expected time to rabbit extinction:\n\ngraph.expectation()\n\n0.5038265306122448\n\n\nbut there is so much more you can do to explore your rabbit model. For a full exposé of the API using the rabbit example see the full python API example.\n\n\n\n\n\n\nThis pages is under construction",
    "crumbs": [
      "Basics",
      "State space"
    ]
  },
  {
    "objectID": "pages/state_space.html#learning-more",
    "href": "pages/state_space.html#learning-more",
    "title": "State space",
    "section": "Learning more",
    "text": "Learning more\n\nSee Python API walk through for a full example of the Python API.\nSee R API walk through for a full example of the R API.",
    "crumbs": [
      "Basics",
      "State space"
    ]
  },
  {
    "objectID": "pages/state_space.html#citing-ptdalgorithms",
    "href": "pages/state_space.html#citing-ptdalgorithms",
    "title": "State space",
    "section": "Citing ptdalgorithms",
    "text": "Citing ptdalgorithms\nGraph-based algorithms for phase-type distributions, Statistics and Computing (2022)",
    "crumbs": [
      "Basics",
      "State space"
    ]
  },
  {
    "objectID": "pages/moments.html",
    "href": "pages/moments.html",
    "title": "Moments",
    "section": "",
    "text": "This pages is under construction",
    "crumbs": [
      "Basics",
      "Moments"
    ]
  },
  {
    "objectID": "pages/tutorial.html",
    "href": "pages/tutorial.html",
    "title": "ptdalgorithms",
    "section": "",
    "text": "PythonRC\n\n\nprint(\"Hello world\")\n\n\ncat(\"Hello world\")\n\n\nprintf(\"Hello World\");"
  },
  {
    "objectID": "api/index.html",
    "href": "api/index.html",
    "title": "Function reference",
    "section": "",
    "text": "Some description…\n\n\n\nGraph\n\n\n\nVertex\n\n\n\nEdge",
    "crumbs": [
      "Function reference"
    ]
  },
  {
    "objectID": "api/index.html#some-section",
    "href": "api/index.html#some-section",
    "title": "Function reference",
    "section": "",
    "text": "Some description…\n\n\n\nGraph\n\n\n\nVertex\n\n\n\nEdge",
    "crumbs": [
      "Function reference"
    ]
  },
  {
    "objectID": "api/Edge.html",
    "href": "api/Edge.html",
    "title": "Edge",
    "section": "",
    "text": "ptdalgorithms.Edge()\n\n\n\n\n\nName\nDescription\n\n\n\n\nto\nto(self: ptdalgorithms.ptdalgorithmscpp_pybind.Edge) -&gt; ptdalgorithms.ptdalgorithmscpp_pybind.Vertex\n\n\nupdate_weight\nupdate_weight(self: ptdalgorithms.ptdalgorithmscpp_pybind.Edge, arg0: float) -&gt; None\n\n\nweight\nweight(self: ptdalgorithms.ptdalgorithmscpp_pybind.Edge) -&gt; float\n\n\n\n\n\nptdalgorithms.Edge.to()\nto(self: ptdalgorithms.ptdalgorithmscpp_pybind.Edge) -&gt; ptdalgorithms.ptdalgorithmscpp_pybind.Vertex\n\n\n\nptdalgorithms.Edge.update_weight()\nupdate_weight(self: ptdalgorithms.ptdalgorithmscpp_pybind.Edge, arg0: float) -&gt; None\n\n\n\nptdalgorithms.Edge.weight()\nweight(self: ptdalgorithms.ptdalgorithmscpp_pybind.Edge) -&gt; float",
    "crumbs": [
      "Some section",
      "Edge"
    ]
  },
  {
    "objectID": "api/Edge.html#methods",
    "href": "api/Edge.html#methods",
    "title": "Edge",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nto\nto(self: ptdalgorithms.ptdalgorithmscpp_pybind.Edge) -&gt; ptdalgorithms.ptdalgorithmscpp_pybind.Vertex\n\n\nupdate_weight\nupdate_weight(self: ptdalgorithms.ptdalgorithmscpp_pybind.Edge, arg0: float) -&gt; None\n\n\nweight\nweight(self: ptdalgorithms.ptdalgorithmscpp_pybind.Edge) -&gt; float\n\n\n\n\n\nptdalgorithms.Edge.to()\nto(self: ptdalgorithms.ptdalgorithmscpp_pybind.Edge) -&gt; ptdalgorithms.ptdalgorithmscpp_pybind.Vertex\n\n\n\nptdalgorithms.Edge.update_weight()\nupdate_weight(self: ptdalgorithms.ptdalgorithmscpp_pybind.Edge, arg0: float) -&gt; None\n\n\n\nptdalgorithms.Edge.weight()\nweight(self: ptdalgorithms.ptdalgorithmscpp_pybind.Edge) -&gt; float",
    "crumbs": [
      "Some section",
      "Edge"
    ]
  }
]