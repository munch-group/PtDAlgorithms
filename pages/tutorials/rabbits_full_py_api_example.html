<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.25">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Rabbits (full API example)</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" integrity="sha384-ZvpUoO/+PpLXR1lu4jmpXWu80pZlYUAfxl5NsBMWOEPSjUn/6Z/hRTt8+pR6L4N2" crossorigin="anonymous"></script><script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../../pages/modelling/state_space_construction.html" rel="next">
<link href="../../pages/getting_started.html" rel="prev">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-7b89279ff1a6dce999919e0e67d4d9ec.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-8c9e22920c0a905a0fba2b096a481a05.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script src="../../site_libs/quarto-contrib/glightbox/glightbox.min.js"></script>
<link href="../../site_libs/quarto-contrib/glightbox/glightbox.min.css" rel="stylesheet">
<link href="../../site_libs/quarto-contrib/glightbox/lightbox.css" rel="stylesheet">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script src="https://cdn.jsdelivr.net/npm/requirejs@2.3.6/require.min.js" integrity="sha384-c9c+LnTbwQ3aujuU7ULEPVvgLs+Fn6fJUvIGTsuu1ZcCf11fiEubah0ttpca4ntM sha384-6V1/AdqZRWk1KAlWbKBlGhN7VG4iE/yAZcO6NZPMF8od0vukrvr0tg4qY6NSrItx" crossorigin="anonymous"></script>

<script type="application/javascript">define('jquery', [],function() {return window.jQuery;})</script>


<link rel="stylesheet" href="../../api/_styles-quartodoc.css">
<link rel="stylesheet" href="../../numpy.css">
<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-sidebar floating nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <div id="quarto-announcement" data-announcement-id="9616bfb5c47a60811ea96e08f2ae1bd0" class="alert alert-warning hidden"><i class="bi bi-exclamation-lg quarto-announcement-icon"></i><div class="quarto-announcement-content">
<p><strong>Alert</strong> - this is some information that you should pay attention to</p>
</div><i class="bi bi-x-lg quarto-announcement-action"></i></div>
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="../../index.html" class="navbar-brand navbar-brand-logo">
    <img src="../../logo.png" alt="Phasic" class="navbar-logo light-content">
    <img src="../../logo.png" alt="Phasic" class="navbar-logo dark-content">
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../api/"> 
<span class="menu-text">Python API reference</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../r_api/"> 
<span class="menu-text">R API reference</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../c_api/"> 
<span class="menu-text">C API reference</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/munch-group/ptdalgorithms/"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../../pages/tutorials/rabbits_full_py_api_example.html">Tutorials</a></li><li class="breadcrumb-item"><a href="../../pages/tutorials/rabbits_full_py_api_example.html">Rabbits (full API example)</a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header sidebar-header-stacked">
      <a href="../../index.html" class="sidebar-logo-link">
      </a>
      </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../pages/getting_started.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Getting Started</span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true">
 <span class="menu-text">Tutorials</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../pages/tutorials/rabbits_full_py_api_example.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text">Rabbits (full API example)</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../pages/modelling/state_space_construction.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">State space</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../pages/tutorials/coalescent_showcase.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">The coalescent</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" role="navigation" aria-expanded="true">
 <span class="menu-text">How it works</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-2" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../pages/implementation/math_and_alg.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Math and background</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../pages/implementation/architecture.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">PtDAlgorithms Project Architecture</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../pages/implementation/symbolic_gauss_elimination.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Symbolic Graph Elimination for Efficient Parameterized Phase-Type Distributions</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" role="navigation" aria-expanded="true">
 <span class="menu-text">State space modelling</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-3" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../pages/modelling/state_lumping.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">State lumping</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../pages/modelling/laplace.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Laplace transform</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../pages/modelling/epochs.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Epochs</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../pages/modelling/joint_prob.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Joint probabilities</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-4" role="navigation" aria-expanded="true">
 <span class="menu-text">Bayesian inference</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-4" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-4" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../pages/svgd/svgd.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">SVGD Inference</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../pages/svgd/svgd_with_symbolic_dag.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">SVGD Inference with Symbolic DAG Optimization</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-5" role="navigation" aria-expanded="true">
 <span class="menu-text">Distributed Computing</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-5" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-5" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
 <span class="menu-text">pages/distributed/docs/pages/distributed_computing_complete_guide.ipynb</span>
  </li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../pages/distributed/slurm_cluster_setup.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">SLURM Cluster Setup and Configuration</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../pages/distributed/cpu_monitoring.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">CPU monitoring</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-6" role="navigation" aria-expanded="true">
 <span class="menu-text">Popgen examples</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-6" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-6" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
 <span class="menu-text">pages/modelling/coalescent-jointprob.ipynb</span>
  </li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../pages/popgen/isolation_migration.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">isolation_migration.html</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../pages/popgen/two-island-two-locus-arg.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Two Island Two Locus Argument</span></a>
  </div>
</li>
      </ul>
  </li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#installing-the-ptdalgorithms-library" id="toc-installing-the-ptdalgorithms-library" class="nav-link active" data-scroll-target="#installing-the-ptdalgorithms-library">Installing the ptdalgorithms library</a></li>
  <li><a href="#state-space-construction" id="toc-state-space-construction" class="nav-link" data-scroll-target="#state-space-construction">State-space construction</a>
  <ul class="collapse">
  <li><a href="#matrix-interface" id="toc-matrix-interface" class="nav-link" data-scroll-target="#matrix-interface">Matrix interface</a></li>
  <li><a href="#continuous-phase-type-distribution" id="toc-continuous-phase-type-distribution" class="nav-link" data-scroll-target="#continuous-phase-type-distribution">Continuous phase-type distribution</a></li>
  <li><a href="#rewards" id="toc-rewards" class="nav-link" data-scroll-target="#rewards">Rewards</a></li>
  </ul></li>
  <li><a href="#random-sampling" id="toc-random-sampling" class="nav-link" data-scroll-target="#random-sampling">Random sampling</a>
  <ul class="collapse">
  <li><a href="#discrete-phase-type-distributions" id="toc-discrete-phase-type-distributions" class="nav-link" data-scroll-target="#discrete-phase-type-distributions">Discrete phase-type distributions</a></li>
  </ul></li>
  <li><a href="#multivariate-phase-type-distributions" id="toc-multivariate-phase-type-distributions" class="nav-link" data-scroll-target="#multivariate-phase-type-distributions">Multivariate phase-type distributions</a>
  <ul class="collapse">
  <li><a href="#parameterized-edges" id="toc-parameterized-edges" class="nav-link" data-scroll-target="#parameterized-edges">Parameterized edges</a></li>
  <li><a href="#symbolic-elimination-for-ultra-fast-parameter-evaluation" id="toc-symbolic-elimination-for-ultra-fast-parameter-evaluation" class="nav-link" data-scroll-target="#symbolic-elimination-for-ultra-fast-parameter-evaluation">Symbolic Elimination for Ultra-Fast Parameter Evaluation</a></li>
  <li><a href="#caching-symbolic-dags-across-sessions" id="toc-caching-symbolic-dags-across-sessions" class="nav-link" data-scroll-target="#caching-symbolic-dags-across-sessions">Caching Symbolic DAGs Across Sessions</a>
  <ul class="collapse">
  <li><a href="#cache-management-and-collaboration" id="toc-cache-management-and-collaboration" class="nav-link" data-scroll-target="#cache-management-and-collaboration">Cache Management and Collaboration</a></li>
  <li><a href="#combined-performance-symbolic-elimination-caching-jax" id="toc-combined-performance-symbolic-elimination-caching-jax" class="nav-link" data-scroll-target="#combined-performance-symbolic-elimination-caching-jax">Combined Performance: Symbolic Elimination + Caching + JAX</a></li>
  </ul></li>
  <li><a href="#time-inhomogeneity" id="toc-time-inhomogeneity" class="nav-link" data-scroll-target="#time-inhomogeneity">Time inhomogeneity</a></li>
  <li><a href="#modelling-epochs-in-state-space" id="toc-modelling-epochs-in-state-space" class="nav-link" data-scroll-target="#modelling-epochs-in-state-space">Modelling epochs in state space</a></li>
  <li><a href="#laplace-transform" id="toc-laplace-transform" class="nav-link" data-scroll-target="#laplace-transform">Laplace transform</a></li>
  <li><a href="#joint-probabiliity" id="toc-joint-probabiliity" class="nav-link" data-scroll-target="#joint-probabiliity">Joint probabiliity</a></li>
  <li><a href="#distributed-computing-for-large-scale-inference" id="toc-distributed-computing-for-large-scale-inference" class="nav-link" data-scroll-target="#distributed-computing-for-large-scale-inference">Distributed Computing for Large-Scale Inference</a></li>
  <li><a href="#bayesian-inference-with-stein-variational-gradient-descent" id="toc-bayesian-inference-with-stein-variational-gradient-descent" class="nav-link" data-scroll-target="#bayesian-inference-with-stein-variational-gradient-descent">Bayesian Inference with Stein Variational Gradient Descent</a></li>
  <li><a href="#building-the-state-space-in-c" id="toc-building-the-state-space-in-c" class="nav-link" data-scroll-target="#building-the-state-space-in-c">Building the state space in C</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default"><nav class="quarto-page-breadcrumbs quarto-title-breadcrumbs d-none d-lg-block" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../../pages/tutorials/rabbits_full_py_api_example.html">Tutorials</a></li><li class="breadcrumb-item"><a href="../../pages/tutorials/rabbits_full_py_api_example.html">Rabbits (full API example)</a></li></ol></nav>
<div class="quarto-title">
<h1 class="title">Rabbits (full API example)</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p>This comprehensive tutorial explores the complete Python API of the ptdalgorithms library, a high-performance computational framework for working with phase-type distributions. At its core, the library implements sophisticated graph-based algorithms published in peer-reviewed literature, offering performance improvements of several orders of magnitude compared to traditional matrix-based approaches that have dominated the field for decades. The implementation leverages C for computational efficiency, with carefully designed bindings to Python through C++ and pybind11, ensuring that Python users can access near-native performance without sacrificing the convenience and flexibility of high-level scripting.</p>
<p>Throughout this tutorial, we will construct increasingly sophisticated models using a simple but illustrative example: rabbits living on two islands that can jump between islands and face periodic flooding events. This seemingly simple scenario will allow us to explore the full richness of the library’s capabilities, from basic state space construction and moment calculations to advanced features like reward transformations, multivariate distributions, parameterized models, symbolic elimination for ultra-fast parameter sweeps, distributed computing across SLURM clusters, and Bayesian inference using Stein Variational Gradient Descent (SVGD).</p>
<p>The tutorial begins with fundamental operations—constructing state spaces, computing expectations and variances, evaluating distribution functions—and progressively builds toward advanced topics. We will see how to work with both continuous phase-type distributions (modeling time until absorption) and discrete phase-type distributions (modeling the number of transitions before absorption). We will explore rewards, which allow us to compute accumulated quantities along paths through the state space, and multivariate extensions that capture joint distributions of multiple quantities. We will learn how to parameterize edge weights, enabling efficient exploration of parameter space, and how symbolic elimination can accelerate this exploration by orders of magnitude.</p>
<p>In the advanced sections, we will discover how to leverage distributed computing infrastructure, scaling our computations from a single machine to hundreds of nodes on a SLURM cluster. We will see how the library integrates seamlessly with JAX, enabling automatic differentiation and GPU acceleration. Finally, we will apply these tools to Bayesian inference problems, using SVGD to estimate model parameters from observed data—a workflow that combines graph construction, symbolic elimination, distributed computing, and gradient-based optimization into a unified, high-performance pipeline.</p>
<p>By the end of this tutorial, you will have mastered not just the mechanics of the API, but the underlying concepts and workflows that make ptdalgorithms a powerful tool for probabilistic modeling, statistical inference, and computational biology.</p>
<div id="cell-2" class="cell" data-execution_count="2">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co"># %load_ext autoreload</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="co"># %autoreload 2</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<section id="installing-the-ptdalgorithms-library" class="level2">
<h2 class="anchored" data-anchor-id="installing-the-ptdalgorithms-library">Installing the ptdalgorithms library</h2>
<p>Using conda (recommended):</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb2"><pre class="sourceCode txt code-with-copy"><code class="sourceCode default"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>conda install -c conda-forge -c munch-group ptdalgorithms</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Using pip:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb3"><pre class="sourceCode txt code-with-copy"><code class="sourceCode default"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>pip install ptdalgorithms</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div id="cell-6" class="cell" data-execution_count="3">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>np.random.seed(<span class="dv">42</span>)</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> seaborn <span class="im">as</span> sns</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> ptdalgorithms <span class="im">import</span> Graph, set_theme</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>config InlineBackend.figure_format <span class="op">=</span> <span class="st">'retina'</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a><span class="co"># plt.style.use('dark_background')</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a><span class="co"># import matplotlib</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a><span class="co"># matplotlib.rcParams['axes.facecolor'] = '#1F1F1F'</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a><span class="co"># matplotlib.rcParams['figure.facecolor'] = '#1F1F1F'</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a><span class="co">#plt.rcParams['figure.facecolor'], plt.rcParams['axes.facecolor'] = '#1F1F1F', '#1F1F1F'</span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>plt.rcParams.update({<span class="st">'figure.facecolor'</span>: <span class="st">'#1F1F1F'</span>, <span class="st">'axes.facecolor'</span>: <span class="st">'#1F1F1F'</span>})</span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>set_theme(<span class="st">'dark'</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
</section>
<section id="state-space-construction" class="level1">
<h1>State-space construction</h1>
<div id="cell-8" class="cell" data-execution_count="4">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> c(<span class="op">*</span>args):</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    elem <span class="op">=</span> []</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> arg <span class="kw">in</span> args:</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">hasattr</span>(arg, <span class="st">'__len__'</span>) <span class="kw">and</span> <span class="bu">len</span>(arg) <span class="op">&gt;</span> <span class="dv">1</span>:</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>            elem.extend(arg)</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>            elem.append(arg)</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.array(elem)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<div id="cell-9" class="cell" data-execution_count="5">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> print_states(vertex):</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(vertex.state())</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> edge <span class="kw">in</span> vertex.edges():</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="st">" "</span>, edge.weight() , <span class="st">"-&gt;"</span>, edge.to().state())    </span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p>This phase-type distribution models the time until all rabits have died We can find the expectation, variance, moments</p>
<div id="cell-11" class="cell" data-execution_count="6">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> construct_rabbit_graph(nr_rabbits, flood_left, flood_right):</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>    <span class="co"># we represent the vector as two integers, the number of </span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>    <span class="co"># rabbits on the left and right island</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>    state_vector_length <span class="op">=</span> <span class="dv">2</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>    graph <span class="op">=</span> Graph(state_vector_length)</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>    <span class="co"># the initial state is the only starting state, with probability 1</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>    initial_state <span class="op">=</span> [nr_rabbits, <span class="dv">0</span>]</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>    vertex <span class="op">=</span> graph.find_or_create_vertex(initial_state)</span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>    graph.starting_vertex().add_edge(vertex, <span class="dv">1</span>)</span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>    index <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>    <span class="co"># iterate over all unvisited vertices</span></span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> index <span class="op">&lt;</span> graph.vertices_length():</span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a>        vertex <span class="op">=</span> graph.vertex_at(index)</span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a>        state <span class="op">=</span> vertex.state()</span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> state[<span class="dv">0</span>] <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a>            <span class="co"># rabbit jump left to right</span></span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true" tabindex="-1"></a>            child_state <span class="op">=</span> [state[<span class="dv">0</span>] <span class="op">-</span> <span class="dv">1</span>, state[<span class="dv">1</span>] <span class="op">+</span> <span class="dv">1</span>]</span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true" tabindex="-1"></a>            vertex.add_edge(</span>
<span id="cb7-23"><a href="#cb7-23" aria-hidden="true" tabindex="-1"></a>                graph.find_or_create_vertex(child_state),</span>
<span id="cb7-24"><a href="#cb7-24" aria-hidden="true" tabindex="-1"></a>                weight<span class="op">=</span><span class="dv">1</span></span>
<span id="cb7-25"><a href="#cb7-25" aria-hidden="true" tabindex="-1"></a>            )</span>
<span id="cb7-26"><a href="#cb7-26" aria-hidden="true" tabindex="-1"></a>            <span class="co"># left island flooding</span></span>
<span id="cb7-27"><a href="#cb7-27" aria-hidden="true" tabindex="-1"></a>            child_state <span class="op">=</span> [<span class="dv">0</span>, state[<span class="dv">1</span>]]</span>
<span id="cb7-28"><a href="#cb7-28" aria-hidden="true" tabindex="-1"></a>            vertex.add_edge(</span>
<span id="cb7-29"><a href="#cb7-29" aria-hidden="true" tabindex="-1"></a>                graph.find_or_create_vertex(child_state), </span>
<span id="cb7-30"><a href="#cb7-30" aria-hidden="true" tabindex="-1"></a>                weight<span class="op">=</span>flood_left</span>
<span id="cb7-31"><a href="#cb7-31" aria-hidden="true" tabindex="-1"></a>            )</span>
<span id="cb7-32"><a href="#cb7-32" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> state[<span class="dv">1</span>] <span class="op">&gt;</span> <span class="dv">0</span>:   </span>
<span id="cb7-33"><a href="#cb7-33" aria-hidden="true" tabindex="-1"></a>            child_state <span class="op">=</span> [state[<span class="dv">0</span>] <span class="op">+</span> <span class="dv">1</span>, state[<span class="dv">1</span>] <span class="op">-</span> <span class="dv">1</span>]</span>
<span id="cb7-34"><a href="#cb7-34" aria-hidden="true" tabindex="-1"></a>            vertex.add_edge(</span>
<span id="cb7-35"><a href="#cb7-35" aria-hidden="true" tabindex="-1"></a>                graph.find_or_create_vertex(child_state),</span>
<span id="cb7-36"><a href="#cb7-36" aria-hidden="true" tabindex="-1"></a>                weight<span class="op">=</span><span class="dv">1</span></span>
<span id="cb7-37"><a href="#cb7-37" aria-hidden="true" tabindex="-1"></a>            )</span>
<span id="cb7-38"><a href="#cb7-38" aria-hidden="true" tabindex="-1"></a>            <span class="co"># right island flooding</span></span>
<span id="cb7-39"><a href="#cb7-39" aria-hidden="true" tabindex="-1"></a>            child_state <span class="op">=</span> [state[<span class="dv">0</span>], <span class="dv">0</span>]</span>
<span id="cb7-40"><a href="#cb7-40" aria-hidden="true" tabindex="-1"></a>            vertex.add_edge(</span>
<span id="cb7-41"><a href="#cb7-41" aria-hidden="true" tabindex="-1"></a>                graph.find_or_create_vertex(child_state), </span>
<span id="cb7-42"><a href="#cb7-42" aria-hidden="true" tabindex="-1"></a>                weight<span class="op">=</span>flood_right</span>
<span id="cb7-43"><a href="#cb7-43" aria-hidden="true" tabindex="-1"></a>            )</span>
<span id="cb7-44"><a href="#cb7-44" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb7-45"><a href="#cb7-45" aria-hidden="true" tabindex="-1"></a>        index <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb7-46"><a href="#cb7-46" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> graph</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<div id="cell-12" class="cell" data-execution_count="7">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>graph <span class="op">=</span> construct_rabbit_graph(<span class="dv">2</span>, <span class="dv">2</span>, <span class="dv">4</span>)        </span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>graph.states()</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display" data-execution_count="7">
<pre><code>array([[0, 0],
       [2, 0],
       [1, 1],
       [0, 0],
       [0, 2],
       [0, 1],
       [1, 0]], dtype=int32)</code></pre>
</div>
</div>
<p>You can plot the graph for visual inspection:</p>
<div id="cell-14" class="cell" data-execution_count="8">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>graph.plot()</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display" data-execution_count="8">
<div>
<figure class="figure">
<p><a href="rabbits_full_py_api_example_files/figure-html/cell-8-output-1.svg" class="lightbox" data-gallery="quarto-lightbox-gallery-1"><img src="rabbits_full_py_api_example_files/figure-html/cell-8-output-1.svg" class="img-fluid figure-img"></a></p>
</figure>
</div>
</div>
</div>
<p>and group, states by some property, by supplying a lambda function for the <code>subgraphfun</code> keyword argument:</p>
<div id="cell-16" class="cell" data-execution_count="9">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb11"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>graph.plot(subgraphfun<span class="op">=</span><span class="kw">lambda</span> state: <span class="ss">f"#rabbits: </span><span class="sc">{</span><span class="bu">sum</span>(state)<span class="sc">}</span><span class="ss">"</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display" data-execution_count="9">
<div>
<figure class="figure">
<p><a href="rabbits_full_py_api_example_files/figure-html/cell-9-output-1.svg" class="lightbox" data-gallery="quarto-lightbox-gallery-2"><img src="rabbits_full_py_api_example_files/figure-html/cell-9-output-1.svg" class="img-fluid figure-img"></a></p>
</figure>
</div>
</div>
</div>
<p>In an abbreviated version using the aliases <code>ae</code> and <code>focv</code> for <code>add_edge</code> and <code>find_and_create_vertex</code></p>
<div id="cell-18" class="cell" data-execution_count="10">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb12"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>nr_rabbits, flood_left, flood_right <span class="op">=</span> <span class="dv">2</span>, <span class="dv">2</span>, <span class="dv">4</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>graph <span class="op">=</span> Graph(<span class="dv">2</span>)</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>graph.starting_vertex().add_edge(graph.focv(c(nr_rabbits, <span class="dv">0</span>)), <span class="dv">1</span>)</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>i <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> i <span class="op">&lt;</span> graph.vertices_length():</span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>    v <span class="op">=</span> graph.vertex_at(i)</span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>    st <span class="op">=</span> v.state()</span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> st[<span class="dv">0</span>] <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>        v.ae(graph.focv([st[<span class="dv">0</span>]<span class="op">-</span><span class="dv">1</span>, st[<span class="dv">1</span>]<span class="op">+</span><span class="dv">1</span>]), <span class="dv">1</span>)</span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>        v.ae(graph.focv([<span class="dv">0</span>, st[<span class="dv">1</span>]]), flood_left)</span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> st[<span class="dv">1</span>] <span class="op">&gt;</span> <span class="dv">0</span>:   </span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a>        v.ae(graph.focv([st[<span class="dv">0</span>]<span class="op">+</span><span class="dv">1</span>, st[<span class="dv">1</span>]<span class="op">-</span><span class="dv">1</span>]), <span class="dv">1</span>)</span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a>        v.ae(graph.focv([st[<span class="dv">0</span>], <span class="dv">0</span>]), flood_right)</span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a>    i <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true" tabindex="-1"></a><span class="co">#graph.states()</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p>You can skip some of the boilerplate code by passing a callback function and an initial state to <code>Graph</code>. The call back function has the signature <code>callback(List[int]) -&gt; List[Dict]</code>. It takes a list argument specifying a state and returns a list of dictionaries each specifying a child state and an edge weight: <code>{'state': [0, 1], 'weight': 0.4}</code>. This approach is slower and is intended mainly for speed up model development and exploration, and to reduce the amount of code needed to represent many models.</p>
<p>To create a callback function, just think of rules of your model and ask yourself: “Given some state, what are the allowed transitions to other states and with what rates to these transititons occur?”. Make a small dictionary for each such transition with the child state and rate (weight) and return them as a list. Here is an example. If the current state is “two rabbits on the left island” (<code>[2, 0]</code>), the reachable states are: “one rabbit on each island” (<code>[1, 1]</code>) if one rabbit jumps and and “no rabbits” (<code>[0, 0]</code>) if the island is flodded. The callback function should in that case produce the mapping:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb13"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>[<span class="dv">2</span>, <span class="dv">0</span>] <span class="op">-&gt;</span> [{<span class="st">'state'</span>: [<span class="dv">1</span>, <span class="dv">1</span>], <span class="st">'weight'</span>: <span class="dv">1</span>, }, {<span class="st">'state'</span>: [<span class="dv">0</span>, <span class="dv">0</span>], <span class="st">'weight'</span>: flood_left}]</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Here is what the callback function looks like for the rabbit model:</p>
<div id="cell-20" class="cell" data-execution_count="11">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb14"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> rabbit_islands(state):</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>    children <span class="op">=</span> []</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> state[<span class="dv">0</span>] <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>        children.append({<span class="st">'state'</span>: [state[<span class="dv">0</span>]<span class="op">-</span><span class="dv">1</span>, state[<span class="dv">1</span>]<span class="op">+</span><span class="dv">1</span>], <span class="st">'weight'</span>: <span class="dv">1</span>})</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>        children.append({<span class="st">'state'</span>: [<span class="dv">0</span>,          state[<span class="dv">1</span>]  ], <span class="st">'weight'</span>: flood_left})</span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> state[<span class="dv">1</span>] <span class="op">&gt;</span> <span class="dv">0</span>:   </span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>        children.append({<span class="st">'state'</span>: [state[<span class="dv">0</span>]<span class="op">+</span><span class="dv">1</span>, state[<span class="dv">1</span>]<span class="op">-</span><span class="dv">1</span>], <span class="st">'weight'</span>: <span class="dv">1</span>})</span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>        children.append({<span class="st">'state'</span>: [state[<span class="dv">0</span>],   <span class="dv">0</span>         ], <span class="st">'weight'</span>: flood_right})</span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> children</span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a>initial_state <span class="op">=</span> [nr_rabbits, <span class="dv">0</span>]    </span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p>Notice that the usual scoping rules apply to the callback functions: the variables defined outside the function <code>flood_left</code> and <code>flood_right</code> are accessible to the function as for any Python function.</p>
<section id="matrix-interface" class="level2">
<h2 class="anchored" data-anchor-id="matrix-interface">Matrix interface</h2>
<p>To allow imbedding in a matrix based workflow, a matrix-based representation of the phase-type distribution can be extracted from the graph. Note that the indices in the matrix representation do not correspond to vertex indices in the graph.</p>
<div id="cell-24" class="cell" data-execution_count="12">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb15"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>mats <span class="op">=</span> graph.as_matrices()</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Initial probability vector:"</span>)</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(mats.ipv)</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Subintensity matrix:"</span>)</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(mats.sim)</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"States:"</span>)</span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(mats.states)</span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Indicies:"</span>)</span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(mats.indices)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>Initial probability vector:
[0. 0. 1. 0. 0.]
Subintensity matrix:
[[-5.  1.  0.  0.  0.]
 [ 1. -8.  1.  4.  2.]
 [ 0.  1. -3.  0.  0.]
 [ 0.  0.  0. -3.  1.]
 [ 0.  0.  0.  1. -5.]]
States:
[[0 2]
 [1 1]
 [2 0]
 [1 0]
 [0 1]]
Indicies:
[5 3 2 7 6]</code></pre>
</div>
</div>
<p>Although computationally inefficient, the graph can also be constructed from an initial probability vector and a subintensity matrix:</p>
<div id="cell-26" class="cell" data-execution_count="13">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb17"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>graph <span class="op">=</span> Graph.from_matrices(mats.ipv, mats.sim, mats.states)</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>graph.plot()</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display" data-execution_count="13">
<div>
<figure class="figure">
<p><a href="rabbits_full_py_api_example_files/figure-html/cell-13-output-1.svg" class="lightbox" data-gallery="quarto-lightbox-gallery-3"><img src="rabbits_full_py_api_example_files/figure-html/cell-13-output-1.svg" class="img-fluid figure-img"></a></p>
</figure>
</div>
</div>
</div>
<p>If the state argument is not provided, matrix indices are used as matrix states:</p>
<div id="cell-28" class="cell" data-execution_count="14">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb18"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>graph <span class="op">=</span> Graph.from_matrices(mats.ipv, mats.sim)</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>graph.plot()</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display" data-execution_count="14">
<div>
<figure class="figure">
<p><a href="rabbits_full_py_api_example_files/figure-html/cell-14-output-1.svg" class="lightbox" data-gallery="quarto-lightbox-gallery-4"><img src="rabbits_full_py_api_example_files/figure-html/cell-14-output-1.svg" class="img-fluid figure-img"></a></p>
</figure>
</div>
</div>
</div>
</section>
<section id="continuous-phase-type-distribution" class="level2">
<h2 class="anchored" data-anchor-id="continuous-phase-type-distribution">Continuous phase-type distribution</h2>
<p>We can now construct the graphs by the function. The flooding rates are set to 2 and 4</p>
<div id="cell-32" class="cell" data-execution_count="15">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb19"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>graph <span class="op">=</span> construct_rabbit_graph(<span class="dv">2</span>, <span class="dv">2</span>, <span class="dv">4</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p>Get the number of vertices in the graph:</p>
<div id="cell-34" class="cell" data-execution_count="16">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb20"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>graph.vertices_length()</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display" data-execution_count="16">
<pre><code>7</code></pre>
</div>
</div>
<p>as well as integer vector states that those vertices represent:</p>
<div id="cell-36" class="cell" data-execution_count="17">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb22"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>M <span class="op">=</span> graph.states()</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>M</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display" data-execution_count="17">
<pre><code>array([[0, 0],
       [2, 0],
       [1, 1],
       [0, 0],
       [0, 2],
       [0, 1],
       [1, 0]], dtype=int32)</code></pre>
</div>
</div>
<p>(or nicely as a dataframe):</p>
<div id="cell-38" class="cell" data-execution_count="18">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb24"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>pd.DataFrame(M, columns<span class="op">=</span>[<span class="st">"Rabbits left"</span>, <span class="st">"Rabbits right"</span>])<span class="co">#.style.hide()</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display" data-execution_count="18">
<div>


<table class="dataframe caption-top table table-sm table-striped small" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">Rabbits left</th>
<th data-quarto-table-cell-role="th">Rabbits right</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<th data-quarto-table-cell-role="th">0</th>
<td>0</td>
<td>0</td>
</tr>
<tr class="even">
<th data-quarto-table-cell-role="th">1</th>
<td>2</td>
<td>0</td>
</tr>
<tr class="odd">
<th data-quarto-table-cell-role="th">2</th>
<td>1</td>
<td>1</td>
</tr>
<tr class="even">
<th data-quarto-table-cell-role="th">3</th>
<td>0</td>
<td>0</td>
</tr>
<tr class="odd">
<th data-quarto-table-cell-role="th">4</th>
<td>0</td>
<td>2</td>
</tr>
<tr class="even">
<th data-quarto-table-cell-role="th">5</th>
<td>0</td>
<td>1</td>
</tr>
<tr class="odd">
<th data-quarto-table-cell-role="th">6</th>
<td>1</td>
<td>0</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<p>This phase-type distribution models the time until all rabits have died. For convenience, we can get its expectation and variance like this:</p>
<div id="cell-40" class="cell" data-execution_count="19">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb25"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>graph.expectation()</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stderr">
<pre><code>INFO: building reward compute graph...</code></pre>
</div>
<div class="cell-output cell-output-display" data-execution_count="19">
<pre><code>0.5038265306122448</code></pre>
</div>
</div>
<div id="cell-41" class="cell" data-execution_count="20">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb28"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a>graph.variance()</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display" data-execution_count="20">
<pre><code>0.2264567497917534</code></pre>
</div>
</div>
<p>But if you want you can get any number of moments like this (here three):</p>
<div id="cell-43" class="cell" data-execution_count="21">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb30"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a>graph.moments(<span class="dv">3</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display" data-execution_count="21">
<pre><code>[0.5038265306122448, 0.48029792274052463, 0.6559101757731152]</code></pre>
</div>
</div>
<p>We can find the expected waiting time given that we start in any of the states, not just the starting state:</p>
<div id="cell-45" class="cell" data-execution_count="22">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb32"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a>graph.expected_waiting_time()</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display" data-execution_count="22">
<pre><code>[0.5038265306122448,
 0.5038265306122448,
 0.5114795918367346,
 0.0,
 0.30229591836734687,
 0.28571428571428564,
 0.4285714285714285]</code></pre>
</div>
</div>
<p>We can get the CDF and PDF. The distribution methods reuse cached computations and recompute only if the graph changes. Compare the running times for the first and second call to the function:</p>
<div id="cell-48" class="cell" data-execution_count="23">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb34"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a>time <span class="op">=</span> np.arange(<span class="dv">0</span>, <span class="dv">4</span>, <span class="fl">0.001</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<div id="cell-49" class="cell" data-execution_count="24">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb35"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="op">%%</span>time</span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a>cdf <span class="op">=</span> graph.cdf(time)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>CPU times: user 310 μs, sys: 27 μs, total: 337 μs
Wall time: 337 μs</code></pre>
</div>
</div>
<div id="cell-50" class="cell" data-execution_count="25">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb37"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="op">%%</span>time</span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a>cdf <span class="op">=</span> graph.cdf(time)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>CPU times: user 46 μs, sys: 7 μs, total: 53 μs
Wall time: 51 μs</code></pre>
</div>
</div>
<div id="cell-51" class="cell" data-execution_count="26">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb39"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="op">%%</span>time</span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a>pdf <span class="op">=</span> graph.pdf(time)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>CPU times: user 45 μs, sys: 9 μs, total: 54 μs
Wall time: 51.7 μs</code></pre>
</div>
</div>
<p>PDF and CDF of distribution. Observe the long tails!</p>
<div id="cell-53" class="cell" data-execution_count="27">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb41"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a>fig, (ax1, ax2) <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">2</span>, figsize<span class="op">=</span>(<span class="dv">8</span>, <span class="dv">3</span>))</span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a>ax1.plot(time, pdf)</span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a>ax1.set_title(<span class="st">"PDF"</span>)</span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true" tabindex="-1"></a>ax1.set_ylim(bottom<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb41-5"><a href="#cb41-5" aria-hidden="true" tabindex="-1"></a>ax2.plot(time, cdf)</span>
<span id="cb41-6"><a href="#cb41-6" aria-hidden="true" tabindex="-1"></a>ax2.set_title(<span class="st">"CDF"</span>)</span>
<span id="cb41-7"><a href="#cb41-7" aria-hidden="true" tabindex="-1"></a>ax2.set_ylim(bottom<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb41-8"><a href="#cb41-8" aria-hidden="true" tabindex="-1"></a>sns.despine()</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><a href="rabbits_full_py_api_example_files/figure-html/cell-29-output-1.png" class="lightbox" data-gallery="quarto-lightbox-gallery-5"><img src="rabbits_full_py_api_example_files/figure-html/cell-29-output-1.png" width="671" height="296" class="figure-img"></a></p>
</figure>
</div>
</div>
</div>
</section>
<section id="rewards" class="level2">
<h2 class="anchored" data-anchor-id="rewards">Rewards</h2>
<p>We can add rewards which are based on the number of rabbits on the second island.</p>
<div id="cell-56" class="cell" data-execution_count="28">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb42"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a>rewards <span class="op">=</span> graph.states()[:, <span class="dv">1</span>]</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p>Can also be computed like this:</p>
<div id="cell-58" class="cell" data-execution_count="29">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb43"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a>rewards <span class="op">=</span> np.array([graph.vertex_at(i).state()[<span class="dv">1</span>] <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(graph.vertices_length())])</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p>Adding these rewards, the phase-type distribution now represent the total accumulated time that any rabbits spends on the right island.</p>
<p>Using rewards to the moment functions etc. is much faster than changing the graph.</p>
<p>The expectation and variance are now:</p>
<div id="cell-62" class="cell" data-execution_count="30">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb44"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a>graph.expectation(rewards), graph.variance(rewards)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display" data-execution_count="30">
<pre><code>(0.09438775510204081, 0.04634787588504789)</code></pre>
</div>
</div>
<p>Using rewards to the moment functions etc. is much faster than actually changing the graph, but sometimes we might want to be interested in reward transforming the phase-type distribution, giving us the full distribution of accumulated rewards. For example if we want the pdf/cdf.</p>
<div id="cell-64" class="cell" data-execution_count="31">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb46"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a>right_graph <span class="op">=</span> graph.reward_transform(rewards)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p>Now we get the expectation and variance from before without adding any rewards:</p>
<div id="cell-66" class="cell" data-execution_count="32">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb47"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a>right_graph.expectation(), right_graph.variance()</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stderr">
<pre><code>INFO: building reward compute graph...</code></pre>
</div>
<div class="cell-output cell-output-display" data-execution_count="32">
<pre><code>(0.09438775510204081, 0.04634787588504791)</code></pre>
</div>
</div>
<p>We can find the distribution function for the the total accumulate time spent by any rabbit on an island. We show here the PDF and CDF</p>
<div id="cell-68" class="cell" data-execution_count="33">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb50"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a>accumulated_rewards <span class="op">=</span> np.arange(<span class="dv">0</span>, <span class="dv">2</span>, <span class="fl">0.01</span>)</span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-3"><a href="#cb50-3" aria-hidden="true" tabindex="-1"></a>pdf <span class="op">=</span> right_graph.pdf(accumulated_rewards)</span>
<span id="cb50-4"><a href="#cb50-4" aria-hidden="true" tabindex="-1"></a>cdf <span class="op">=</span> right_graph.cdf(accumulated_rewards)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p>PDF and CDF of distribution. Notice how we have a “defect” i.e.&nbsp;a probability of obtaining no rewards:</p>
<div id="cell-70" class="cell" data-tags="[]" data-execution_count="34">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb51"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a>right_graph.defect()</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display" data-execution_count="34">
<pre><code>0.6666666666666666</code></pre>
</div>
</div>
<p>The defect is shown with a dotted line below. Remember to always consider this defect.</p>
<div id="cell-72" class="cell" data-execution_count="35">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb53"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a>fig, (ax1, ax2) <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">2</span>, figsize<span class="op">=</span>(<span class="dv">8</span>, <span class="dv">3</span>), sharey<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb53-2"><a href="#cb53-2" aria-hidden="true" tabindex="-1"></a>ax1.plot(accumulated_rewards, pdf)</span>
<span id="cb53-3"><a href="#cb53-3" aria-hidden="true" tabindex="-1"></a>ax1.set_title(<span class="st">"PDF"</span>)</span>
<span id="cb53-4"><a href="#cb53-4" aria-hidden="true" tabindex="-1"></a>ax1.set_ylim(bottom<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb53-5"><a href="#cb53-5" aria-hidden="true" tabindex="-1"></a>ax2.plot(accumulated_rewards, cdf)</span>
<span id="cb53-6"><a href="#cb53-6" aria-hidden="true" tabindex="-1"></a>ax2.set_title(<span class="st">"CDF"</span>)</span>
<span id="cb53-7"><a href="#cb53-7" aria-hidden="true" tabindex="-1"></a>ax2.set_ylim(bottom<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb53-8"><a href="#cb53-8" aria-hidden="true" tabindex="-1"></a>ax2.axhline(y<span class="op">=</span>right_graph.defect(), linestyle<span class="op">=</span><span class="st">'dotted'</span>, color<span class="op">=</span><span class="st">'black'</span>)</span>
<span id="cb53-9"><a href="#cb53-9" aria-hidden="true" tabindex="-1"></a>sns.despine()</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><a href="rabbits_full_py_api_example_files/figure-html/cell-37-output-1.png" class="lightbox" data-gallery="quarto-lightbox-gallery-6"><img src="rabbits_full_py_api_example_files/figure-html/cell-37-output-1.png" width="671" height="296" class="figure-img"></a></p>
</figure>
</div>
</div>
</div>
<p>There are also utility methods to get the stop probability i.e.&nbsp;probabilities of occupying each state at time t.</p>
<div id="cell-74" class="cell" data-execution_count="36">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb54"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a>graph.stop_probability(<span class="fl">0.2</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display" data-execution_count="36">
<pre><code>[0.0,
 0.5561531639166896,
 0.07040541534825098,
 0.0,
 0.007095725804629082,
 0.016348108066650276,
 0.03374890558205247]</code></pre>
</div>
</div>
<p>We can use that to compute the expected number of rabbits across time:</p>
<div id="cell-76" class="cell" data-execution_count="37">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb56"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a>times <span class="op">=</span> np.arange(<span class="dv">0</span>, <span class="dv">2</span>, <span class="fl">0.05</span>)</span>
<span id="cb56-2"><a href="#cb56-2" aria-hidden="true" tabindex="-1"></a>expected_rabbits_left <span class="op">=</span> [</span>
<span id="cb56-3"><a href="#cb56-3" aria-hidden="true" tabindex="-1"></a>    np.<span class="bu">sum</span>(graph.stop_probability(i) </span>
<span id="cb56-4"><a href="#cb56-4" aria-hidden="true" tabindex="-1"></a>           <span class="op">*</span> np.<span class="bu">sum</span>(graph.states(), axis<span class="op">=</span><span class="dv">1</span>)) </span>
<span id="cb56-5"><a href="#cb56-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> times</span>
<span id="cb56-6"><a href="#cb56-6" aria-hidden="true" tabindex="-1"></a>    ]</span>
<span id="cb56-7"><a href="#cb56-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb56-8"><a href="#cb56-8" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">1</span>, figsize<span class="op">=</span>(<span class="dv">4</span>, <span class="dv">3</span>))</span>
<span id="cb56-9"><a href="#cb56-9" aria-hidden="true" tabindex="-1"></a>ax.plot(times, expected_rabbits_left)</span>
<span id="cb56-10"><a href="#cb56-10" aria-hidden="true" tabindex="-1"></a>ax.set_xlabel(<span class="st">'time'</span>)</span>
<span id="cb56-11"><a href="#cb56-11" aria-hidden="true" tabindex="-1"></a>ax.set_ylabel(<span class="st">"Expected nr rabbits"</span>)</span>
<span id="cb56-12"><a href="#cb56-12" aria-hidden="true" tabindex="-1"></a>sns.despine()</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><a href="rabbits_full_py_api_example_files/figure-html/cell-39-output-1.png" class="lightbox" data-gallery="quarto-lightbox-gallery-7"><img src="rabbits_full_py_api_example_files/figure-html/cell-39-output-1.png" width="385" height="294" class="figure-img"></a></p>
</figure>
</div>
</div>
</div>
<p>We can also get the accumulated visiting time of a particular state. E.g. the total time before time t=0.5 where there was a rabbit on the right island:</p>
<div id="cell-78" class="cell" data-execution_count="38">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb57"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a>rewards <span class="op">=</span> (graph.states()[:,<span class="dv">1</span>]<span class="op">&gt;</span><span class="dv">0</span>).astype(<span class="bu">int</span>)</span>
<span id="cb57-2"><a href="#cb57-2" aria-hidden="true" tabindex="-1"></a>np.<span class="bu">sum</span>(graph.accumulated_visiting_time(time<span class="op">=</span><span class="fl">0.5</span>) <span class="op">*</span> rewards)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display" data-execution_count="38">
<pre><code>np.float64(0.04053231796047568)</code></pre>
</div>
</div>
<div id="cell-79" class="cell" data-execution_count="39">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb59"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a>graph.expected_residence_time()</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display" data-execution_count="39">
<pre><code>[0.0, 0.5038265306122448, 0.0, 0.0, 0.0, 0.0, 0.0]</code></pre>
</div>
</div>
</section>
</section>
<section id="random-sampling" class="level1">
<h1>Random sampling</h1>
<p>The library includes functions to do random sampling. These are useful to also validate the computations</p>
<div id="cell-82" class="cell" data-execution_count="40">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb61"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a>graph.sample(<span class="dv">5</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display" data-execution_count="40">
<pre><code>[0.10250674063588988,
 0.03780655127514197,
 0.3989222107944617,
 0.32494236374614416,
 0.27525835965026685]</code></pre>
</div>
</div>
<div id="cell-83" class="cell" data-execution_count="41">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb63"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb63-1"><a href="#cb63-1" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(figsize<span class="op">=</span>(<span class="dv">4</span>, <span class="dv">3</span>))</span>
<span id="cb63-2"><a href="#cb63-2" aria-hidden="true" tabindex="-1"></a>samples <span class="op">=</span> graph.sample(<span class="dv">1000000</span>)</span>
<span id="cb63-3"><a href="#cb63-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-4"><a href="#cb63-4" aria-hidden="true" tabindex="-1"></a>ax.hist(samples, bins<span class="op">=</span><span class="dv">50</span>, density<span class="op">=</span><span class="va">True</span>, label<span class="op">=</span><span class="st">'Samples'</span>)</span>
<span id="cb63-5"><a href="#cb63-5" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> np.arange(<span class="dv">0</span>, <span class="dv">2</span>, <span class="fl">0.05</span>)</span>
<span id="cb63-6"><a href="#cb63-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-7"><a href="#cb63-7" aria-hidden="true" tabindex="-1"></a>ax.plot(x, [graph.pdf(t) <span class="cf">for</span> t <span class="kw">in</span> x], label<span class="op">=</span><span class="st">'PDF'</span>)</span>
<span id="cb63-8"><a href="#cb63-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-9"><a href="#cb63-9" aria-hidden="true" tabindex="-1"></a>ax.set_xlim(<span class="dv">0</span>, <span class="dv">2</span>)</span>
<span id="cb63-10"><a href="#cb63-10" aria-hidden="true" tabindex="-1"></a>ax.legend()</span>
<span id="cb63-11"><a href="#cb63-11" aria-hidden="true" tabindex="-1"></a>sns.despine()</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><a href="rabbits_full_py_api_example_files/figure-html/cell-43-output-1.png" class="lightbox" data-gallery="quarto-lightbox-gallery-8"><img src="rabbits_full_py_api_example_files/figure-html/cell-43-output-1.png" width="372" height="274" class="figure-img"></a></p>
</figure>
</div>
</div>
</div>
<p>You can produce the moments from sampling if needed. Compare to the sampled and exact second moments:</p>
<div id="cell-85" class="cell" data-execution_count="42">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb64"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb64-1"><a href="#cb64-1" aria-hidden="true" tabindex="-1"></a>np.<span class="bu">sum</span>(np.array(graph.sample(<span class="dv">1000000</span>))<span class="op">**</span><span class="dv">2</span>)<span class="op">/</span><span class="dv">1000000</span>, graph.moments(<span class="dv">2</span>)[<span class="dv">1</span>]</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display" data-execution_count="42">
<pre><code>(np.float64(0.4806322956991767), 0.48029792274052463)</code></pre>
</div>
</div>
<div id="cell-86" class="cell" data-execution_count="43">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb66"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb66-1"><a href="#cb66-1" aria-hidden="true" tabindex="-1"></a>rewards <span class="op">=</span> graph.states()[:,<span class="dv">1</span>]</span>
<span id="cb66-2"><a href="#cb66-2" aria-hidden="true" tabindex="-1"></a>np.<span class="bu">sum</span>(np.array(graph.sample(<span class="dv">1000000</span>, rewards))<span class="op">**</span><span class="dv">2</span>)<span class="op">/</span><span class="dv">1000000</span>, graph.moments(<span class="dv">2</span>, rewards)[<span class="dv">1</span>]</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display" data-execution_count="43">
<pre><code>(np.float64(0.055537147935424455), 0.05525692419825073)</code></pre>
</div>
</div>
<p>Reward-transforming first and then computing without rewards achieves the same thing:</p>
<div id="cell-88" class="cell" data-execution_count="44">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb68"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb68-1"><a href="#cb68-1" aria-hidden="true" tabindex="-1"></a>revtr_graph <span class="op">=</span> graph.reward_transform(rewards)</span>
<span id="cb68-2"><a href="#cb68-2" aria-hidden="true" tabindex="-1"></a>np.<span class="bu">sum</span>(np.array(revtr_graph.sample(<span class="dv">1000000</span>))<span class="op">**</span><span class="dv">2</span>)<span class="op">/</span><span class="dv">1000000</span>, revtr_graph.moments(<span class="dv">2</span>)[<span class="dv">1</span>]</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stderr">
<pre><code>INFO: building reward compute graph...</code></pre>
</div>
<div class="cell-output cell-output-display" data-execution_count="44">
<pre><code>(np.float64(0.05512565566279011), 0.055256924198250734)</code></pre>
</div>
</div>
<section id="discrete-phase-type-distributions" class="level2">
<h2 class="anchored" data-anchor-id="discrete-phase-type-distributions">Discrete phase-type distributions</h2>
<p>We can also work with discrete phase-type distributions. This is the number of jumps in a Markov Chain before absorption. We will model that any rabbit can find a carrot at each time with rate 0.1 and see how many carrots the rabbits will have found. We could of course just make a new state-space creation function, but we can also manipulate existing.</p>
<div id="cell-91" class="cell" data-execution_count="45">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb71"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb71-1"><a href="#cb71-1" aria-hidden="true" tabindex="-1"></a>carrot_graph <span class="op">=</span> graph.copy()</span>
<span id="cb71-2"><a href="#cb71-2" aria-hidden="true" tabindex="-1"></a>vlength <span class="op">=</span> carrot_graph.vertices_length()</span>
<span id="cb71-3"><a href="#cb71-3" aria-hidden="true" tabindex="-1"></a>carrot_vertices <span class="op">=</span> np.repeat(<span class="va">False</span>, vlength<span class="op">*</span><span class="dv">2</span>)</span>
<span id="cb71-4"><a href="#cb71-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb71-5"><a href="#cb71-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb71-6"><a href="#cb71-6" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(vlength):</span>
<span id="cb71-7"><a href="#cb71-7" aria-hidden="true" tabindex="-1"></a>    vertex <span class="op">=</span> carrot_graph.vertex_at(i)</span>
<span id="cb71-8"><a href="#cb71-8" aria-hidden="true" tabindex="-1"></a>    rabbits <span class="op">=</span> <span class="bu">sum</span>(vertex.state())</span>
<span id="cb71-9"><a href="#cb71-9" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb71-10"><a href="#cb71-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> rabbits <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb71-11"><a href="#cb71-11" aria-hidden="true" tabindex="-1"></a>        obtained_carrot_vertex <span class="op">=</span> carrot_graph.create_vertex([<span class="dv">0</span>])</span>
<span id="cb71-12"><a href="#cb71-12" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Go directly back to the state we came from</span></span>
<span id="cb71-13"><a href="#cb71-13" aria-hidden="true" tabindex="-1"></a>        obtained_carrot_vertex.add_edge(vertex, <span class="dv">1</span>)</span>
<span id="cb71-14"><a href="#cb71-14" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Rate of finding carrot</span></span>
<span id="cb71-15"><a href="#cb71-15" aria-hidden="true" tabindex="-1"></a>        vertex.add_edge(obtained_carrot_vertex, rabbits <span class="op">*</span> <span class="fl">0.1</span>)</span>
<span id="cb71-16"><a href="#cb71-16" aria-hidden="true" tabindex="-1"></a>        carrot_vertices[obtained_carrot_vertex.index()] <span class="op">=</span> <span class="va">True</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<div id="cell-92" class="cell" data-execution_count="46">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb72"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb72-1"><a href="#cb72-1" aria-hidden="true" tabindex="-1"></a>carrot_graph.plot()</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display" data-execution_count="46">
<div>
<figure class="figure">
<p><a href="rabbits_full_py_api_example_files/figure-html/cell-48-output-1.svg" class="lightbox" data-gallery="quarto-lightbox-gallery-9"><img src="rabbits_full_py_api_example_files/figure-html/cell-48-output-1.svg" class="img-fluid figure-img"></a></p>
</figure>
</div>
</div>
</div>
<div id="cell-93" class="cell" data-execution_count="47">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb73"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb73-1"><a href="#cb73-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-2"><a href="#cb73-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-3"><a href="#cb73-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-4"><a href="#cb73-4" aria-hidden="true" tabindex="-1"></a>vlength <span class="op">=</span> carrot_graph.vertices_length()</span>
<span id="cb73-5"><a href="#cb73-5" aria-hidden="true" tabindex="-1"></a>carrot_vertices <span class="op">=</span> np.repeat(<span class="va">False</span>, vlength<span class="op">*</span><span class="dv">2</span>)</span>
<span id="cb73-6"><a href="#cb73-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-7"><a href="#cb73-7" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(vlength):</span>
<span id="cb73-8"><a href="#cb73-8" aria-hidden="true" tabindex="-1"></a>    vertex <span class="op">=</span> carrot_graph.vertex_at(i)</span>
<span id="cb73-9"><a href="#cb73-9" aria-hidden="true" tabindex="-1"></a>    rabbits <span class="op">=</span> <span class="bu">sum</span>(vertex.state())</span>
<span id="cb73-10"><a href="#cb73-10" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb73-11"><a href="#cb73-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> rabbits <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb73-12"><a href="#cb73-12" aria-hidden="true" tabindex="-1"></a>        obtained_carrot_vertex <span class="op">=</span> carrot_graph.create_vertex([<span class="dv">0</span>])</span>
<span id="cb73-13"><a href="#cb73-13" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Go directly back to the state we came from</span></span>
<span id="cb73-14"><a href="#cb73-14" aria-hidden="true" tabindex="-1"></a>        obtained_carrot_vertex.add_edge(vertex, <span class="dv">1</span>)</span>
<span id="cb73-15"><a href="#cb73-15" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Rate of finding carrot</span></span>
<span id="cb73-16"><a href="#cb73-16" aria-hidden="true" tabindex="-1"></a>        vertex.add_edge(obtained_carrot_vertex, rabbits <span class="op">*</span> <span class="fl">0.1</span>)</span>
<span id="cb73-17"><a href="#cb73-17" aria-hidden="true" tabindex="-1"></a>        carrot_vertices[obtained_carrot_vertex.index()] <span class="op">=</span> <span class="va">True</span></span>
<span id="cb73-18"><a href="#cb73-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-19"><a href="#cb73-19" aria-hidden="true" tabindex="-1"></a>carrot_vertices <span class="op">=</span> carrot_vertices[np.arange(carrot_graph.vertices_length())]</span>
<span id="cb73-20"><a href="#cb73-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-21"><a href="#cb73-21" aria-hidden="true" tabindex="-1"></a><span class="co"># We now want to make the graph discrete. We do this by 'normalizing' the edges</span></span>
<span id="cb73-22"><a href="#cb73-22" aria-hidden="true" tabindex="-1"></a><span class="co"># This is imply scaling the vertices such that the total out-going rate is 1</span></span>
<span id="cb73-23"><a href="#cb73-23" aria-hidden="true" tabindex="-1"></a><span class="co"># As it is now the probability of transitions</span></span>
<span id="cb73-24"><a href="#cb73-24" aria-hidden="true" tabindex="-1"></a>weights_were_multiplied_with <span class="op">=</span> carrot_graph.normalize()</span>
<span id="cb73-25"><a href="#cb73-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-26"><a href="#cb73-26" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"This is the discrete state space as a sub-transition matrix:"</span>)</span>
<span id="cb73-27"><a href="#cb73-27" aria-hidden="true" tabindex="-1"></a><span class="co">#carrot_graph.as_matrices()</span></span>
<span id="cb73-28"><a href="#cb73-28" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'GRAPH AS MATRIX MAKES THE KERNEL DIE...'</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>This is the discrete state space as a sub-transition matrix:
GRAPH AS MATRIX MAKES THE KERNEL DIE...</code></pre>
</div>
</div>
<div id="cell-94" class="cell" data-execution_count="48">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb75"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb75-1"><a href="#cb75-1" aria-hidden="true" tabindex="-1"></a><span class="co"># for vertex in carrot_graph.vertices():</span></span>
<span id="cb75-2"><a href="#cb75-2" aria-hidden="true" tabindex="-1"></a><span class="co">#     print(vertex.index(),vertex.state(), vertex.edges())</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<div id="cell-95" class="cell" data-execution_count="49">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb76"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb76-1"><a href="#cb76-1" aria-hidden="true" tabindex="-1"></a><span class="co"># for vertex in carrot_graph.vertices():</span></span>
<span id="cb76-2"><a href="#cb76-2" aria-hidden="true" tabindex="-1"></a><span class="co">#     print(vertex)</span></span>
<span id="cb76-3"><a href="#cb76-3" aria-hidden="true" tabindex="-1"></a><span class="co">#     for edge in vertex.edges():</span></span>
<span id="cb76-4"><a href="#cb76-4" aria-hidden="true" tabindex="-1"></a><span class="co">#         print("  ", edge)</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<div id="cell-96" class="cell" data-execution_count="50">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb77"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb77-1"><a href="#cb77-1" aria-hidden="true" tabindex="-1"></a><span class="co"># carrot_vertices.astype(int)</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p>We now want to find the expected number of eaten carrots. We set the reward such that the carrot vertex has a reward of ‘1’.</p>
<div id="cell-98" class="cell" data-execution_count="51">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb78"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb78-1"><a href="#cb78-1" aria-hidden="true" tabindex="-1"></a>rewards <span class="op">=</span> carrot_vertices.astype(<span class="bu">int</span>)</span>
<span id="cb78-2"><a href="#cb78-2" aria-hidden="true" tabindex="-1"></a>carrot_graph.expectation_discrete(rewards)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stderr">
<pre><code>INFO: building reward compute graph...</code></pre>
</div>
<div class="cell-output cell-output-display" data-execution_count="51">
<pre><code>0.09056122448979592</code></pre>
</div>
</div>
<p>We can verify that the number of carrots correspond to scaling the continuous graph:</p>
<div id="cell-100" class="cell" data-execution_count="52">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb81"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb81-1"><a href="#cb81-1" aria-hidden="true" tabindex="-1"></a>graph.expectation(graph.states().<span class="bu">sum</span>(axis<span class="op">=</span><span class="dv">1</span>)) <span class="op">*</span> <span class="fl">0.1</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display" data-execution_count="52">
<pre><code>0.09056122448979591</code></pre>
</div>
</div>
<p>Of course we cannot do this for other moments:</p>
<div id="cell-102" class="cell" data-execution_count="53">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb83"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb83-1"><a href="#cb83-1" aria-hidden="true" tabindex="-1"></a>carrot_graph.variance_discrete(rewards)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display" data-execution_count="53">
<pre><code>0.09723142700957937</code></pre>
</div>
</div>
<p>Verified by sampling:</p>
<div id="cell-104" class="cell" data-execution_count="54">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb85"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb85-1"><a href="#cb85-1" aria-hidden="true" tabindex="-1"></a>samples <span class="op">=</span> carrot_graph.sample_discrete(<span class="dv">1000000</span>, rewards)</span>
<span id="cb85-2"><a href="#cb85-2" aria-hidden="true" tabindex="-1"></a>samples <span class="op">=</span> np.array(samples)</span>
<span id="cb85-3"><a href="#cb85-3" aria-hidden="true" tabindex="-1"></a>np.<span class="bu">sum</span>(samples<span class="op">**</span><span class="dv">2</span>) <span class="op">/</span> <span class="dv">1000000</span> <span class="op">-</span> ((np.<span class="bu">sum</span>(samples)) <span class="op">/</span> <span class="dv">1000000</span>)<span class="op">**</span><span class="dv">2</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display" data-execution_count="54">
<pre><code>np.float64(0.097111574351)</code></pre>
</div>
</div>
<div id="cell-105" class="cell" data-execution_count="55">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb87"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb87-1"><a href="#cb87-1" aria-hidden="true" tabindex="-1"></a><span class="co"># We can find the distribution function for the the total number of carrots found</span></span>
<span id="cb87-2"><a href="#cb87-2" aria-hidden="true" tabindex="-1"></a>carrots <span class="op">=</span> np.arange(<span class="dv">10</span>)</span>
<span id="cb87-3"><a href="#cb87-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Notice that with this reward transformation the graph is no longer sparse, as all paths through</span></span>
<span id="cb87-4"><a href="#cb87-4" aria-hidden="true" tabindex="-1"></a><span class="co"># the graph are represented!!</span></span>
<span id="cb87-5"><a href="#cb87-5" aria-hidden="true" tabindex="-1"></a>found_carrots_graph  <span class="op">=</span> carrot_graph.reward_transform_discrete(rewards)</span>
<span id="cb87-6"><a href="#cb87-6" aria-hidden="true" tabindex="-1"></a>pmf <span class="op">=</span> found_carrots_graph.pmf_discrete(carrots)</span>
<span id="cb87-7"><a href="#cb87-7" aria-hidden="true" tabindex="-1"></a>cdf <span class="op">=</span> found_carrots_graph.cdf_discrete(carrots)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<div id="cell-106" class="cell" data-execution_count="56">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb88"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb88-1"><a href="#cb88-1" aria-hidden="true" tabindex="-1"></a>fig, (ax1, ax2) <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">2</span>, figsize<span class="op">=</span>(<span class="dv">8</span>, <span class="dv">3</span>), sharey<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb88-2"><a href="#cb88-2" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> np.arange(<span class="dv">0</span>, <span class="dv">10</span>, <span class="dv">1</span>)</span>
<span id="cb88-3"><a href="#cb88-3" aria-hidden="true" tabindex="-1"></a>ax1.bar(x, pmf)</span>
<span id="cb88-4"><a href="#cb88-4" aria-hidden="true" tabindex="-1"></a>ax1.set_title(<span class="st">"PDF"</span>)</span>
<span id="cb88-5"><a href="#cb88-5" aria-hidden="true" tabindex="-1"></a>ax1.set_xlabel(<span class="st">'Total number of carrots found'</span>)</span>
<span id="cb88-6"><a href="#cb88-6" aria-hidden="true" tabindex="-1"></a><span class="co"># ax1.set_ylim(bottom=0)</span></span>
<span id="cb88-7"><a href="#cb88-7" aria-hidden="true" tabindex="-1"></a><span class="co">#ax2.plot(x, cdf)</span></span>
<span id="cb88-8"><a href="#cb88-8" aria-hidden="true" tabindex="-1"></a>left, right <span class="op">=</span> x, np.arange(<span class="dv">1</span>, x.size<span class="op">+</span><span class="dv">1</span>, <span class="dv">1</span>)</span>
<span id="cb88-9"><a href="#cb88-9" aria-hidden="true" tabindex="-1"></a>ax2.hlines(y<span class="op">=</span>cdf, xmin<span class="op">=</span>left, xmax<span class="op">=</span>right, zorder<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb88-10"><a href="#cb88-10" aria-hidden="true" tabindex="-1"></a>ax2.scatter(left, cdf, s<span class="op">=</span><span class="dv">18</span>, zorder<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb88-11"><a href="#cb88-11" aria-hidden="true" tabindex="-1"></a>ax2.set_title(<span class="st">"CDF"</span>)</span>
<span id="cb88-12"><a href="#cb88-12" aria-hidden="true" tabindex="-1"></a><span class="co"># ax2.set_ylim(bottom=0)</span></span>
<span id="cb88-13"><a href="#cb88-13" aria-hidden="true" tabindex="-1"></a>ax2.set_xlabel(<span class="st">'Total number of carrots found'</span>)</span>
<span id="cb88-14"><a href="#cb88-14" aria-hidden="true" tabindex="-1"></a>ax2.axhline(y<span class="op">=</span>right_graph.defect(), linestyle<span class="op">=</span><span class="st">'dotted'</span>)</span>
<span id="cb88-15"><a href="#cb88-15" aria-hidden="true" tabindex="-1"></a>sns.despine()</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><a href="rabbits_full_py_api_example_files/figure-html/cell-58-output-1.png" class="lightbox" data-gallery="quarto-lightbox-gallery-10"><img src="rabbits_full_py_api_example_files/figure-html/cell-58-output-1.png" width="671" height="315" class="figure-img"></a></p>
</figure>
</div>
</div>
</div>
</section>
</section>
<section id="multivariate-phase-type-distributions" class="level1">
<h1>Multivariate phase-type distributions</h1>
<p>Instead of a univariate reward, we can have the distribution earn a <em>vector</em> of rewards for each time unit spent at a vertex. We will continue with the rabbit example. We will now show the relationship between total time spent by any rabbit on either of the two islands.</p>
<div id="cell-109" class="cell" data-execution_count="57">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb89"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb89-1"><a href="#cb89-1" aria-hidden="true" tabindex="-1"></a>states <span class="op">=</span> graph.states()</span>
<span id="cb89-2"><a href="#cb89-2" aria-hidden="true" tabindex="-1"></a>states[:, <span class="dv">1</span>]</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display" data-execution_count="57">
<pre><code>array([0, 0, 1, 0, 2, 1, 0], dtype=int32)</code></pre>
</div>
</div>
<div id="cell-110" class="cell" data-execution_count="58">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb91"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb91-1"><a href="#cb91-1" aria-hidden="true" tabindex="-1"></a>states <span class="op">=</span> graph.states()</span>
<span id="cb91-2"><a href="#cb91-2" aria-hidden="true" tabindex="-1"></a>graph.covariance(states[:,<span class="dv">0</span>], states[:,<span class="dv">1</span>])</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display" data-execution_count="58">
<pre><code>0.030003774468971296</code></pre>
</div>
</div>
<div id="cell-111" class="cell" data-execution_count="59">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb93"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb93-1"><a href="#cb93-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb93-2"><a href="#cb93-2" aria-hidden="true" tabindex="-1"></a>simulations <span class="op">=</span> graph.sample_multivariate(<span class="dv">100000</span>, graph.states())</span>
<span id="cb93-3"><a href="#cb93-3" aria-hidden="true" tabindex="-1"></a>simulated_cov <span class="op">=</span> <span class="bu">sum</span>(simulations[<span class="dv">0</span>,:]<span class="op">*</span>simulations[<span class="dv">1</span>,:])<span class="op">/</span><span class="dv">100000</span> <span class="op">-</span> <span class="op">\</span></span>
<span id="cb93-4"><a href="#cb93-4" aria-hidden="true" tabindex="-1"></a>                    <span class="bu">sum</span>(simulations[<span class="dv">0</span>,:])<span class="op">/</span><span class="dv">100000</span><span class="op">*</span><span class="bu">sum</span>(simulations[<span class="dv">1</span>,:])<span class="op">/</span><span class="dv">100000</span></span>
<span id="cb93-5"><a href="#cb93-5" aria-hidden="true" tabindex="-1"></a>simulated_cov</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display" data-execution_count="59">
<pre><code>np.float64(0.03007018964691248)</code></pre>
</div>
</div>
<p>The api also supports multivariate <em>discrete</em> phase-type distributions. We show the covariance between carrots found on either island.</p>
<div id="cell-113" class="cell" data-execution_count="60">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb95"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb95-1"><a href="#cb95-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb95-2"><a href="#cb95-2" aria-hidden="true" tabindex="-1"></a>mdph_carrot_graph <span class="op">=</span> graph.clone()</span>
<span id="cb95-3"><a href="#cb95-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb95-4"><a href="#cb95-4" aria-hidden="true" tabindex="-1"></a>vlength <span class="op">=</span> mdph_carrot_graph.vertices_length()</span>
<span id="cb95-5"><a href="#cb95-5" aria-hidden="true" tabindex="-1"></a>carrot_vertices_left <span class="op">=</span> np.repeat(<span class="va">False</span>, vlength<span class="op">*</span><span class="dv">2</span>)</span>
<span id="cb95-6"><a href="#cb95-6" aria-hidden="true" tabindex="-1"></a>carrot_vertices_right <span class="op">=</span> np.repeat(<span class="va">False</span>, vlength<span class="op">*</span><span class="dv">2</span>)</span>
<span id="cb95-7"><a href="#cb95-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb95-8"><a href="#cb95-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb95-9"><a href="#cb95-9" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(vlength):</span>
<span id="cb95-10"><a href="#cb95-10" aria-hidden="true" tabindex="-1"></a>    vertex <span class="op">=</span> mdph_carrot_graph.vertex_at(i)</span>
<span id="cb95-11"><a href="#cb95-11" aria-hidden="true" tabindex="-1"></a>    rabbits <span class="op">=</span> vertex.state()</span>
<span id="cb95-12"><a href="#cb95-12" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb95-13"><a href="#cb95-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> rabbits[<span class="dv">0</span>] <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb95-14"><a href="#cb95-14" aria-hidden="true" tabindex="-1"></a>        obtained_carrot_vertex <span class="op">=</span> mdph_carrot_graph.create_vertex([<span class="dv">0</span>])</span>
<span id="cb95-15"><a href="#cb95-15" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Go directly back to the state we came from</span></span>
<span id="cb95-16"><a href="#cb95-16" aria-hidden="true" tabindex="-1"></a>        obtained_carrot_vertex.add_edge(vertex, <span class="dv">1</span>)</span>
<span id="cb95-17"><a href="#cb95-17" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Rate of finding carrot</span></span>
<span id="cb95-18"><a href="#cb95-18" aria-hidden="true" tabindex="-1"></a>        vertex.add_edge(obtained_carrot_vertex, rabbits[<span class="dv">0</span>] <span class="op">*</span> <span class="fl">0.1</span>)</span>
<span id="cb95-19"><a href="#cb95-19" aria-hidden="true" tabindex="-1"></a>        carrot_vertices_left[obtained_carrot_vertex.index()] <span class="op">=</span> <span class="va">True</span></span>
<span id="cb95-20"><a href="#cb95-20" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb95-21"><a href="#cb95-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> rabbits[<span class="dv">1</span>] <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb95-22"><a href="#cb95-22" aria-hidden="true" tabindex="-1"></a>        obtained_carrot_vertex <span class="op">=</span> mdph_carrot_graph.create_vertex([<span class="dv">0</span>])</span>
<span id="cb95-23"><a href="#cb95-23" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Go directly back to the state we came from</span></span>
<span id="cb95-24"><a href="#cb95-24" aria-hidden="true" tabindex="-1"></a>        obtained_carrot_vertex.add_edge(vertex, <span class="dv">1</span>)</span>
<span id="cb95-25"><a href="#cb95-25" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Rate of finding carrot</span></span>
<span id="cb95-26"><a href="#cb95-26" aria-hidden="true" tabindex="-1"></a>        vertex.add_edge(obtained_carrot_vertex, rabbits[<span class="dv">1</span>] <span class="op">*</span> <span class="fl">0.1</span>)</span>
<span id="cb95-27"><a href="#cb95-27" aria-hidden="true" tabindex="-1"></a>        carrot_vertices_right[obtained_carrot_vertex.index()] <span class="op">=</span> <span class="va">True</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p>Covariance:</p>
<div id="cell-115" class="cell" data-execution_count="61">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb96"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb96-1"><a href="#cb96-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb96-2"><a href="#cb96-2" aria-hidden="true" tabindex="-1"></a>carrot_vertices_left <span class="op">=</span> carrot_vertices_left[<span class="dv">0</span>:mdph_carrot_graph.vertices_length()]</span>
<span id="cb96-3"><a href="#cb96-3" aria-hidden="true" tabindex="-1"></a>carrot_vertices_right <span class="op">=</span> carrot_vertices_right[<span class="dv">0</span>:mdph_carrot_graph.vertices_length()]</span>
<span id="cb96-4"><a href="#cb96-4" aria-hidden="true" tabindex="-1"></a>mdph_carrot_graph.normalize()</span>
<span id="cb96-5"><a href="#cb96-5" aria-hidden="true" tabindex="-1"></a>rewards <span class="op">=</span> np.column_stack((carrot_vertices_left, carrot_vertices_right)).astype(<span class="bu">int</span>)</span>
<span id="cb96-6"><a href="#cb96-6" aria-hidden="true" tabindex="-1"></a>mdph_carrot_graph.covariance_discrete(rewards[:,<span class="dv">0</span>], rewards[:,<span class="dv">1</span>])</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stderr">
<pre><code>INFO: building reward compute graph...</code></pre>
</div>
<div class="cell-output cell-output-display" data-execution_count="61">
<pre><code>-0.0005338270512286547</code></pre>
</div>
</div>
<p>Sampled covariance:</p>
<div id="cell-117" class="cell" data-execution_count="62">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb99"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb99-1"><a href="#cb99-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb99-2"><a href="#cb99-2" aria-hidden="true" tabindex="-1"></a>simulations <span class="op">=</span> mdph_carrot_graph.sample_multivariate_discrete(<span class="dv">1000000</span>, rewards)</span>
<span id="cb99-3"><a href="#cb99-3" aria-hidden="true" tabindex="-1"></a>simulated_cov <span class="op">&lt;-</span> np.<span class="bu">sum</span>(simulations[<span class="dv">0</span>,:]<span class="op">*</span>simulations[<span class="dv">1</span>,:])<span class="op">/</span><span class="dv">1000000</span> <span class="op">-</span> <span class="op">\</span></span>
<span id="cb99-4"><a href="#cb99-4" aria-hidden="true" tabindex="-1"></a>                    np.<span class="bu">sum</span>(simulations[<span class="dv">0</span>,:])<span class="op">/</span><span class="dv">1000000</span><span class="op">*</span>np.<span class="bu">sum</span>(simulations[<span class="dv">1</span>,:])<span class="op">/</span><span class="dv">1000000</span></span>
<span id="cb99-5"><a href="#cb99-5" aria-hidden="true" tabindex="-1"></a>simulated_cov</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display" data-execution_count="62">
<pre><code>np.float64(0.03007018964691248)</code></pre>
</div>
</div>
<section id="parameterized-edges" class="level2">
<h2 class="anchored" data-anchor-id="parameterized-edges">Parameterized edges</h2>
<p>We can <em>parameterize</em> the edges to easily update the weights of the edge</p>
<p>We do this by assigning a <em>state</em> to the <em>edge</em>.</p>
<p>We will now also say that the rate of rabbits jumping is proportional to the number of rabbits on the island.</p>
<p>Our state is [rabbits able to jump, left flooding, right flooding]</p>
<div id="cell-120" class="cell" data-execution_count="63">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb101"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb101-1"><a href="#cb101-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-2"><a href="#cb101-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> construct_rabbit_graph_params(nr_rabbits):</span>
<span id="cb101-3"><a href="#cb101-3" aria-hidden="true" tabindex="-1"></a>    <span class="co"># We represent the vector as two integers, the number of rabbits on the left and right island</span></span>
<span id="cb101-4"><a href="#cb101-4" aria-hidden="true" tabindex="-1"></a>    state_vector_length <span class="op">=</span> <span class="dv">2</span></span>
<span id="cb101-5"><a href="#cb101-5" aria-hidden="true" tabindex="-1"></a>    graph <span class="op">=</span> Graph(state_vector_length)</span>
<span id="cb101-6"><a href="#cb101-6" aria-hidden="true" tabindex="-1"></a>    initial_state <span class="op">=</span> [nr_rabbits, <span class="dv">0</span>]</span>
<span id="cb101-7"><a href="#cb101-7" aria-hidden="true" tabindex="-1"></a>    <span class="co"># The initial state is the only starting state, with 100% starting probability</span></span>
<span id="cb101-8"><a href="#cb101-8" aria-hidden="true" tabindex="-1"></a>    graph.starting_vertex().add_edge(</span>
<span id="cb101-9"><a href="#cb101-9" aria-hidden="true" tabindex="-1"></a>      graph.find_or_create_vertex(initial_state),</span>
<span id="cb101-10"><a href="#cb101-10" aria-hidden="true" tabindex="-1"></a>      <span class="dv">1</span></span>
<span id="cb101-11"><a href="#cb101-11" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb101-12"><a href="#cb101-12" aria-hidden="true" tabindex="-1"></a>    index <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb101-13"><a href="#cb101-13" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Iterate over all unvisited vertices</span></span>
<span id="cb101-14"><a href="#cb101-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> index <span class="op">&lt;</span> graph.vertices_length():</span>
<span id="cb101-15"><a href="#cb101-15" aria-hidden="true" tabindex="-1"></a>      vertex <span class="op">=</span> graph.vertex_at(index)</span>
<span id="cb101-16"><a href="#cb101-16" aria-hidden="true" tabindex="-1"></a>      state <span class="op">=</span> vertex.state()</span>
<span id="cb101-17"><a href="#cb101-17" aria-hidden="true" tabindex="-1"></a>      <span class="cf">if</span> state[<span class="dv">0</span>] <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb101-18"><a href="#cb101-18" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Rabbit jump left to right</span></span>
<span id="cb101-19"><a href="#cb101-19" aria-hidden="true" tabindex="-1"></a>        child_state <span class="op">=</span> [state[<span class="dv">0</span>] <span class="op">-</span> <span class="dv">1</span>, state[<span class="dv">1</span>] <span class="op">+</span> <span class="dv">1</span>]</span>
<span id="cb101-20"><a href="#cb101-20" aria-hidden="true" tabindex="-1"></a>        vertex.add_edge_parameterized(</span>
<span id="cb101-21"><a href="#cb101-21" aria-hidden="true" tabindex="-1"></a>          graph.find_or_create_vertex(child_state),</span>
<span id="cb101-22"><a href="#cb101-22" aria-hidden="true" tabindex="-1"></a>          <span class="dv">0</span>,</span>
<span id="cb101-23"><a href="#cb101-23" aria-hidden="true" tabindex="-1"></a>          [state[<span class="dv">0</span>],<span class="dv">0</span>,<span class="dv">0</span>]</span>
<span id="cb101-24"><a href="#cb101-24" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb101-25"><a href="#cb101-25" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Left island flooding</span></span>
<span id="cb101-26"><a href="#cb101-26" aria-hidden="true" tabindex="-1"></a>        child_state <span class="op">=</span> c(<span class="dv">0</span>, state[<span class="dv">1</span>])</span>
<span id="cb101-27"><a href="#cb101-27" aria-hidden="true" tabindex="-1"></a>        vertex.add_edge_parameterized(</span>
<span id="cb101-28"><a href="#cb101-28" aria-hidden="true" tabindex="-1"></a>          graph.find_or_create_vertex(child_state),</span>
<span id="cb101-29"><a href="#cb101-29" aria-hidden="true" tabindex="-1"></a>          <span class="dv">0</span>,</span>
<span id="cb101-30"><a href="#cb101-30" aria-hidden="true" tabindex="-1"></a>          [<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">0</span>]</span>
<span id="cb101-31"><a href="#cb101-31" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb101-32"><a href="#cb101-32" aria-hidden="true" tabindex="-1"></a>      <span class="cf">if</span> state[<span class="dv">1</span>] <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb101-33"><a href="#cb101-33" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Rabbit jump right to left</span></span>
<span id="cb101-34"><a href="#cb101-34" aria-hidden="true" tabindex="-1"></a>        child_state <span class="op">=</span> [state[<span class="dv">0</span>] <span class="op">+</span> <span class="dv">1</span>, state[<span class="dv">1</span>] <span class="op">-</span> <span class="dv">1</span>]</span>
<span id="cb101-35"><a href="#cb101-35" aria-hidden="true" tabindex="-1"></a>        vertex.add_edge_parameterized(</span>
<span id="cb101-36"><a href="#cb101-36" aria-hidden="true" tabindex="-1"></a>          graph.find_or_create_vertex(child_state),</span>
<span id="cb101-37"><a href="#cb101-37" aria-hidden="true" tabindex="-1"></a>          <span class="dv">0</span>, </span>
<span id="cb101-38"><a href="#cb101-38" aria-hidden="true" tabindex="-1"></a>          [state[<span class="dv">1</span>],<span class="dv">0</span>,<span class="dv">0</span>]</span>
<span id="cb101-39"><a href="#cb101-39" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb101-40"><a href="#cb101-40" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Right island flooding with rate of 4</span></span>
<span id="cb101-41"><a href="#cb101-41" aria-hidden="true" tabindex="-1"></a>        child_state <span class="op">=</span> [state[<span class="dv">0</span>], <span class="dv">0</span>]</span>
<span id="cb101-42"><a href="#cb101-42" aria-hidden="true" tabindex="-1"></a>        vertex.add_edge_parameterized(</span>
<span id="cb101-43"><a href="#cb101-43" aria-hidden="true" tabindex="-1"></a>          graph.find_or_create_vertex(child_state),</span>
<span id="cb101-44"><a href="#cb101-44" aria-hidden="true" tabindex="-1"></a>          <span class="dv">0</span>,</span>
<span id="cb101-45"><a href="#cb101-45" aria-hidden="true" tabindex="-1"></a>          [<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">1</span>]</span>
<span id="cb101-46"><a href="#cb101-46" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb101-47"><a href="#cb101-47" aria-hidden="true" tabindex="-1"></a>      index <span class="op">=</span> index <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb101-48"><a href="#cb101-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-49"><a href="#cb101-49" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span>(graph)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p>The parameterized edges have what ever weight is assigned to them, and the state does not by itself mean anything.</p>
<div id="cell-122" class="cell" data-execution_count="64">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb102"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb102-1"><a href="#cb102-1" aria-hidden="true" tabindex="-1"></a>param_graph <span class="op">=</span> construct_rabbit_graph_params(<span class="dv">2</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p>If we let the edge have a state, this gives us an easy way of changing the weights based on some model parameters. In this case, it is the rate of jumping left rate of flooding and right rate of flooding.</p>
<p>The update simply takes the inner product of the state vector and the model parameters, e.g.&nbsp;if the state is x1, x2 and the parameters are p1, p2, then the weight of the edge become x1<em>p1+x2</em>p2</p>
<div id="cell-124" class="cell" data-execution_count="65">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb103"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb103-1"><a href="#cb103-1" aria-hidden="true" tabindex="-1"></a>param_graph.update_parameterized_weights([<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">4</span>])</span>
<span id="cb103-2"><a href="#cb103-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Expectation (1,2,4):"</span>, param_graph.expectation())</span>
<span id="cb103-3"><a href="#cb103-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb103-4"><a href="#cb103-4" aria-hidden="true" tabindex="-1"></a>param_graph.update_parameterized_weights([<span class="dv">2</span>, <span class="dv">2</span>, <span class="dv">4</span>])</span>
<span id="cb103-5"><a href="#cb103-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Expectation (1,2,4):"</span>, param_graph.expectation())</span>
<span id="cb103-6"><a href="#cb103-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb103-7"><a href="#cb103-7" aria-hidden="true" tabindex="-1"></a>param_graph.update_parameterized_weights([<span class="dv">2</span>, <span class="dv">4</span>, <span class="dv">4</span>])</span>
<span id="cb103-8"><a href="#cb103-8" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Expectation (1,2,4):"</span>, param_graph.expectation())</span>
<span id="cb103-9"><a href="#cb103-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb103-10"><a href="#cb103-10" aria-hidden="true" tabindex="-1"></a>param_graph.update_parameterized_weights([<span class="dv">2</span>, <span class="dv">4</span>, <span class="dv">18</span>])</span>
<span id="cb103-11"><a href="#cb103-11" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Expectation (1,2,4):"</span>, param_graph.expectation())</span>
<span id="cb103-12"><a href="#cb103-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb103-13"><a href="#cb103-13" aria-hidden="true" tabindex="-1"></a>param_graph.update_parameterized_weights([<span class="dv">8</span>, <span class="dv">4</span>, <span class="dv">18</span>])</span>
<span id="cb103-14"><a href="#cb103-14" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Expectation (1,2,4):"</span>, param_graph.expectation())</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>Expectation (1,2,4): 0.5083056478405314
Expectation (1,2,4): 0.49565217391304334
Expectation (1,2,4): 0.30000000000000004
Expectation (1,2,4): 0.22709632268736477
Expectation (1,2,4): 0.17719439369563442</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>INFO: building parameterized compute graph...
INFO: building reward compute graph from parameterized compute graph...
INFO: building parameterized compute graph...
INFO: building reward compute graph from parameterized compute graph...
INFO: building parameterized compute graph...
INFO: building reward compute graph from parameterized compute graph...
INFO: building parameterized compute graph...
INFO: building reward compute graph from parameterized compute graph...
INFO: building parameterized compute graph...
INFO: building reward compute graph from parameterized compute graph...</code></pre>
</div>
</div>
<p>Note that the moment graph <em>has</em> to be recalculated after updating weights</p>
<div id="cell-126" class="cell" data-execution_count="66">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb106"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb106-1"><a href="#cb106-1" aria-hidden="true" tabindex="-1"></a>param_graph.update_parameterized_weights([<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">4</span>])</span>
<span id="cb106-2"><a href="#cb106-2" aria-hidden="true" tabindex="-1"></a><span class="co">#param_graph.as_matrices()</span></span>
<span id="cb106-3"><a href="#cb106-3" aria-hidden="true" tabindex="-1"></a>      </span>
<span id="cb106-4"><a href="#cb106-4" aria-hidden="true" tabindex="-1"></a>param_graph.update_parameterized_weights([<span class="dv">8</span>, <span class="dv">4</span>, <span class="dv">18</span>])</span>
<span id="cb106-5"><a href="#cb106-5" aria-hidden="true" tabindex="-1"></a><span class="co">#param_graph.as_matrices()</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
</section>
<section id="symbolic-elimination-for-ultra-fast-parameter-evaluation" class="level2">
<h2 class="anchored" data-anchor-id="symbolic-elimination-for-ultra-fast-parameter-evaluation">Symbolic Elimination for Ultra-Fast Parameter Evaluation</h2>
<p>When working with parameterized models, we often need to evaluate the model for many different parameter values. Perhaps we are exploring parameter space to understand model behavior, or performing Bayesian inference where we need to compute likelihoods or gradients for thousands of parameter vectors. The straightforward approach—updating parameters with <code>update_parameterized_weights()</code> and then computing moments or distribution functions—works correctly but faces a fundamental computational bottleneck. Each time we update parameters and compute properties, we are effectively performing Gaussian elimination on the graph, an operation with O(n³) complexity for a graph with n vertices.</p>
<p>This cubic scaling means that even modest increases in state space size lead to dramatic increases in computation time. For inference problems where we might need to evaluate the model millions of times, this quickly becomes prohibitive. The problem is particularly acute because the structure of the computation graph—the dependencies between vertices, the topology of the graph—remains constant across parameter updates. We are repeatedly performing the same structural computation, just with different numerical values plugged in.</p>
<p>Symbolic elimination offers an elegant solution to this performance bottleneck. The key insight is to separate the expensive structural computation, which depends only on graph topology, from the cheap numerical computation, which depends on parameter values. Instead of computing numbers during Gaussian elimination, we compute <em>symbolic expressions</em>—trees of mathematical operations that describe how to compute the final result given parameter values. This symbolic Gaussian elimination is performed once, with O(n³) complexity, producing a directed acyclic graph (DAG) of symbolic expressions. Once we have this DAG, evaluating it for any specific parameter vector requires only O(n) time—we simply traverse the DAG, evaluating each expression node.</p>
<p>The performance improvement can be dramatic. For inference problems, where we might evaluate the model a million times, symbolic elimination transforms an O(n³ × 10⁶) computation into O(n³ + n × 10⁶). For moderately sized state spaces where n is in the hundreds or thousands, this can mean speedups of 100×, 1000×, or even more. The transformation is particularly powerful when combined with JAX, which can compile the O(n) evaluation into highly optimized machine code and automatically differentiate through it for gradient-based inference.</p>
<p>Let’s see how symbolic elimination works in practice with our rabbit model. We will construct a parameterized model, perform symbolic elimination once to build the expression DAG, and then demonstrate how we can rapidly evaluate it for many different parameter values. We will also measure the performance improvement to quantify the speedup.</p>
<div id="cell-129" class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb107"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb107-1"><a href="#cb107-1" aria-hidden="true" tabindex="-1"></a><span class="co"># First, let's create a parameterized rabbit model with more rabbits to see the performance benefit</span></span>
<span id="cb107-2"><a href="#cb107-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> construct_parameterized_rabbit_model(nr_rabbits):</span>
<span id="cb107-3"><a href="#cb107-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb107-4"><a href="#cb107-4" aria-hidden="true" tabindex="-1"></a><span class="co">    Construct a parameterized rabbit model where edge weights are linear combinations of parameters.</span></span>
<span id="cb107-5"><a href="#cb107-5" aria-hidden="true" tabindex="-1"></a><span class="co">    Parameters: [jump_rate, flood_left_rate, flood_right_rate]</span></span>
<span id="cb107-6"><a href="#cb107-6" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb107-7"><a href="#cb107-7" aria-hidden="true" tabindex="-1"></a>    <span class="im">import</span> ptdalgorithms <span class="im">as</span> ptd</span>
<span id="cb107-8"><a href="#cb107-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-9"><a href="#cb107-9" aria-hidden="true" tabindex="-1"></a>    graph <span class="op">=</span> ptd.Graph(state_length<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb107-10"><a href="#cb107-10" aria-hidden="true" tabindex="-1"></a>    initial_state <span class="op">=</span> [nr_rabbits, <span class="dv">0</span>]</span>
<span id="cb107-11"><a href="#cb107-11" aria-hidden="true" tabindex="-1"></a>    graph.starting_vertex().add_edge(graph.find_or_create_vertex(initial_state), <span class="dv">1</span>)</span>
<span id="cb107-12"><a href="#cb107-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-13"><a href="#cb107-13" aria-hidden="true" tabindex="-1"></a>    index <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb107-14"><a href="#cb107-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> index <span class="op">&lt;</span> graph.vertices_length():</span>
<span id="cb107-15"><a href="#cb107-15" aria-hidden="true" tabindex="-1"></a>        vertex <span class="op">=</span> graph.vertex_at(index)</span>
<span id="cb107-16"><a href="#cb107-16" aria-hidden="true" tabindex="-1"></a>        state <span class="op">=</span> vertex.state()</span>
<span id="cb107-17"><a href="#cb107-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-18"><a href="#cb107-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> state[<span class="dv">0</span>] <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb107-19"><a href="#cb107-19" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Jump left to right - rate proportional to number of rabbits</span></span>
<span id="cb107-20"><a href="#cb107-20" aria-hidden="true" tabindex="-1"></a>            child_state <span class="op">=</span> [state[<span class="dv">0</span>] <span class="op">-</span> <span class="dv">1</span>, state[<span class="dv">1</span>] <span class="op">+</span> <span class="dv">1</span>]</span>
<span id="cb107-21"><a href="#cb107-21" aria-hidden="true" tabindex="-1"></a>            vertex.add_edge_parameterized(</span>
<span id="cb107-22"><a href="#cb107-22" aria-hidden="true" tabindex="-1"></a>                graph.find_or_create_vertex(child_state),</span>
<span id="cb107-23"><a href="#cb107-23" aria-hidden="true" tabindex="-1"></a>                <span class="dv">0</span>,</span>
<span id="cb107-24"><a href="#cb107-24" aria-hidden="true" tabindex="-1"></a>                [state[<span class="dv">0</span>], <span class="dv">0</span>, <span class="dv">0</span>]  <span class="co"># jump_rate * n_rabbits</span></span>
<span id="cb107-25"><a href="#cb107-25" aria-hidden="true" tabindex="-1"></a>            )</span>
<span id="cb107-26"><a href="#cb107-26" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Left island flooding</span></span>
<span id="cb107-27"><a href="#cb107-27" aria-hidden="true" tabindex="-1"></a>            child_state <span class="op">=</span> [<span class="dv">0</span>, state[<span class="dv">1</span>]]</span>
<span id="cb107-28"><a href="#cb107-28" aria-hidden="true" tabindex="-1"></a>            vertex.add_edge_parameterized(</span>
<span id="cb107-29"><a href="#cb107-29" aria-hidden="true" tabindex="-1"></a>                graph.find_or_create_vertex(child_state),</span>
<span id="cb107-30"><a href="#cb107-30" aria-hidden="true" tabindex="-1"></a>                <span class="dv">0</span>,</span>
<span id="cb107-31"><a href="#cb107-31" aria-hidden="true" tabindex="-1"></a>                [<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">0</span>]  <span class="co"># flood_left_rate</span></span>
<span id="cb107-32"><a href="#cb107-32" aria-hidden="true" tabindex="-1"></a>            )</span>
<span id="cb107-33"><a href="#cb107-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-34"><a href="#cb107-34" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> state[<span class="dv">1</span>] <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb107-35"><a href="#cb107-35" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Jump right to left</span></span>
<span id="cb107-36"><a href="#cb107-36" aria-hidden="true" tabindex="-1"></a>            child_state <span class="op">=</span> [state[<span class="dv">0</span>] <span class="op">+</span> <span class="dv">1</span>, state[<span class="dv">1</span>] <span class="op">-</span> <span class="dv">1</span>]</span>
<span id="cb107-37"><a href="#cb107-37" aria-hidden="true" tabindex="-1"></a>            vertex.add_edge_parameterized(</span>
<span id="cb107-38"><a href="#cb107-38" aria-hidden="true" tabindex="-1"></a>                graph.find_or_create_vertex(child_state),</span>
<span id="cb107-39"><a href="#cb107-39" aria-hidden="true" tabindex="-1"></a>                <span class="dv">0</span>,</span>
<span id="cb107-40"><a href="#cb107-40" aria-hidden="true" tabindex="-1"></a>                [state[<span class="dv">1</span>], <span class="dv">0</span>, <span class="dv">0</span>]  <span class="co"># jump_rate * n_rabbits</span></span>
<span id="cb107-41"><a href="#cb107-41" aria-hidden="true" tabindex="-1"></a>            )</span>
<span id="cb107-42"><a href="#cb107-42" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Right island flooding</span></span>
<span id="cb107-43"><a href="#cb107-43" aria-hidden="true" tabindex="-1"></a>            child_state <span class="op">=</span> [state[<span class="dv">0</span>], <span class="dv">0</span>]</span>
<span id="cb107-44"><a href="#cb107-44" aria-hidden="true" tabindex="-1"></a>            vertex.add_edge_parameterized(</span>
<span id="cb107-45"><a href="#cb107-45" aria-hidden="true" tabindex="-1"></a>                graph.find_or_create_vertex(child_state),</span>
<span id="cb107-46"><a href="#cb107-46" aria-hidden="true" tabindex="-1"></a>                <span class="dv">0</span>,</span>
<span id="cb107-47"><a href="#cb107-47" aria-hidden="true" tabindex="-1"></a>                [<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>]  <span class="co"># flood_right_rate</span></span>
<span id="cb107-48"><a href="#cb107-48" aria-hidden="true" tabindex="-1"></a>            )</span>
<span id="cb107-49"><a href="#cb107-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-50"><a href="#cb107-50" aria-hidden="true" tabindex="-1"></a>        index <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb107-51"><a href="#cb107-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-52"><a href="#cb107-52" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> graph</span>
<span id="cb107-53"><a href="#cb107-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-54"><a href="#cb107-54" aria-hidden="true" tabindex="-1"></a><span class="co"># Create a model with 5 rabbits</span></span>
<span id="cb107-55"><a href="#cb107-55" aria-hidden="true" tabindex="-1"></a>symbolic_graph <span class="op">=</span> construct_parameterized_rabbit_model(<span class="dv">5</span>)</span>
<span id="cb107-56"><a href="#cb107-56" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Created parameterized model with </span><span class="sc">{</span>symbolic_graph<span class="sc">.</span>vertices_length()<span class="sc">}</span><span class="ss"> states"</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>Created parameterized model with 67 states</code></pre>
</div>
<div class="cell-output cell-output-error">
<div class="ansi-escaped-output">
<pre><span class="ansi-red-fg ansi-bold">The Kernel crashed while executing code in the current cell or a previous cell. 

</span><span class="ansi-red-fg ansi-bold">Please review the code in the cell(s) to identify a possible cause of the failure. 

</span><span class="ansi-red-fg ansi-bold">Click &lt;a href='https://aka.ms/vscodeJupyterKernelCrash'&gt;here&lt;/a&gt; for more info. 

</span><span class="ansi-red-fg ansi-bold">View Jupyter &lt;a href='command:jupyter.viewOutput'&gt;log&lt;/a&gt; for further details.</span></pre>
</div>
</div>
</div>
<p>Now we perform the key operation: symbolic elimination. This analyzes the graph structure and builds a directed acyclic graph (DAG) of symbolic expressions. The DAG encodes all the dependencies and operations needed to compute moments and distribution functions as a function of the parameter vector. This is the expensive O(n³) operation, but we only do it once.</p>
<div id="cell-131" class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb109"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb109-1"><a href="#cb109-1" aria-hidden="true" tabindex="-1"></a><span class="co"># First set initial parameters (required before elimination)</span></span>
<span id="cb109-2"><a href="#cb109-2" aria-hidden="true" tabindex="-1"></a>initial_params <span class="op">=</span> np.array([<span class="fl">1.0</span>, <span class="fl">2.0</span>, <span class="fl">4.0</span>])  <span class="co"># jump_rate, flood_left, flood_right</span></span>
<span id="cb109-3"><a href="#cb109-3" aria-hidden="true" tabindex="-1"></a>symbolic_graph.update_parameterized_weights(initial_params)</span>
<span id="cb109-4"><a href="#cb109-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb109-5"><a href="#cb109-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Perform symbolic elimination - this is O(n³) but done once</span></span>
<span id="cb109-6"><a href="#cb109-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Performing symbolic Gaussian elimination..."</span>)</span>
<span id="cb109-7"><a href="#cb109-7" aria-hidden="true" tabindex="-1"></a>dag <span class="op">=</span> symbolic_graph.eliminate_to_dag()</span>
<span id="cb109-8"><a href="#cb109-8" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Created symbolic DAG with </span><span class="sc">{</span>dag<span class="sc">.</span>vertices_length<span class="sc">}</span><span class="ss"> expression nodes"</span>)</span>
<span id="cb109-9"><a href="#cb109-9" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"This DAG can now be evaluated in O(n) time for any parameter vector"</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-error">
<div class="ansi-escaped-output">
<pre><span class="ansi-red-fg ansi-bold">The Kernel crashed while executing code in the current cell or a previous cell. 

</span><span class="ansi-red-fg ansi-bold">Please review the code in the cell(s) to identify a possible cause of the failure. 

</span><span class="ansi-red-fg ansi-bold">Click &lt;a href='https://aka.ms/vscodeJupyterKernelCrash'&gt;here&lt;/a&gt; for more info. 

</span><span class="ansi-red-fg ansi-bold">View Jupyter &lt;a href='command:jupyter.viewOutput'&gt;log&lt;/a&gt; for further details.</span></pre>
</div>
</div>
</div>
<p>With the symbolic DAG created, we can now evaluate it rapidly for different parameter values. Each evaluation is O(n) instead of O(n³). Let’s compare the performance of the traditional approach (updating weights and recomputing) versus the symbolic approach (instantiating the DAG).</p>
<div id="cell-133" class="cell" data-execution_count="1">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb110"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb110-1"><a href="#cb110-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> time</span>
<span id="cb110-2"><a href="#cb110-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb110-3"><a href="#cb110-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Generate 1000 random parameter vectors to test</span></span>
<span id="cb110-4"><a href="#cb110-4" aria-hidden="true" tabindex="-1"></a>n_evaluations <span class="op">=</span> <span class="dv">1000</span></span>
<span id="cb110-5"><a href="#cb110-5" aria-hidden="true" tabindex="-1"></a>param_vectors <span class="op">=</span> np.random.uniform(<span class="fl">0.5</span>, <span class="fl">5.0</span>, size<span class="op">=</span>(n_evaluations, <span class="dv">3</span>))</span>
<span id="cb110-6"><a href="#cb110-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb110-7"><a href="#cb110-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Method 1: Traditional approach - update weights each time</span></span>
<span id="cb110-8"><a href="#cb110-8" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Method 1: Traditional update_parameterized_weights approach"</span>)</span>
<span id="cb110-9"><a href="#cb110-9" aria-hidden="true" tabindex="-1"></a>start <span class="op">=</span> time.time()</span>
<span id="cb110-10"><a href="#cb110-10" aria-hidden="true" tabindex="-1"></a>traditional_expectations <span class="op">=</span> []</span>
<span id="cb110-11"><a href="#cb110-11" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> params <span class="kw">in</span> param_vectors[:<span class="dv">100</span>]:  <span class="co"># Just 100 to avoid taking too long</span></span>
<span id="cb110-12"><a href="#cb110-12" aria-hidden="true" tabindex="-1"></a>    symbolic_graph.update_parameterized_weights(params)</span>
<span id="cb110-13"><a href="#cb110-13" aria-hidden="true" tabindex="-1"></a>    traditional_expectations.append(symbolic_graph.expectation())</span>
<span id="cb110-14"><a href="#cb110-14" aria-hidden="true" tabindex="-1"></a>traditional_time <span class="op">=</span> time.time() <span class="op">-</span> start</span>
<span id="cb110-15"><a href="#cb110-15" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"  Time for 100 evaluations: </span><span class="sc">{</span>traditional_time<span class="sc">:.3f}</span><span class="ss"> seconds"</span>)</span>
<span id="cb110-16"><a href="#cb110-16" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"  Time per evaluation: </span><span class="sc">{</span>traditional_time<span class="op">/</span><span class="dv">100</span><span class="op">*</span><span class="dv">1000</span><span class="sc">:.2f}</span><span class="ss"> ms"</span>)</span>
<span id="cb110-17"><a href="#cb110-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb110-18"><a href="#cb110-18" aria-hidden="true" tabindex="-1"></a><span class="co"># Method 2: Symbolic elimination approach - instantiate DAG</span></span>
<span id="cb110-19"><a href="#cb110-19" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">Method 2: Symbolic elimination with DAG instantiation"</span>)</span>
<span id="cb110-20"><a href="#cb110-20" aria-hidden="true" tabindex="-1"></a>start <span class="op">=</span> time.time()</span>
<span id="cb110-21"><a href="#cb110-21" aria-hidden="true" tabindex="-1"></a>symbolic_expectations <span class="op">=</span> []</span>
<span id="cb110-22"><a href="#cb110-22" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> params <span class="kw">in</span> param_vectors:</span>
<span id="cb110-23"><a href="#cb110-23" aria-hidden="true" tabindex="-1"></a>    concrete_dag <span class="op">=</span> dag.instantiate(params)</span>
<span id="cb110-24"><a href="#cb110-24" aria-hidden="true" tabindex="-1"></a>    symbolic_expectations.append(concrete_dag.expectation())</span>
<span id="cb110-25"><a href="#cb110-25" aria-hidden="true" tabindex="-1"></a>symbolic_time <span class="op">=</span> time.time() <span class="op">-</span> start</span>
<span id="cb110-26"><a href="#cb110-26" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"  Time for 1000 evaluations: </span><span class="sc">{</span>symbolic_time<span class="sc">:.3f}</span><span class="ss"> seconds"</span>)</span>
<span id="cb110-27"><a href="#cb110-27" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"  Time per evaluation: </span><span class="sc">{</span>symbolic_time<span class="op">/</span><span class="dv">1000</span><span class="op">*</span><span class="dv">1000</span><span class="sc">:.2f}</span><span class="ss"> ms"</span>)</span>
<span id="cb110-28"><a href="#cb110-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb110-29"><a href="#cb110-29" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss">Speedup: </span><span class="sc">{</span>(traditional_time<span class="op">/</span><span class="dv">100</span>) <span class="op">/</span> (symbolic_time<span class="op">/</span><span class="dv">1000</span>)<span class="sc">:.1f}</span><span class="ss">x faster"</span>)</span>
<span id="cb110-30"><a href="#cb110-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb110-31"><a href="#cb110-31" aria-hidden="true" tabindex="-1"></a><span class="co"># Verify results match</span></span>
<span id="cb110-32"><a href="#cb110-32" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss">Verification: expectations match = </span><span class="sc">{</span>np<span class="sc">.</span>allclose(traditional_expectations, symbolic_expectations[:<span class="dv">100</span>], rtol<span class="op">=</span><span class="fl">1e-10</span>)<span class="sc">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-error">
<div class="ansi-escaped-output">
<pre>  <span class="ansi-cyan-fg">Cell</span><span class="ansi-cyan-fg"> </span><span class="ansi-green-fg">In[1]</span><span class="ansi-green-fg">, line 32</span>
<span class="ansi-red-fg">    </span><span class="ansi-red-fg">print(f"\nVerification: expectations match = {np.allclose(traditional_expectations, symbolic_expectations[:100], rtol=1e-10)}</span>
          ^
<span class="ansi-red-fg">SyntaxError</span><span class="ansi-red-fg">:</span> unterminated f-string literal (detected at line 32)
</pre>
</div>
</div>
</div>
<p>The speedup is substantial even for this modestly-sized model with only ~10 states. For larger models with hundreds or thousands of states, the speedup can easily reach 100× or 1000×. This makes the difference between inference being computationally infeasible and running in reasonable time.</p>
<p>The symbolic elimination approach is particularly powerful when combined with JAX for automatic differentiation and JIT compilation. The JAX integration allows us to convert the symbolic DAG into a JAX function that can be differentiated (for gradient-based inference) and compiled to highly optimized machine code. Let’s see how this works.</p>
<div id="cell-135" class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb111"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb111-1"><a href="#cb111-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Check if JAX is available</span></span>
<span id="cb111-2"><a href="#cb111-2" aria-hidden="true" tabindex="-1"></a><span class="cf">try</span>:</span>
<span id="cb111-3"><a href="#cb111-3" aria-hidden="true" tabindex="-1"></a>    <span class="im">import</span> jax</span>
<span id="cb111-4"><a href="#cb111-4" aria-hidden="true" tabindex="-1"></a>    <span class="im">import</span> jax.numpy <span class="im">as</span> jnp</span>
<span id="cb111-5"><a href="#cb111-5" aria-hidden="true" tabindex="-1"></a>    HAS_JAX <span class="op">=</span> <span class="va">True</span></span>
<span id="cb111-6"><a href="#cb111-6" aria-hidden="true" tabindex="-1"></a><span class="cf">except</span> <span class="pp">ImportError</span>:</span>
<span id="cb111-7"><a href="#cb111-7" aria-hidden="true" tabindex="-1"></a>    HAS_JAX <span class="op">=</span> <span class="va">False</span></span>
<span id="cb111-8"><a href="#cb111-8" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"JAX not available - install with: pip install jax"</span>)</span>
<span id="cb111-9"><a href="#cb111-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb111-10"><a href="#cb111-10" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> HAS_JAX:</span>
<span id="cb111-11"><a href="#cb111-11" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Convert the symbolic DAG to a JAX-compatible function</span></span>
<span id="cb111-12"><a href="#cb111-12" aria-hidden="true" tabindex="-1"></a>    <span class="co"># This creates a pure function that can be JIT compiled and differentiated</span></span>
<span id="cb111-13"><a href="#cb111-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> expectation_fn(theta):</span>
<span id="cb111-14"><a href="#cb111-14" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""Compute expectation given parameter vector theta"""</span></span>
<span id="cb111-15"><a href="#cb111-15" aria-hidden="true" tabindex="-1"></a>        concrete <span class="op">=</span> dag.instantiate(theta)</span>
<span id="cb111-16"><a href="#cb111-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> concrete.expectation()</span>
<span id="cb111-17"><a href="#cb111-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb111-18"><a href="#cb111-18" aria-hidden="true" tabindex="-1"></a>    <span class="co"># JIT compile the function for maximum performance</span></span>
<span id="cb111-19"><a href="#cb111-19" aria-hidden="true" tabindex="-1"></a>    expectation_jit <span class="op">=</span> jax.jit(expectation_fn)</span>
<span id="cb111-20"><a href="#cb111-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb111-21"><a href="#cb111-21" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Create a gradient function for gradient-based optimization/inference</span></span>
<span id="cb111-22"><a href="#cb111-22" aria-hidden="true" tabindex="-1"></a>    grad_expectation <span class="op">=</span> jax.grad(expectation_fn)</span>
<span id="cb111-23"><a href="#cb111-23" aria-hidden="true" tabindex="-1"></a>    grad_expectation_jit <span class="op">=</span> jax.jit(grad_expectation)</span>
<span id="cb111-24"><a href="#cb111-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb111-25"><a href="#cb111-25" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Test the JIT-compiled function</span></span>
<span id="cb111-26"><a href="#cb111-26" aria-hidden="true" tabindex="-1"></a>    test_params <span class="op">=</span> jnp.array([<span class="fl">1.0</span>, <span class="fl">2.0</span>, <span class="fl">4.0</span>])</span>
<span id="cb111-27"><a href="#cb111-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb111-28"><a href="#cb111-28" aria-hidden="true" tabindex="-1"></a>    <span class="co"># First call includes compilation time</span></span>
<span id="cb111-29"><a href="#cb111-29" aria-hidden="true" tabindex="-1"></a>    start <span class="op">=</span> time.time()</span>
<span id="cb111-30"><a href="#cb111-30" aria-hidden="true" tabindex="-1"></a>    result1 <span class="op">=</span> expectation_jit(test_params)</span>
<span id="cb111-31"><a href="#cb111-31" aria-hidden="true" tabindex="-1"></a>    first_time <span class="op">=</span> time.time() <span class="op">-</span> start</span>
<span id="cb111-32"><a href="#cb111-32" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"First JIT call (includes compilation): </span><span class="sc">{</span>first_time<span class="op">*</span><span class="dv">1000</span><span class="sc">:.2f}</span><span class="ss"> ms"</span>)</span>
<span id="cb111-33"><a href="#cb111-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb111-34"><a href="#cb111-34" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Subsequent calls use compiled code</span></span>
<span id="cb111-35"><a href="#cb111-35" aria-hidden="true" tabindex="-1"></a>    start <span class="op">=</span> time.time()</span>
<span id="cb111-36"><a href="#cb111-36" aria-hidden="true" tabindex="-1"></a>    result2 <span class="op">=</span> expectation_jit(test_params)</span>
<span id="cb111-37"><a href="#cb111-37" aria-hidden="true" tabindex="-1"></a>    second_time <span class="op">=</span> time.time() <span class="op">-</span> start</span>
<span id="cb111-38"><a href="#cb111-38" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Second JIT call (compiled): </span><span class="sc">{</span>second_time<span class="op">*</span><span class="dv">1000</span><span class="sc">:.2f}</span><span class="ss"> ms"</span>)</span>
<span id="cb111-39"><a href="#cb111-39" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Expectation: </span><span class="sc">{</span>result2<span class="sc">:.6f}</span><span class="ss">"</span>)</span>
<span id="cb111-40"><a href="#cb111-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb111-41"><a href="#cb111-41" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Compute gradient</span></span>
<span id="cb111-42"><a href="#cb111-42" aria-hidden="true" tabindex="-1"></a>    start <span class="op">=</span> time.time()</span>
<span id="cb111-43"><a href="#cb111-43" aria-hidden="true" tabindex="-1"></a>    gradient <span class="op">=</span> grad_expectation_jit(test_params)</span>
<span id="cb111-44"><a href="#cb111-44" aria-hidden="true" tabindex="-1"></a>    grad_time <span class="op">=</span> time.time() <span class="op">-</span> start</span>
<span id="cb111-45"><a href="#cb111-45" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss">Gradient computation: </span><span class="sc">{</span>grad_time<span class="op">*</span><span class="dv">1000</span><span class="sc">:.2f}</span><span class="ss"> ms"</span>)</span>
<span id="cb111-46"><a href="#cb111-46" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Gradient: </span><span class="sc">{</span>gradient<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb111-47"><a href="#cb111-47" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">These gradients are exact (via automatic differentiation) and can be used"</span>)</span>
<span id="cb111-48"><a href="#cb111-48" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"for gradient-based inference methods like SVGD, HMC, or variational inference"</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p>The combination of symbolic elimination, JAX compilation, and automatic differentiation creates a powerful workflow for parameter inference. The symbolic DAG removes the O(n³) bottleneck, JIT compilation optimizes the resulting O(n) evaluation, and automatic differentiation provides exact gradients without manual derivation or finite differences. This is precisely the workflow we will use in the SVGD section later in this tutorial, where we will estimate rabbit model parameters from observed data.</p>
<p>For now, the key takeaway is that whenever you have a parameterized model that you need to evaluate many times—whether for parameter exploration, sensitivity analysis, or Bayesian inference—symbolic elimination should be your default choice. The performance improvement is dramatic, and the integration with JAX opens the door to gradient-based methods and GPU acceleration.</p>
</section>
<section id="caching-symbolic-dags-across-sessions" class="level2">
<h2 class="anchored" data-anchor-id="caching-symbolic-dags-across-sessions">Caching Symbolic DAGs Across Sessions</h2>
<p>The symbolic elimination we just performed is a one-time computational investment that pays dividends every time we evaluate the model with different parameters. However, there’s still a hidden cost: every time we restart our Python session or run our analysis script again, we must rebuild the symbolic DAG from scratch. For complex models with hundreds or thousands of states, even this one-time symbolic elimination can take seconds or minutes—creating friction in iterative workflows where we’re refining analyses, debugging code, or exploring different inference configurations.</p>
<p>The PtDAlgorithms library solves this with automatic caching of symbolic DAGs. When you call <code>pmf_from_graph()</code> or <code>eliminate_to_dag()</code>, the library computes a cryptographic hash of your graph’s structure (using SHA-256 combined with Weisfeiler-Lehman graph hashing) and checks whether a symbolic DAG with this hash already exists in the cache. If it does, the cached DAG is loaded instantly. If not, symbolic elimination proceeds normally and the result is cached for future use. This caching is completely transparent—you don’t need to change your code, and it works automatically across all Python sessions.</p>
<p>The cache is <strong>content-addressed</strong>, meaning the hash depends only on the graph’s topology and parameterization pattern, not on specific parameter values. This means that graphs with the same structure but different edge weights (arising from different parameters) share the same symbolic DAG, as they should. The cache is stored persistently in <code>~/.ptdalgorithms_cache/symbolic/</code> and can be shared among collaborators by exporting and importing cache directories.</p>
<div id="cell-138" class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb112"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb112-1"><a href="#cb112-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> ptdalgorithms <span class="im">import</span> SymbolicCache, print_cache_info</span>
<span id="cb112-2"><a href="#cb112-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb112-3"><a href="#cb112-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Let's see the caching system in action</span></span>
<span id="cb112-4"><a href="#cb112-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Demonstrating Symbolic DAG Caching</span><span class="ch">\n</span><span class="st">"</span> <span class="op">+</span> <span class="st">"="</span><span class="op">*</span><span class="dv">70</span> <span class="op">+</span> <span class="st">"</span><span class="ch">\n</span><span class="st">"</span>)</span>
<span id="cb112-5"><a href="#cb112-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb112-6"><a href="#cb112-6" aria-hidden="true" tabindex="-1"></a><span class="co"># Initialize cache</span></span>
<span id="cb112-7"><a href="#cb112-7" aria-hidden="true" tabindex="-1"></a>cache <span class="op">=</span> SymbolicCache()</span>
<span id="cb112-8"><a href="#cb112-8" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Cache location: </span><span class="sc">{</span>cache<span class="sc">.</span>cache_dir<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb112-9"><a href="#cb112-9" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Storage: SQLite index + JSON files for each symbolic DAG</span><span class="ch">\n</span><span class="ss">"</span>)</span>
<span id="cb112-10"><a href="#cb112-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb112-11"><a href="#cb112-11" aria-hidden="true" tabindex="-1"></a><span class="co"># Show current cache statistics</span></span>
<span id="cb112-12"><a href="#cb112-12" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Current Cache Statistics:"</span>)</span>
<span id="cb112-13"><a href="#cb112-13" aria-hidden="true" tabindex="-1"></a>print_cache_info()</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p>Now let’s see caching in action by creating models and observing cache hits and misses. When we create a model for the first time, the cache will miss (no entry exists) and symbolic elimination will run normally. When we create the same model again—even with different initial parameter values—the cache will hit and return the pre-computed symbolic DAG instantly.</p>
<div id="cell-140" class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb113"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb113-1"><a href="#cb113-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> time</span>
<span id="cb113-2"><a href="#cb113-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb113-3"><a href="#cb113-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Create a larger rabbit model to see timing differences more clearly</span></span>
<span id="cb113-4"><a href="#cb113-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> larger_rabbit_callback(state, max_rabbits<span class="op">=</span><span class="dv">5</span>):</span>
<span id="cb113-5"><a href="#cb113-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">len</span>(state) <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb113-6"><a href="#cb113-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> [([<span class="dv">5</span>, <span class="dv">5</span>], <span class="fl">1.0</span>, [<span class="fl">1.0</span>, <span class="fl">0.0</span>, <span class="fl">0.0</span>])]</span>
<span id="cb113-7"><a href="#cb113-7" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb113-8"><a href="#cb113-8" aria-hidden="true" tabindex="-1"></a>    n1, n2 <span class="op">=</span> state[<span class="dv">0</span>], state[<span class="dv">1</span>]</span>
<span id="cb113-9"><a href="#cb113-9" aria-hidden="true" tabindex="-1"></a>    transitions <span class="op">=</span> []</span>
<span id="cb113-10"><a href="#cb113-10" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb113-11"><a href="#cb113-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n1 <span class="op">+</span> n2 <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb113-12"><a href="#cb113-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> []  <span class="co"># Absorbing state</span></span>
<span id="cb113-13"><a href="#cb113-13" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb113-14"><a href="#cb113-14" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Births (parameter 0)</span></span>
<span id="cb113-15"><a href="#cb113-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n1 <span class="op">&gt;</span> <span class="dv">0</span> <span class="kw">and</span> n1 <span class="op">+</span> n2 <span class="op">&lt;</span> max_rabbits:</span>
<span id="cb113-16"><a href="#cb113-16" aria-hidden="true" tabindex="-1"></a>        transitions.append(([n1 <span class="op">+</span> <span class="dv">1</span>, n2], <span class="fl">0.0</span>, [n1 <span class="op">*</span> <span class="fl">0.5</span>, <span class="fl">0.0</span>, <span class="fl">0.0</span>]))</span>
<span id="cb113-17"><a href="#cb113-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n2 <span class="op">&gt;</span> <span class="dv">0</span> <span class="kw">and</span> n1 <span class="op">+</span> n2 <span class="op">&lt;</span> max_rabbits:</span>
<span id="cb113-18"><a href="#cb113-18" aria-hidden="true" tabindex="-1"></a>        transitions.append(([n1, n2 <span class="op">+</span> <span class="dv">1</span>], <span class="fl">0.0</span>, [n2 <span class="op">*</span> <span class="fl">0.5</span>, <span class="fl">0.0</span>, <span class="fl">0.0</span>]))</span>
<span id="cb113-19"><a href="#cb113-19" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb113-20"><a href="#cb113-20" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Deaths (parameter 1)</span></span>
<span id="cb113-21"><a href="#cb113-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n1 <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb113-22"><a href="#cb113-22" aria-hidden="true" tabindex="-1"></a>        transitions.append(([n1 <span class="op">-</span> <span class="dv">1</span>, n2], <span class="fl">0.0</span>, [<span class="fl">0.0</span>, n1 <span class="op">*</span> <span class="fl">0.3</span>, <span class="fl">0.0</span>]))</span>
<span id="cb113-23"><a href="#cb113-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n2 <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb113-24"><a href="#cb113-24" aria-hidden="true" tabindex="-1"></a>        transitions.append(([n1, n2 <span class="op">-</span> <span class="dv">1</span>], <span class="fl">0.0</span>, [<span class="fl">0.0</span>, n2 <span class="op">*</span> <span class="fl">0.3</span>, <span class="fl">0.0</span>]))</span>
<span id="cb113-25"><a href="#cb113-25" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb113-26"><a href="#cb113-26" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Migration (parameter 2)</span></span>
<span id="cb113-27"><a href="#cb113-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n1 <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb113-28"><a href="#cb113-28" aria-hidden="true" tabindex="-1"></a>        transitions.append(([n1 <span class="op">-</span> <span class="dv">1</span>, n2 <span class="op">+</span> <span class="dv">1</span>], <span class="fl">0.0</span>, [<span class="fl">0.0</span>, <span class="fl">0.0</span>, n1 <span class="op">*</span> <span class="fl">0.2</span>]))</span>
<span id="cb113-29"><a href="#cb113-29" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n2 <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb113-30"><a href="#cb113-30" aria-hidden="true" tabindex="-1"></a>        transitions.append(([n1 <span class="op">+</span> <span class="dv">1</span>, n2 <span class="op">-</span> <span class="dv">1</span>], <span class="fl">0.0</span>, [<span class="fl">0.0</span>, <span class="fl">0.0</span>, n2 <span class="op">*</span> <span class="fl">0.2</span>]))</span>
<span id="cb113-31"><a href="#cb113-31" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb113-32"><a href="#cb113-32" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> transitions</span>
<span id="cb113-33"><a href="#cb113-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb113-34"><a href="#cb113-34" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"First construction (cache miss expected)..."</span>)</span>
<span id="cb113-35"><a href="#cb113-35" aria-hidden="true" tabindex="-1"></a>start <span class="op">=</span> time.time()</span>
<span id="cb113-36"><a href="#cb113-36" aria-hidden="true" tabindex="-1"></a>graph1 <span class="op">=</span> Graph(callback<span class="op">=</span>larger_rabbit_callback, parameterized<span class="op">=</span><span class="va">True</span>, max_rabbits<span class="op">=</span><span class="dv">5</span>)</span>
<span id="cb113-37"><a href="#cb113-37" aria-hidden="true" tabindex="-1"></a>model1 <span class="op">=</span> Graph.pmf_from_graph(graph1, use_cache<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb113-38"><a href="#cb113-38" aria-hidden="true" tabindex="-1"></a>time1 <span class="op">=</span> time.time() <span class="op">-</span> start</span>
<span id="cb113-39"><a href="#cb113-39" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"✓ Completed in </span><span class="sc">{</span>time1<span class="sc">:.4f}</span><span class="ss">s (includes symbolic elimination + caching)</span><span class="ch">\n</span><span class="ss">"</span>)</span>
<span id="cb113-40"><a href="#cb113-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb113-41"><a href="#cb113-41" aria-hidden="true" tabindex="-1"></a><span class="co"># Simulate a new Python session: create the same model with different initial parameters</span></span>
<span id="cb113-42"><a href="#cb113-42" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Second construction with same structure (cache hit expected)..."</span>)</span>
<span id="cb113-43"><a href="#cb113-43" aria-hidden="true" tabindex="-1"></a>start <span class="op">=</span> time.time()</span>
<span id="cb113-44"><a href="#cb113-44" aria-hidden="true" tabindex="-1"></a>graph2 <span class="op">=</span> Graph(callback<span class="op">=</span>larger_rabbit_callback, parameterized<span class="op">=</span><span class="va">True</span>, max_rabbits<span class="op">=</span><span class="dv">5</span>)</span>
<span id="cb113-45"><a href="#cb113-45" aria-hidden="true" tabindex="-1"></a>model2 <span class="op">=</span> Graph.pmf_from_graph(graph2, use_cache<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb113-46"><a href="#cb113-46" aria-hidden="true" tabindex="-1"></a>time2 <span class="op">=</span> time.time() <span class="op">-</span> start</span>
<span id="cb113-47"><a href="#cb113-47" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"✓ Completed in </span><span class="sc">{</span>time2<span class="sc">:.4f}</span><span class="ss">s (loaded from cache!)</span><span class="ch">\n</span><span class="ss">"</span>)</span>
<span id="cb113-48"><a href="#cb113-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb113-49"><a href="#cb113-49" aria-hidden="true" tabindex="-1"></a>speedup <span class="op">=</span> time1 <span class="op">/</span> time2 <span class="cf">if</span> time2 <span class="op">&gt;</span> <span class="dv">0</span> <span class="cf">else</span> <span class="dv">0</span></span>
<span id="cb113-50"><a href="#cb113-50" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"🚀 Speedup from caching: </span><span class="sc">{</span>speedup<span class="sc">:.1f}</span><span class="ss">×"</span>)</span>
<span id="cb113-51"><a href="#cb113-51" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss">Key Insight:"</span>)</span>
<span id="cb113-52"><a href="#cb113-52" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"  • Graph topology and parameterization are identical"</span>)</span>
<span id="cb113-53"><a href="#cb113-53" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"  • Symbolic DAG is the same regardless of parameter values"</span>)</span>
<span id="cb113-54"><a href="#cb113-54" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"  • Cache recognizes this and avoids redundant computation"</span>)</span>
<span id="cb113-55"><a href="#cb113-55" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"  • This speedup applies across all Python sessions!"</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<section id="cache-management-and-collaboration" class="level3">
<h3 class="anchored" data-anchor-id="cache-management-and-collaboration">Cache Management and Collaboration</h3>
<p>The cache is designed to be low-maintenance, but several tools are available for power users:</p>
<p><strong>Inspecting the cache:</strong> Use <code>cache.info()</code> to see summary statistics, or <code>cache.list_entries(limit=N)</code> to see individual entries with their hashes, timestamps, and sizes.</p>
<p><strong>Sharing with collaborators:</strong> Export your cache with <code>cache.export_library(output_dir)</code> to create a shareable directory containing symbolic DAGs. Collaborators can then run <code>cache.import_library(exported_dir)</code> to add these pre-computed models to their cache. This is especially useful for complex models that take minutes to eliminate—once one person computes it, everyone else gets instant loading.</p>
<p><strong>CLI tool:</strong> The <code>ptd-cache</code> command-line tool provides convenient cache management:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb114"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb114-1"><a href="#cb114-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Show cache statistics</span></span>
<span id="cb114-2"><a href="#cb114-2" aria-hidden="true" tabindex="-1"></a><span class="ex">ptd-cache</span> info <span class="at">--symbolic</span></span>
<span id="cb114-3"><a href="#cb114-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-4"><a href="#cb114-4" aria-hidden="true" tabindex="-1"></a><span class="co"># List cached models</span></span>
<span id="cb114-5"><a href="#cb114-5" aria-hidden="true" tabindex="-1"></a><span class="ex">ptd-cache</span> list <span class="at">--symbolic</span> <span class="at">--limit</span> 10</span>
<span id="cb114-6"><a href="#cb114-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-7"><a href="#cb114-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Export cache for sharing</span></span>
<span id="cb114-8"><a href="#cb114-8" aria-hidden="true" tabindex="-1"></a><span class="ex">ptd-cache</span> export my_models.tar.gz <span class="at">--symbolic</span></span>
<span id="cb114-9"><a href="#cb114-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-10"><a href="#cb114-10" aria-hidden="true" tabindex="-1"></a><span class="co"># Import someone else's cache</span></span>
<span id="cb114-11"><a href="#cb114-11" aria-hidden="true" tabindex="-1"></a><span class="ex">ptd-cache</span> import downloaded_models.tar.gz <span class="at">--symbolic</span></span>
<span id="cb114-12"><a href="#cb114-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-13"><a href="#cb114-13" aria-hidden="true" tabindex="-1"></a><span class="co"># Clean up old entries</span></span>
<span id="cb114-14"><a href="#cb114-14" aria-hidden="true" tabindex="-1"></a><span class="ex">ptd-cache</span> vacuum <span class="at">--max-age-days</span> 30</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p><strong>Distributed computing:</strong> In HPC environments with shared filesystems, you can configure multiple compute nodes to share a cache by pointing the cache directory to network storage. The cache uses file locking to safely handle concurrent access, allowing distributed jobs to share symbolic DAGs without redundant computation. See the <a href="../../pages/distributed/distributed_computing_complete_guide.html">distributed computing guide</a> for details.</p>
<p><strong>Disabling caching:</strong> If needed, you can disable automatic caching with <code>use_cache=False</code>:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb115"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb115-1"><a href="#cb115-1" aria-hidden="true" tabindex="-1"></a>model <span class="op">=</span> Graph.pmf_from_graph(graph, use_cache<span class="op">=</span><span class="va">False</span>)  <span class="co"># Always recompute</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>This is rarely necessary but can be useful for testing or when you suspect cache corruption.</p>
</section>
<section id="combined-performance-symbolic-elimination-caching-jax" class="level3">
<h3 class="anchored" data-anchor-id="combined-performance-symbolic-elimination-caching-jax">Combined Performance: Symbolic Elimination + Caching + JAX</h3>
<p>Understanding the complete performance story requires seeing how symbolic elimination, caching, and JAX compilation work together:</p>
<ol type="1">
<li><p><strong>Symbolic Elimination</strong> (within-session speedup): Perform O(n³) graph elimination once, then evaluate in O(n) for each parameter vector. For m parameter evaluations, this gives ~m× speedup.</p></li>
<li><p><strong>Caching</strong> (cross-session speedup): Store symbolic DAGs to disk and retrieve them instantly in future sessions. For models that take seconds to eliminate, this provides 10-1000× speedup on subsequent runs. The speedup compounds with development iterations—the more times you run your analysis, the more time caching saves.</p></li>
<li><p><strong>JAX Compilation</strong>: Once you have a symbolic DAG, JAX can compile the evaluation function to optimized XLA code, providing another 10-100× speedup. JAX’s compilation cache persists across sessions (stored in <code>~/.cache/jax/</code>), so this speedup is also maintained.</p></li>
</ol>
<p><strong>Real-world example:</strong> Developing a Bayesian inference pipeline for a population genetics model:</p>
<ul>
<li><p><strong>Traditional approach (no optimization)</strong>: 8 hours per SVGD run, must wait 8 hours each time you adjust parameters or fix bugs. Total development time: 40+ hours over 5 iterations.</p></li>
<li><p><strong>With symbolic elimination only</strong>: First run takes 10s (elimination) + 30s (SVGD), subsequent runs each take 10s + 30s = 40s. Total: 3.5 minutes over 5 iterations. <strong>~680× faster than traditional.</strong></p></li>
<li><p><strong>With symbolic elimination + caching</strong>: First run takes 10s + 30s, subsequent runs take 0.1s (cache retrieval) + 30s = 30.1s. Total: 2.5 minutes over 5 iterations. <strong>~960× faster than traditional.</strong></p></li>
<li><p><strong>With symbolic elimination + caching + JAX</strong>: First run takes 10s + 3s (compile) + 3s (SVGD), subsequent runs take 0.1s + 3s = 3.1s. Total: 28 seconds over 5 iterations. <strong>~5,000× faster than traditional.</strong></p></li>
</ul>
<p>The transformation from a 40-hour development cycle to a 30-second development cycle fundamentally changes how we can work with these models. What was once a batch process requiring overnight runs becomes an interactive exploration where we can rapidly iterate and experiment.</p>
</section>
</section>
<section id="time-inhomogeneity" class="level2">
<h2 class="anchored" data-anchor-id="time-inhomogeneity">Time inhomogeneity</h2>
<p>If the weights change over time - or new edges are added!</p>
<p>Then the distribution is time inhomogeneous. The api also supports such distributions, but in limited manner.</p>
<p>Like the pph, dph, etc. functions, it is a (very good) approximation based on very small steps. If the rates change dramatically, set the granularity as an argument to the functions!! E.g. set it to a high enough value.</p>
<p>If we pick a time far into the future, we can integrate under the pdf to find the expectation!</p>
<p>Integrating over accumulated visiting time:</p>
<div id="cell-146" class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb116"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb116-1"><a href="#cb116-1" aria-hidden="true" tabindex="-1"></a><span class="bu">sum</span>(graph.accumulated_visiting_time(<span class="dv">10</span>))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display" data-execution_count="64">
<pre><code>0.5038265306014538</code></pre>
</div>
</div>
<p>The first moment (expectation):</p>
<div id="cell-148" class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb118"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb118-1"><a href="#cb118-1" aria-hidden="true" tabindex="-1"></a>graph.expectation()</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display" data-execution_count="65">
<pre><code>0.5038265306122448</code></pre>
</div>
</div>
<p>Say at a certain point in time, the flooding starts!</p>
<p>In the beginning, there is <em>no</em> flooding</p>
<div id="cell-150" class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb120"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb120-1"><a href="#cb120-1" aria-hidden="true" tabindex="-1"></a>param_graph.update_parameterized_weights([<span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>])</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p>We can build a context to step over the distribution. Weights can be freely changed and edges added in such a context</p>
<div id="cell-152" class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb121"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb121-1"><a href="#cb121-1" aria-hidden="true" tabindex="-1"></a><span class="co"># import ptdalgorithms as ptd</span></span>
<span id="cb121-2"><a href="#cb121-2" aria-hidden="true" tabindex="-1"></a><span class="co"># import numpy as np</span></span>
<span id="cb121-3"><a href="#cb121-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb121-4"><a href="#cb121-4" aria-hidden="true" tabindex="-1"></a><span class="co"># def c(*args):</span></span>
<span id="cb121-5"><a href="#cb121-5" aria-hidden="true" tabindex="-1"></a><span class="co">#     elem = []</span></span>
<span id="cb121-6"><a href="#cb121-6" aria-hidden="true" tabindex="-1"></a><span class="co">#     for arg in args:</span></span>
<span id="cb121-7"><a href="#cb121-7" aria-hidden="true" tabindex="-1"></a><span class="co">#         if hasattr(arg, '__len__') and len(arg) &gt; 1:</span></span>
<span id="cb121-8"><a href="#cb121-8" aria-hidden="true" tabindex="-1"></a><span class="co">#             elem.extend(arg)</span></span>
<span id="cb121-9"><a href="#cb121-9" aria-hidden="true" tabindex="-1"></a><span class="co">#         else:</span></span>
<span id="cb121-10"><a href="#cb121-10" aria-hidden="true" tabindex="-1"></a><span class="co">#             elem.append(arg)</span></span>
<span id="cb121-11"><a href="#cb121-11" aria-hidden="true" tabindex="-1"></a><span class="co">#     return np.array(elem)</span></span>
<span id="cb121-12"><a href="#cb121-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb121-13"><a href="#cb121-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb121-14"><a href="#cb121-14" aria-hidden="true" tabindex="-1"></a><span class="co"># nr_rabbits, flood_left, flood_right = 2, 2, 4</span></span>
<span id="cb121-15"><a href="#cb121-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb121-16"><a href="#cb121-16" aria-hidden="true" tabindex="-1"></a><span class="co"># # we represent the vector as two integers, the number of </span></span>
<span id="cb121-17"><a href="#cb121-17" aria-hidden="true" tabindex="-1"></a><span class="co"># # rabbits on the left and right island</span></span>
<span id="cb121-18"><a href="#cb121-18" aria-hidden="true" tabindex="-1"></a><span class="co"># state_vector_length = 2</span></span>
<span id="cb121-19"><a href="#cb121-19" aria-hidden="true" tabindex="-1"></a><span class="co"># graph = ptd.Graph(state_vector_length)</span></span>
<span id="cb121-20"><a href="#cb121-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb121-21"><a href="#cb121-21" aria-hidden="true" tabindex="-1"></a><span class="co"># # the initial state is the only starting state, with probability 1</span></span>
<span id="cb121-22"><a href="#cb121-22" aria-hidden="true" tabindex="-1"></a><span class="co"># initial_state = c(nr_rabbits, 0)</span></span>
<span id="cb121-23"><a href="#cb121-23" aria-hidden="true" tabindex="-1"></a><span class="co"># vertex = graph.find_or_create_vertex(initial_state)</span></span>
<span id="cb121-24"><a href="#cb121-24" aria-hidden="true" tabindex="-1"></a><span class="co"># graph.starting_vertex().add_edge(vertex, 1)</span></span>
<span id="cb121-25"><a href="#cb121-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb121-26"><a href="#cb121-26" aria-hidden="true" tabindex="-1"></a><span class="co"># index = 1</span></span>
<span id="cb121-27"><a href="#cb121-27" aria-hidden="true" tabindex="-1"></a><span class="co"># # iterate over all unvisited vertices</span></span>
<span id="cb121-28"><a href="#cb121-28" aria-hidden="true" tabindex="-1"></a><span class="co"># while index &lt; graph.vertices_length():</span></span>
<span id="cb121-29"><a href="#cb121-29" aria-hidden="true" tabindex="-1"></a><span class="co">#     vertex = graph.vertex_at(index)</span></span>
<span id="cb121-30"><a href="#cb121-30" aria-hidden="true" tabindex="-1"></a><span class="co">#     state = vertex.state()</span></span>
<span id="cb121-31"><a href="#cb121-31" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb121-32"><a href="#cb121-32" aria-hidden="true" tabindex="-1"></a><span class="co">#     if state[0] &gt; 0:</span></span>
<span id="cb121-33"><a href="#cb121-33" aria-hidden="true" tabindex="-1"></a><span class="co">#         # rabbit jump left to right</span></span>
<span id="cb121-34"><a href="#cb121-34" aria-hidden="true" tabindex="-1"></a><span class="co">#         child_state = c(state[0] - 1, state[1] + 1)</span></span>
<span id="cb121-35"><a href="#cb121-35" aria-hidden="true" tabindex="-1"></a><span class="co">#         vertex.add_edge(</span></span>
<span id="cb121-36"><a href="#cb121-36" aria-hidden="true" tabindex="-1"></a><span class="co">#             graph.find_or_create_vertex(child_state),</span></span>
<span id="cb121-37"><a href="#cb121-37" aria-hidden="true" tabindex="-1"></a><span class="co">#             weight=1</span></span>
<span id="cb121-38"><a href="#cb121-38" aria-hidden="true" tabindex="-1"></a><span class="co">#         )</span></span>
<span id="cb121-39"><a href="#cb121-39" aria-hidden="true" tabindex="-1"></a><span class="co">#         # left island flooding</span></span>
<span id="cb121-40"><a href="#cb121-40" aria-hidden="true" tabindex="-1"></a><span class="co">#         child_state = c(0, state[1])</span></span>
<span id="cb121-41"><a href="#cb121-41" aria-hidden="true" tabindex="-1"></a><span class="co">#         vertex.add_edge(</span></span>
<span id="cb121-42"><a href="#cb121-42" aria-hidden="true" tabindex="-1"></a><span class="co">#             graph.find_or_create_vertex(child_state), </span></span>
<span id="cb121-43"><a href="#cb121-43" aria-hidden="true" tabindex="-1"></a><span class="co">#             weight=flood_left</span></span>
<span id="cb121-44"><a href="#cb121-44" aria-hidden="true" tabindex="-1"></a><span class="co">#         )</span></span>
<span id="cb121-45"><a href="#cb121-45" aria-hidden="true" tabindex="-1"></a><span class="co">#     if state[1] &gt; 0:   </span></span>
<span id="cb121-46"><a href="#cb121-46" aria-hidden="true" tabindex="-1"></a><span class="co">#         child_state = c(state[0] + 1, state[1] - 1)</span></span>
<span id="cb121-47"><a href="#cb121-47" aria-hidden="true" tabindex="-1"></a><span class="co">#         vertex.add_edge(</span></span>
<span id="cb121-48"><a href="#cb121-48" aria-hidden="true" tabindex="-1"></a><span class="co">#             graph.find_or_create_vertex(child_state),</span></span>
<span id="cb121-49"><a href="#cb121-49" aria-hidden="true" tabindex="-1"></a><span class="co">#             weight=1</span></span>
<span id="cb121-50"><a href="#cb121-50" aria-hidden="true" tabindex="-1"></a><span class="co">#         )</span></span>
<span id="cb121-51"><a href="#cb121-51" aria-hidden="true" tabindex="-1"></a><span class="co">#         # right island flooding</span></span>
<span id="cb121-52"><a href="#cb121-52" aria-hidden="true" tabindex="-1"></a><span class="co">#         child_state = c(state[0], 0)</span></span>
<span id="cb121-53"><a href="#cb121-53" aria-hidden="true" tabindex="-1"></a><span class="co">#         vertex.add_edge(</span></span>
<span id="cb121-54"><a href="#cb121-54" aria-hidden="true" tabindex="-1"></a><span class="co">#             graph.find_or_create_vertex(child_state), </span></span>
<span id="cb121-55"><a href="#cb121-55" aria-hidden="true" tabindex="-1"></a><span class="co">#             weight=flood_right</span></span>
<span id="cb121-56"><a href="#cb121-56" aria-hidden="true" tabindex="-1"></a><span class="co">#         )</span></span>
<span id="cb121-57"><a href="#cb121-57" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb121-58"><a href="#cb121-58" aria-hidden="true" tabindex="-1"></a><span class="co">#     index += 1</span></span>
<span id="cb121-59"><a href="#cb121-59" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb121-60"><a href="#cb121-60" aria-hidden="true" tabindex="-1"></a><span class="co"># # graph.plot(nodesep=1, ranksep=0.1)</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<div id="cell-153" class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb122"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb122-1"><a href="#cb122-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-2"><a href="#cb122-2" aria-hidden="true" tabindex="-1"></a><span class="co"># ctx = graph.distribution_context()</span></span>
<span id="cb122-3"><a href="#cb122-3" aria-hidden="true" tabindex="-1"></a><span class="co"># cdfs = []</span></span>
<span id="cb122-4"><a href="#cb122-4" aria-hidden="true" tabindex="-1"></a><span class="co"># times = []</span></span>
<span id="cb122-5"><a href="#cb122-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-6"><a href="#cb122-6" aria-hidden="true" tabindex="-1"></a><span class="co"># # while ctx.time() &lt; 1.5:</span></span>
<span id="cb122-7"><a href="#cb122-7" aria-hidden="true" tabindex="-1"></a><span class="co"># while ctx.cdf() &lt; 0.999:</span></span>
<span id="cb122-8"><a href="#cb122-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-9"><a href="#cb122-9" aria-hidden="true" tabindex="-1"></a><span class="co">#     cdfs.append(ctx.cdf())</span></span>
<span id="cb122-10"><a href="#cb122-10" aria-hidden="true" tabindex="-1"></a><span class="co">#     times.append(ctx.time())</span></span>
<span id="cb122-11"><a href="#cb122-11" aria-hidden="true" tabindex="-1"></a><span class="co">#     param_graph.update_parameterized_weights(</span></span>
<span id="cb122-12"><a href="#cb122-12" aria-hidden="true" tabindex="-1"></a><span class="co">#         [1,</span></span>
<span id="cb122-13"><a href="#cb122-13" aria-hidden="true" tabindex="-1"></a><span class="co">#         ctx.time() - 1.5, </span></span>
<span id="cb122-14"><a href="#cb122-14" aria-hidden="true" tabindex="-1"></a><span class="co">#         2 * ctx.time() - 1.5</span></span>
<span id="cb122-15"><a href="#cb122-15" aria-hidden="true" tabindex="-1"></a><span class="co">#         ]</span></span>
<span id="cb122-16"><a href="#cb122-16" aria-hidden="true" tabindex="-1"></a><span class="co">#     )</span></span>
<span id="cb122-17"><a href="#cb122-17" aria-hidden="true" tabindex="-1"></a><span class="co">#     ctx.step()</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p>It increases by every time step. Time until all rabbits are dead. Flooding increases linearly after 1.5 time units:</p>
<div id="cell-155" class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb123"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb123-1"><a href="#cb123-1" aria-hidden="true" tabindex="-1"></a>param_graph.update_parameterized_weights([<span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>])</span>
<span id="cb123-2"><a href="#cb123-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb123-3"><a href="#cb123-3" aria-hidden="true" tabindex="-1"></a>ctx <span class="op">=</span> param_graph.distribution_context()</span>
<span id="cb123-4"><a href="#cb123-4" aria-hidden="true" tabindex="-1"></a>cdfs <span class="op">=</span> []</span>
<span id="cb123-5"><a href="#cb123-5" aria-hidden="true" tabindex="-1"></a>times <span class="op">=</span> []</span>
<span id="cb123-6"><a href="#cb123-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb123-7"><a href="#cb123-7" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> ctx.time() <span class="op">&lt;</span> <span class="fl">1.5</span>:</span>
<span id="cb123-8"><a href="#cb123-8" aria-hidden="true" tabindex="-1"></a>    cdfs.append(ctx.cdf())</span>
<span id="cb123-9"><a href="#cb123-9" aria-hidden="true" tabindex="-1"></a>    times.append(ctx.time())</span>
<span id="cb123-10"><a href="#cb123-10" aria-hidden="true" tabindex="-1"></a>    ctx.step()</span>
<span id="cb123-11"><a href="#cb123-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb123-12"><a href="#cb123-12" aria-hidden="true" tabindex="-1"></a><span class="co">#param_graph.update_parameterized_weights([1, 1, 1])</span></span>
<span id="cb123-13"><a href="#cb123-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb123-14"><a href="#cb123-14" aria-hidden="true" tabindex="-1"></a><span class="co"># at time 1.5, the flooding starts!</span></span>
<span id="cb123-15"><a href="#cb123-15" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> ctx.cdf() <span class="op">&lt;</span> <span class="fl">0.999</span>:</span>
<span id="cb123-16"><a href="#cb123-16" aria-hidden="true" tabindex="-1"></a>    cdfs.append(ctx.cdf())</span>
<span id="cb123-17"><a href="#cb123-17" aria-hidden="true" tabindex="-1"></a>    times.append(ctx.time())</span>
<span id="cb123-18"><a href="#cb123-18" aria-hidden="true" tabindex="-1"></a>    param_graph.update_parameterized_weights(</span>
<span id="cb123-19"><a href="#cb123-19" aria-hidden="true" tabindex="-1"></a>        [<span class="dv">1</span>,</span>
<span id="cb123-20"><a href="#cb123-20" aria-hidden="true" tabindex="-1"></a>        ctx.time() <span class="op">-</span> <span class="fl">1.5</span>, </span>
<span id="cb123-21"><a href="#cb123-21" aria-hidden="true" tabindex="-1"></a>        <span class="dv">2</span> <span class="op">*</span> ctx.time() <span class="op">-</span> <span class="fl">1.5</span></span>
<span id="cb123-22"><a href="#cb123-22" aria-hidden="true" tabindex="-1"></a>        ]</span>
<span id="cb123-23"><a href="#cb123-23" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb123-24"><a href="#cb123-24" aria-hidden="true" tabindex="-1"></a>    ctx.step()</span>
<span id="cb123-25"><a href="#cb123-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb123-26"><a href="#cb123-26" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">1</span>, figsize<span class="op">=</span>(<span class="dv">4</span>, <span class="dv">3</span>))</span>
<span id="cb123-27"><a href="#cb123-27" aria-hidden="true" tabindex="-1"></a>ax.plot(times, cdfs)</span>
<span id="cb123-28"><a href="#cb123-28" aria-hidden="true" tabindex="-1"></a>sns.despine()</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><a href="rabbits_full_py_api_example_files/figure-html/cell-80-output-1.png" class="lightbox" data-gallery="quarto-lightbox-gallery-11"><img src="rabbits_full_py_api_example_files/figure-html/cell-80-output-1.png" width="361" height="274" class="figure-img"></a></p>
</figure>
</div>
</div>
</div>
<p>If we pick a time far into the future, we can integrate under it to find the expectation. This means that we can scale by a reward, and thereby find the marginal expectation.</p>
<p>Summing over accumulated visiting time (with reward):</p>
<div id="cell-158" class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb124"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb124-1"><a href="#cb124-1" aria-hidden="true" tabindex="-1"></a>np.<span class="bu">sum</span>(graph.accumulated_visiting_time(<span class="dv">10</span>)<span class="op">*</span>graph.states()[:,<span class="dv">1</span>])</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display" data-execution_count="70">
<pre><code>np.float64(0.09438775509887067)</code></pre>
</div>
</div>
<p>The first moment (expectation) (with reward):</p>
<div id="cell-160" class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb126"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb126-1"><a href="#cb126-1" aria-hidden="true" tabindex="-1"></a>graph.expectation(graph.states()[:,<span class="dv">1</span>])</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display" data-execution_count="71">
<pre><code>0.09438775510204081</code></pre>
</div>
</div>
<p>But if the time is <em>not</em> far into the future, we get the expectation up to a certain point in time.</p>
<p>Expectation (rewarded) when truncating at 0.05 time:</p>
<div id="cell-163" class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb128"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb128-1"><a href="#cb128-1" aria-hidden="true" tabindex="-1"></a>np.<span class="bu">sum</span>(graph.accumulated_visiting_time(<span class="fl">0.05</span>)<span class="op">*</span>graph.states()[:,<span class="dv">1</span>])</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display" data-execution_count="72">
<pre><code>np.float64(0.0011713234985744549)</code></pre>
</div>
</div>
<p>Untruncated expectation:</p>
<div id="cell-165" class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb130"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb130-1"><a href="#cb130-1" aria-hidden="true" tabindex="-1"></a>graph.expectation(graph.states()[:,<span class="dv">1</span>])</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display" data-execution_count="73">
<pre><code>0.09438775510204081</code></pre>
</div>
</div>
<p>Expectation (rewarded) when <em>starting</em> at 0.05 time:</p>
<p>The Laplace transform is a fundamental tool for analyzing continuous phase-type distributions. For a random variable T with probability density function f(t), the Laplace transform is defined as L(s) = E[e^(-sT)] = ∫₀^∞ e^(-st) f(t) dt. For phase-type distributions represented as absorbing Markov chains, the Laplace transform has an elegant matrix form that can be computed efficiently from the graph structure.</p>
<p>The Laplace transform is particularly useful because it provides an alternative characterization of the distribution that often simplifies analytical calculations. Moments can be recovered by differentiating the Laplace transform: the n-th moment is E[T^n] = (-1)^n (d^n L/ds^n)|_{s=0}. The Laplace transform also plays a crucial role in analyzing time-inhomogeneous processes and in computing convolutions of distributions.</p>
<p>In our rabbit model, the Laplace transform captures the moment generating function of the time until all rabbits have died. Let’s compute it and verify that we can recover moments by differentiation.</p>
<div id="cell-168" class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb132"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb132-1"><a href="#cb132-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Compute Laplace transform for several values of s</span></span>
<span id="cb132-2"><a href="#cb132-2" aria-hidden="true" tabindex="-1"></a>s_values <span class="op">=</span> np.array([<span class="fl">0.1</span>, <span class="fl">0.5</span>, <span class="fl">1.0</span>, <span class="fl">2.0</span>, <span class="fl">5.0</span>, <span class="fl">10.0</span>])</span>
<span id="cb132-3"><a href="#cb132-3" aria-hidden="true" tabindex="-1"></a>laplace_values <span class="op">=</span> graph.laplace_transform(s_values)</span>
<span id="cb132-4"><a href="#cb132-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb132-5"><a href="#cb132-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Laplace transform L(s) = E[e^(-sT)]:"</span>)</span>
<span id="cb132-6"><a href="#cb132-6" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> s, L_s <span class="kw">in</span> <span class="bu">zip</span>(s_values, laplace_values):</span>
<span id="cb132-7"><a href="#cb132-7" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"  L(</span><span class="sc">{</span>s<span class="sc">:4.1f}</span><span class="ss">) = </span><span class="sc">{</span>L_s<span class="sc">:.6f}</span><span class="ss">"</span>)</span>
<span id="cb132-8"><a href="#cb132-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb132-9"><a href="#cb132-9" aria-hidden="true" tabindex="-1"></a><span class="co"># Verify that L(0) = 1 (certain event)</span></span>
<span id="cb132-10"><a href="#cb132-10" aria-hidden="true" tabindex="-1"></a>L_0 <span class="op">=</span> graph.laplace_transform(np.array([<span class="fl">0.0</span>]))[<span class="dv">0</span>]</span>
<span id="cb132-11"><a href="#cb132-11" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss">Verification: L(0) = </span><span class="sc">{</span>L_0<span class="sc">:.10f}</span><span class="ss"> (should be 1.0)"</span>)</span>
<span id="cb132-12"><a href="#cb132-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb132-13"><a href="#cb132-13" aria-hidden="true" tabindex="-1"></a><span class="co"># Verify relationship to moments using numerical differentiation</span></span>
<span id="cb132-14"><a href="#cb132-14" aria-hidden="true" tabindex="-1"></a><span class="co"># E[T] = -L'(0), so we approximate with finite differences</span></span>
<span id="cb132-15"><a href="#cb132-15" aria-hidden="true" tabindex="-1"></a>h <span class="op">=</span> <span class="fl">1e-6</span></span>
<span id="cb132-16"><a href="#cb132-16" aria-hidden="true" tabindex="-1"></a>L_h <span class="op">=</span> graph.laplace_transform(np.array([h]))[<span class="dv">0</span>]</span>
<span id="cb132-17"><a href="#cb132-17" aria-hidden="true" tabindex="-1"></a>L_0 <span class="op">=</span> graph.laplace_transform(np.array([<span class="fl">0.0</span>]))[<span class="dv">0</span>]</span>
<span id="cb132-18"><a href="#cb132-18" aria-hidden="true" tabindex="-1"></a>numerical_expectation <span class="op">=</span> <span class="op">-</span>(L_h <span class="op">-</span> L_0) <span class="op">/</span> h</span>
<span id="cb132-19"><a href="#cb132-19" aria-hidden="true" tabindex="-1"></a>analytical_expectation <span class="op">=</span> graph.expectation()</span>
<span id="cb132-20"><a href="#cb132-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb132-21"><a href="#cb132-21" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss">Expectation from Laplace derivative: </span><span class="sc">{</span>numerical_expectation<span class="sc">:.6f}</span><span class="ss">"</span>)</span>
<span id="cb132-22"><a href="#cb132-22" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Expectation from direct computation: </span><span class="sc">{</span>analytical_expectation<span class="sc">:.6f}</span><span class="ss">"</span>)</span>
<span id="cb132-23"><a href="#cb132-23" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Relative error: </span><span class="sc">{</span><span class="bu">abs</span>(numerical_expectation <span class="op">-</span> analytical_expectation)<span class="op">/</span>analytical_expectation <span class="op">*</span> <span class="dv">100</span><span class="sc">:.4f}</span><span class="ss">%"</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p>Phase-type distributions can be extended to model joint probabilities of multiple random variables. This is particularly important in applications like population genetics, where we might be interested in the joint distribution of coalescence times for multiple lineages, or in reliability theory, where we might want the joint distribution of failure times for multiple components. The library provides tools for constructing and analyzing such joint distributions through the concept of multi-dimensional phase-type distributions.</p>
<p>The key idea is that we can embed multiple independent or dependent processes into a single state space, where the state vector encodes the progress of all processes simultaneously. Transitions in this joint state space then correspond to events in any of the individual processes. By carefully constructing the edge weights and using reward transformations, we can extract marginal distributions, conditional distributions, and joint distribution functions.</p>
<p>In our rabbit model, we might be interested in the joint distribution of two quantities: the time until the left island is depleted (either by jumping or flooding) and the time until the right island is depleted. These two times are not independent—they are coupled through the rabbits jumping between islands. Let’s construct a model that tracks both times simultaneously.</p>
<div id="cell-170" class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb133"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb133-1"><a href="#cb133-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Construct a rabbit model that tracks time to depletion for each island separately</span></span>
<span id="cb133-2"><a href="#cb133-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> construct_joint_time_model(nr_rabbits, flood_left, flood_right):</span>
<span id="cb133-3"><a href="#cb133-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb133-4"><a href="#cb133-4" aria-hidden="true" tabindex="-1"></a><span class="co">    Construct a model tracking joint distribution of depletion times.</span></span>
<span id="cb133-5"><a href="#cb133-5" aria-hidden="true" tabindex="-1"></a><span class="co">    State: [rabbits_left, rabbits_right, left_depleted, right_depleted]</span></span>
<span id="cb133-6"><a href="#cb133-6" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb133-7"><a href="#cb133-7" aria-hidden="true" tabindex="-1"></a>    graph <span class="op">=</span> Graph(state_length<span class="op">=</span><span class="dv">4</span>)</span>
<span id="cb133-8"><a href="#cb133-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb133-9"><a href="#cb133-9" aria-hidden="true" tabindex="-1"></a>    initial_state <span class="op">=</span> [nr_rabbits, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>]  <span class="co"># Start with all rabbits on left</span></span>
<span id="cb133-10"><a href="#cb133-10" aria-hidden="true" tabindex="-1"></a>    graph.starting_vertex().add_edge(graph.find_or_create_vertex(initial_state), <span class="dv">1</span>)</span>
<span id="cb133-11"><a href="#cb133-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb133-12"><a href="#cb133-12" aria-hidden="true" tabindex="-1"></a>    index <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb133-13"><a href="#cb133-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> index <span class="op">&lt;</span> graph.vertices_length():</span>
<span id="cb133-14"><a href="#cb133-14" aria-hidden="true" tabindex="-1"></a>        vertex <span class="op">=</span> graph.vertex_at(index)</span>
<span id="cb133-15"><a href="#cb133-15" aria-hidden="true" tabindex="-1"></a>        state <span class="op">=</span> <span class="bu">list</span>(vertex.state())</span>
<span id="cb133-16"><a href="#cb133-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb133-17"><a href="#cb133-17" aria-hidden="true" tabindex="-1"></a>        <span class="co"># If left island has rabbits and not yet depleted</span></span>
<span id="cb133-18"><a href="#cb133-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> state[<span class="dv">0</span>] <span class="op">&gt;</span> <span class="dv">0</span> <span class="kw">and</span> state[<span class="dv">2</span>] <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb133-19"><a href="#cb133-19" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Jump to right</span></span>
<span id="cb133-20"><a href="#cb133-20" aria-hidden="true" tabindex="-1"></a>            child_state <span class="op">=</span> [state[<span class="dv">0</span>] <span class="op">-</span> <span class="dv">1</span>, state[<span class="dv">1</span>] <span class="op">+</span> <span class="dv">1</span>, state[<span class="dv">2</span>], state[<span class="dv">3</span>]]</span>
<span id="cb133-21"><a href="#cb133-21" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> child_state[<span class="dv">0</span>] <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb133-22"><a href="#cb133-22" aria-hidden="true" tabindex="-1"></a>                child_state[<span class="dv">2</span>] <span class="op">=</span> <span class="dv">1</span>  <span class="co"># Mark left as depleted</span></span>
<span id="cb133-23"><a href="#cb133-23" aria-hidden="true" tabindex="-1"></a>            vertex.add_edge(graph.find_or_create_vertex(child_state), weight<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb133-24"><a href="#cb133-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb133-25"><a href="#cb133-25" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Left flooding</span></span>
<span id="cb133-26"><a href="#cb133-26" aria-hidden="true" tabindex="-1"></a>            child_state <span class="op">=</span> [<span class="dv">0</span>, state[<span class="dv">1</span>], <span class="dv">1</span>, state[<span class="dv">3</span>]]  <span class="co"># All left rabbits die, mark depleted</span></span>
<span id="cb133-27"><a href="#cb133-27" aria-hidden="true" tabindex="-1"></a>            vertex.add_edge(graph.find_or_create_vertex(child_state), weight<span class="op">=</span>flood_left)</span>
<span id="cb133-28"><a href="#cb133-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb133-29"><a href="#cb133-29" aria-hidden="true" tabindex="-1"></a>        <span class="co"># If right island has rabbits and not yet depleted</span></span>
<span id="cb133-30"><a href="#cb133-30" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> state[<span class="dv">1</span>] <span class="op">&gt;</span> <span class="dv">0</span> <span class="kw">and</span> state[<span class="dv">3</span>] <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb133-31"><a href="#cb133-31" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Jump to left</span></span>
<span id="cb133-32"><a href="#cb133-32" aria-hidden="true" tabindex="-1"></a>            child_state <span class="op">=</span> [state[<span class="dv">0</span>] <span class="op">+</span> <span class="dv">1</span>, state[<span class="dv">1</span>] <span class="op">-</span> <span class="dv">1</span>, state[<span class="dv">2</span>], state[<span class="dv">3</span>]]</span>
<span id="cb133-33"><a href="#cb133-33" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> child_state[<span class="dv">1</span>] <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb133-34"><a href="#cb133-34" aria-hidden="true" tabindex="-1"></a>                child_state[<span class="dv">3</span>] <span class="op">=</span> <span class="dv">1</span>  <span class="co"># Mark right as depleted</span></span>
<span id="cb133-35"><a href="#cb133-35" aria-hidden="true" tabindex="-1"></a>            vertex.add_edge(graph.find_or_create_vertex(child_state), weight<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb133-36"><a href="#cb133-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb133-37"><a href="#cb133-37" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Right flooding</span></span>
<span id="cb133-38"><a href="#cb133-38" aria-hidden="true" tabindex="-1"></a>            child_state <span class="op">=</span> [state[<span class="dv">0</span>], <span class="dv">0</span>, state[<span class="dv">2</span>], <span class="dv">1</span>]  <span class="co"># All right rabbits die, mark depleted</span></span>
<span id="cb133-39"><a href="#cb133-39" aria-hidden="true" tabindex="-1"></a>            vertex.add_edge(graph.find_or_create_vertex(child_state), weight<span class="op">=</span>flood_right)</span>
<span id="cb133-40"><a href="#cb133-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb133-41"><a href="#cb133-41" aria-hidden="true" tabindex="-1"></a>        index <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb133-42"><a href="#cb133-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb133-43"><a href="#cb133-43" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> graph</span>
<span id="cb133-44"><a href="#cb133-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb133-45"><a href="#cb133-45" aria-hidden="true" tabindex="-1"></a><span class="co"># Create the joint model</span></span>
<span id="cb133-46"><a href="#cb133-46" aria-hidden="true" tabindex="-1"></a>joint_graph <span class="op">=</span> construct_joint_time_model(<span class="dv">3</span>, <span class="fl">2.0</span>, <span class="fl">4.0</span>)</span>
<span id="cb133-47"><a href="#cb133-47" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Created joint model with </span><span class="sc">{</span>joint_graph<span class="sc">.</span>vertices_length()<span class="sc">}</span><span class="ss"> states"</span>)</span>
<span id="cb133-48"><a href="#cb133-48" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss">First few states (rabbits_left, rabbits_right, left_depleted, right_depleted):"</span>)</span>
<span id="cb133-49"><a href="#cb133-49" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">min</span>(<span class="dv">10</span>, joint_graph.vertices_length())):</span>
<span id="cb133-50"><a href="#cb133-50" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"  State </span><span class="sc">{</span>i<span class="sc">}</span><span class="ss">: </span><span class="sc">{</span>joint_graph<span class="sc">.</span>vertex_at(i)<span class="sc">.</span>state()<span class="sc">}</span><span class="ss">"</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p>Now we can use rewards to extract information about the joint distribution. By defining rewards that are non-zero only until each island is depleted, we can compute the marginal time until depletion for each island. By looking at the joint accumulated rewards, we can explore the correlation between these depletion times.</p>
<div id="cell-172" class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb134"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb134-1"><a href="#cb134-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Define rewards: earn reward while island is not depleted</span></span>
<span id="cb134-2"><a href="#cb134-2" aria-hidden="true" tabindex="-1"></a>states <span class="op">=</span> joint_graph.states()</span>
<span id="cb134-3"><a href="#cb134-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb134-4"><a href="#cb134-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Reward 1: time spent before left depletion (left_depleted == 0)</span></span>
<span id="cb134-5"><a href="#cb134-5" aria-hidden="true" tabindex="-1"></a>reward_before_left_depletion <span class="op">=</span> (states[:, <span class="dv">2</span>] <span class="op">==</span> <span class="dv">0</span>).astype(<span class="bu">float</span>)</span>
<span id="cb134-6"><a href="#cb134-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb134-7"><a href="#cb134-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Reward 2: time spent before right depletion (right_depleted == 0)</span></span>
<span id="cb134-8"><a href="#cb134-8" aria-hidden="true" tabindex="-1"></a>reward_before_right_depletion <span class="op">=</span> (states[:, <span class="dv">3</span>] <span class="op">==</span> <span class="dv">0</span>).astype(<span class="bu">float</span>)</span>
<span id="cb134-9"><a href="#cb134-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb134-10"><a href="#cb134-10" aria-hidden="true" tabindex="-1"></a><span class="co"># Compute expectations</span></span>
<span id="cb134-11"><a href="#cb134-11" aria-hidden="true" tabindex="-1"></a>E_time_to_left_depletion <span class="op">=</span> joint_graph.expectation(reward_before_left_depletion)</span>
<span id="cb134-12"><a href="#cb134-12" aria-hidden="true" tabindex="-1"></a>E_time_to_right_depletion <span class="op">=</span> joint_graph.expectation(reward_before_right_depletion)</span>
<span id="cb134-13"><a href="#cb134-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb134-14"><a href="#cb134-14" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Expected time until left island depleted: </span><span class="sc">{</span>E_time_to_left_depletion<span class="sc">:.4f}</span><span class="ss">"</span>)</span>
<span id="cb134-15"><a href="#cb134-15" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Expected time until right island depleted: </span><span class="sc">{</span>E_time_to_right_depletion<span class="sc">:.4f}</span><span class="ss">"</span>)</span>
<span id="cb134-16"><a href="#cb134-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb134-17"><a href="#cb134-17" aria-hidden="true" tabindex="-1"></a><span class="co"># Compute covariance between the two times</span></span>
<span id="cb134-18"><a href="#cb134-18" aria-hidden="true" tabindex="-1"></a>cov <span class="op">=</span> joint_graph.covariance(reward_before_left_depletion, reward_before_right_depletion)</span>
<span id="cb134-19"><a href="#cb134-19" aria-hidden="true" tabindex="-1"></a>var_left <span class="op">=</span> joint_graph.variance(reward_before_left_depletion)</span>
<span id="cb134-20"><a href="#cb134-20" aria-hidden="true" tabindex="-1"></a>var_right <span class="op">=</span> joint_graph.variance(reward_before_right_depletion)</span>
<span id="cb134-21"><a href="#cb134-21" aria-hidden="true" tabindex="-1"></a>correlation <span class="op">=</span> cov <span class="op">/</span> np.sqrt(var_left <span class="op">*</span> var_right)</span>
<span id="cb134-22"><a href="#cb134-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb134-23"><a href="#cb134-23" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss">Covariance between depletion times: </span><span class="sc">{</span>cov<span class="sc">:.6f}</span><span class="ss">"</span>)</span>
<span id="cb134-24"><a href="#cb134-24" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Correlation: </span><span class="sc">{</span>correlation<span class="sc">:.4f}</span><span class="ss">"</span>)</span>
<span id="cb134-25"><a href="#cb134-25" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">The positive correlation indicates that when the left island takes longer to deplete,"</span>)</span>
<span id="cb134-26"><a href="#cb134-26" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"the right island also tends to take longer (rabbits jumping back and forth prolongs both)"</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p>This framework for joint probabilities extends naturally to more complex scenarios. We can model multiple dependent processes, extract conditional distributions, and analyze the dependencies between different random variables in our model. The key is careful state space construction that encodes all relevant information, combined with judicious use of rewards to extract the quantities of interest. In population genetics applications, this approach is used to model the joint distribution of coalescence times across multiple loci or populations, capturing the complex dependencies induced by recombination and migration.</p>
<p>We can increase granularity for better performance:</p>
<div id="cell-175" class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb135"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb135-1"><a href="#cb135-1" aria-hidden="true" tabindex="-1"></a>np.<span class="bu">sum</span>(graph.accumulated_visiting_time(<span class="fl">0.05</span>, granularity<span class="op">=</span><span class="dv">1000000</span>)<span class="op">*</span>graph.states()[:,<span class="dv">1</span>])</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display" data-execution_count="77">
<pre><code>np.float64(0.0011138317897953385)</code></pre>
</div>
</div>
</section>
<section id="modelling-epochs-in-state-space" class="level2">
<h2 class="anchored" data-anchor-id="modelling-epochs-in-state-space">Modelling epochs in state space</h2>
</section>
<section id="laplace-transform" class="level2">
<h2 class="anchored" data-anchor-id="laplace-transform">Laplace transform</h2>
</section>
<section id="joint-probabiliity" class="level2">
<h2 class="anchored" data-anchor-id="joint-probabiliity">Joint probabiliity</h2>
</section>
<section id="distributed-computing-for-large-scale-inference" class="level2">
<h2 class="anchored" data-anchor-id="distributed-computing-for-large-scale-inference">Distributed Computing for Large-Scale Inference</h2>
<p>Modern computational infrastructure offers substantial computing power not just through faster processors, but through massive parallelism across multiple machines. A typical high-performance computing (HPC) cluster might have dozens to hundreds of compute nodes, each with dozens of CPU cores, representing thousands of processor cores working in parallel. For computationally intensive tasks like Bayesian inference, where we need to evaluate a complex model millions of times, this parallel computing power is transformative. What might take days on a single machine can complete in hours or minutes when distributed across a cluster.</p>
<p>The ptdalgorithms library is designed from the ground up to leverage this distributed computing infrastructure. Through tight integration with JAX’s distributed computing capabilities and support for SLURM (Simple Linux Utility for Resource Management), the standard job scheduler on HPC clusters, the library makes it straightforward to scale from running on your laptop to running on hundreds of nodes. The key insight is that many inference algorithms—particularly particle-based methods like Stein Variational Gradient Descent (SVGD)—are naturally parallel. Each particle can be evaluated independently, and gradients can be computed in parallel across all particles. With the right infrastructure, we can distribute these particles across many machines and aggregate results efficiently.</p>
<p>This section demonstrates how to set up and run distributed computations with ptdalgorithms. We will see how the library automatically detects whether it is running on a SLURM cluster, how it coordinates multiple processes across different nodes, and how JAX distributes computations across available resources. We will work with our rabbit model, showing how the combination of symbolic elimination (for fast per-particle evaluation) and distributed computing (for parallel particle evaluation) enables inference at scales that would be impossible on a single machine.</p>
<p>The workflow has three main components: (1) initialization, where we detect the distributed environment and set up JAX for multi-node computation; (2) model setup, where we construct our parameterized model and perform symbolic elimination; and (3) distributed evaluation, where we leverage JAX’s <code>pmap</code> (parallel map) to evaluate the model across all available devices in parallel. Let’s see each component in detail.</p>
<div id="cell-187" class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb137"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb137-1"><a href="#cb137-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Distributed computing setup</span></span>
<span id="cb137-2"><a href="#cb137-2" aria-hidden="true" tabindex="-1"></a><span class="co"># First check if we're on a SLURM cluster</span></span>
<span id="cb137-3"><a href="#cb137-3" aria-hidden="true" tabindex="-1"></a><span class="cf">try</span>:</span>
<span id="cb137-4"><a href="#cb137-4" aria-hidden="true" tabindex="-1"></a>    <span class="im">from</span> ptdalgorithms <span class="im">import</span> initialize_distributed, DistributedConfig</span>
<span id="cb137-5"><a href="#cb137-5" aria-hidden="true" tabindex="-1"></a>    HAS_DISTRIBUTED <span class="op">=</span> <span class="va">True</span></span>
<span id="cb137-6"><a href="#cb137-6" aria-hidden="true" tabindex="-1"></a><span class="cf">except</span> <span class="pp">ImportError</span>:</span>
<span id="cb137-7"><a href="#cb137-7" aria-hidden="true" tabindex="-1"></a>    HAS_DISTRIBUTED <span class="op">=</span> <span class="va">False</span></span>
<span id="cb137-8"><a href="#cb137-8" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"Distributed computing utilities not available"</span>)</span>
<span id="cb137-9"><a href="#cb137-9" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"These features require a SLURM cluster environment"</span>)</span>
<span id="cb137-10"><a href="#cb137-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb137-11"><a href="#cb137-11" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> HAS_DISTRIBUTED:</span>
<span id="cb137-12"><a href="#cb137-12" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Initialize distributed computing</span></span>
<span id="cb137-13"><a href="#cb137-13" aria-hidden="true" tabindex="-1"></a>    <span class="co"># This function auto-detects SLURM environment variables and sets up JAX</span></span>
<span id="cb137-14"><a href="#cb137-14" aria-hidden="true" tabindex="-1"></a>    dist_info <span class="op">=</span> initialize_distributed(</span>
<span id="cb137-15"><a href="#cb137-15" aria-hidden="true" tabindex="-1"></a>        coordinator_port<span class="op">=</span><span class="dv">12345</span>,  <span class="co"># Port for process coordination</span></span>
<span id="cb137-16"><a href="#cb137-16" aria-hidden="true" tabindex="-1"></a>        platform<span class="op">=</span><span class="st">"cpu"</span>,           <span class="co"># or "gpu" for GPU clusters</span></span>
<span id="cb137-17"><a href="#cb137-17" aria-hidden="true" tabindex="-1"></a>        enable_x64<span class="op">=</span><span class="va">True</span>          <span class="co"># Enable 64-bit precision</span></span>
<span id="cb137-18"><a href="#cb137-18" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb137-19"><a href="#cb137-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb137-20"><a href="#cb137-20" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Distributed computing initialized:"</span>)</span>
<span id="cb137-21"><a href="#cb137-21" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"  Process rank: </span><span class="sc">{</span>dist_info<span class="sc">.</span>global_rank<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb137-22"><a href="#cb137-22" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"  Total processes: </span><span class="sc">{</span>dist_info<span class="sc">.</span>num_processes<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb137-23"><a href="#cb137-23" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"  Local devices: </span><span class="sc">{</span>dist_info<span class="sc">.</span>num_local_devices<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb137-24"><a href="#cb137-24" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"  Total devices: </span><span class="sc">{</span>dist_info<span class="sc">.</span>num_global_devices<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb137-25"><a href="#cb137-25" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"  Coordinator: </span><span class="sc">{</span>dist_info<span class="sc">.</span>coordinator_address<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb137-26"><a href="#cb137-26" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span>:</span>
<span id="cb137-27"><a href="#cb137-27" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"Running in single-machine mode"</span>)</span>
<span id="cb137-28"><a href="#cb137-28" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Even without SLURM, we can use JAX on a single machine</span></span>
<span id="cb137-29"><a href="#cb137-29" aria-hidden="true" tabindex="-1"></a>    <span class="im">import</span> jax</span>
<span id="cb137-30"><a href="#cb137-30" aria-hidden="true" tabindex="-1"></a>    jax.config.update(<span class="st">"jax_enable_x64"</span>, <span class="va">True</span>)</span>
<span id="cb137-31"><a href="#cb137-31" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Available devices: </span><span class="sc">{</span>jax<span class="sc">.</span>devices()<span class="sc">}</span><span class="ss">"</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p>The initialization step handles all the complexity of distributed setup. If we’re on a SLURM cluster, it reads environment variables like <code>SLURM_PROCID</code>, <code>SLURM_NTASKS</code>, and <code>SLURM_NODELIST</code> to determine how many processes are running and where they are located. It identifies a coordinator process (typically rank 0) and establishes communication between all processes. It then initializes JAX’s distributed computing backend, telling JAX about all available devices across all nodes.</p>
<p>The result is a computing environment where JAX operations can be automatically distributed. When we use <code>jax.pmap</code> (parallel map) to parallelize a function, JAX will distribute the work across all devices on all nodes. From our perspective as users, we write code that looks almost like single-machine code, but it runs in parallel across the entire cluster.</p>
<p>Now let’s set up our rabbit model for distributed inference. We will use the parameterized model with symbolic elimination, which gives us fast evaluation, and wrap it in a JAX-compatible function that can be parallelized.</p>
<div id="cell-189" class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb138"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb138-1"><a href="#cb138-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Set up the parameterized rabbit model with symbolic elimination</span></span>
<span id="cb138-2"><a href="#cb138-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb138-3"><a href="#cb138-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb138-4"><a href="#cb138-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> create_symbolic_rabbit_model(n_rabbits<span class="op">=</span><span class="dv">5</span>):</span>
<span id="cb138-5"><a href="#cb138-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Create a parameterized rabbit model with symbolic elimination"""</span></span>
<span id="cb138-6"><a href="#cb138-6" aria-hidden="true" tabindex="-1"></a>    graph <span class="op">=</span> construct_parameterized_rabbit_model(n_rabbits)</span>
<span id="cb138-7"><a href="#cb138-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb138-8"><a href="#cb138-8" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Initial parameters for elimination</span></span>
<span id="cb138-9"><a href="#cb138-9" aria-hidden="true" tabindex="-1"></a>    initial_params <span class="op">=</span> np.array([<span class="fl">1.0</span>, <span class="fl">2.0</span>, <span class="fl">4.0</span>])</span>
<span id="cb138-10"><a href="#cb138-10" aria-hidden="true" tabindex="-1"></a>    graph.update_parameterized_weights(initial_params)</span>
<span id="cb138-11"><a href="#cb138-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb138-12"><a href="#cb138-12" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Perform symbolic elimination</span></span>
<span id="cb138-13"><a href="#cb138-13" aria-hidden="true" tabindex="-1"></a>    dag <span class="op">=</span> graph.eliminate_to_dag()</span>
<span id="cb138-14"><a href="#cb138-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb138-15"><a href="#cb138-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dag</span>
<span id="cb138-16"><a href="#cb138-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb138-17"><a href="#cb138-17" aria-hidden="true" tabindex="-1"></a><span class="co"># Create the symbolic model</span></span>
<span id="cb138-18"><a href="#cb138-18" aria-hidden="true" tabindex="-1"></a>symbolic_dag <span class="op">=</span> create_symbolic_rabbit_model(n_rabbits<span class="op">=</span><span class="dv">5</span>)</span>
<span id="cb138-19"><a href="#cb138-19" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Created symbolic model with </span><span class="sc">{</span>symbolic_dag<span class="sc">.</span>vertices_length<span class="sc">}</span><span class="ss"> expression nodes"</span>)</span>
<span id="cb138-20"><a href="#cb138-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb138-21"><a href="#cb138-21" aria-hidden="true" tabindex="-1"></a><span class="co"># Define a JAX-compatible evaluation function</span></span>
<span id="cb138-22"><a href="#cb138-22" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> evaluate_model(params):</span>
<span id="cb138-23"><a href="#cb138-23" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Evaluate the model for given parameters"""</span></span>
<span id="cb138-24"><a href="#cb138-24" aria-hidden="true" tabindex="-1"></a>    concrete <span class="op">=</span> symbolic_dag.instantiate(params)</span>
<span id="cb138-25"><a href="#cb138-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> concrete.expectation()</span>
<span id="cb138-26"><a href="#cb138-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb138-27"><a href="#cb138-27" aria-hidden="true" tabindex="-1"></a><span class="co"># Test on a single parameter vector</span></span>
<span id="cb138-28"><a href="#cb138-28" aria-hidden="true" tabindex="-1"></a>test_params <span class="op">=</span> np.array([<span class="fl">1.5</span>, <span class="fl">3.0</span>, <span class="fl">5.0</span>])</span>
<span id="cb138-29"><a href="#cb138-29" aria-hidden="true" tabindex="-1"></a>result <span class="op">=</span> evaluate_model(test_params)</span>
<span id="cb138-30"><a href="#cb138-30" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss">Test evaluation: E[T] = </span><span class="sc">{</span>result<span class="sc">:.6f}</span><span class="ss"> for params </span><span class="sc">{</span>test_params<span class="sc">}</span><span class="ss">"</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p>With the model set up, we can now create a distributed evaluation function. The key is to use <code>jax.pmap</code>, which automatically distributes computation across all available devices. We pass it a function and a batch of inputs (one per device), and it evaluates the function on each input in parallel, returning the results. This is perfect for SVGD and other particle methods, where we have many particles (parameter vectors) to evaluate independently.</p>
<div id="cell-191" class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb139"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb139-1"><a href="#cb139-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> jax</span>
<span id="cb139-2"><a href="#cb139-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> jax.numpy <span class="im">as</span> jnp</span>
<span id="cb139-3"><a href="#cb139-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb139-4"><a href="#cb139-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Create a batch of parameter vectors to evaluate in parallel</span></span>
<span id="cb139-5"><a href="#cb139-5" aria-hidden="true" tabindex="-1"></a><span class="co"># In a real inference run, these would be our SVGD particles</span></span>
<span id="cb139-6"><a href="#cb139-6" aria-hidden="true" tabindex="-1"></a>n_particles <span class="op">=</span> <span class="dv">8</span>  <span class="co"># Usually 100-1000 for real inference</span></span>
<span id="cb139-7"><a href="#cb139-7" aria-hidden="true" tabindex="-1"></a>np.random.seed(<span class="dv">42</span>)</span>
<span id="cb139-8"><a href="#cb139-8" aria-hidden="true" tabindex="-1"></a>particle_params <span class="op">=</span> np.random.uniform(<span class="fl">0.5</span>, <span class="fl">5.0</span>, size<span class="op">=</span>(n_particles, <span class="dv">3</span>))</span>
<span id="cb139-9"><a href="#cb139-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb139-10"><a href="#cb139-10" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Evaluating </span><span class="sc">{</span>n_particles<span class="sc">}</span><span class="ss"> particles..."</span>)</span>
<span id="cb139-11"><a href="#cb139-11" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Available JAX devices: </span><span class="sc">{</span><span class="bu">len</span>(jax.devices())<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb139-12"><a href="#cb139-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb139-13"><a href="#cb139-13" aria-hidden="true" tabindex="-1"></a><span class="co"># For demonstration, we'll vectorize over particles using vmap</span></span>
<span id="cb139-14"><a href="#cb139-14" aria-hidden="true" tabindex="-1"></a><span class="co"># In a multi-device setting, pmap would distribute across devices</span></span>
<span id="cb139-15"><a href="#cb139-15" aria-hidden="true" tabindex="-1"></a>evaluate_batch <span class="op">=</span> jax.vmap(evaluate_model)</span>
<span id="cb139-16"><a href="#cb139-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb139-17"><a href="#cb139-17" aria-hidden="true" tabindex="-1"></a><span class="co"># Convert to JAX arrays</span></span>
<span id="cb139-18"><a href="#cb139-18" aria-hidden="true" tabindex="-1"></a>particle_params_jax <span class="op">=</span> jnp.array(particle_params)</span>
<span id="cb139-19"><a href="#cb139-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb139-20"><a href="#cb139-20" aria-hidden="true" tabindex="-1"></a><span class="co"># Evaluate all particles</span></span>
<span id="cb139-21"><a href="#cb139-21" aria-hidden="true" tabindex="-1"></a>start <span class="op">=</span> time.time()</span>
<span id="cb139-22"><a href="#cb139-22" aria-hidden="true" tabindex="-1"></a>expectations <span class="op">=</span> evaluate_batch(particle_params_jax)</span>
<span id="cb139-23"><a href="#cb139-23" aria-hidden="true" tabindex="-1"></a>elapsed <span class="op">=</span> time.time() <span class="op">-</span> start</span>
<span id="cb139-24"><a href="#cb139-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb139-25"><a href="#cb139-25" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss">Batch evaluation of </span><span class="sc">{</span>n_particles<span class="sc">}</span><span class="ss"> particles: </span><span class="sc">{</span>elapsed<span class="op">*</span><span class="dv">1000</span><span class="sc">:.2f}</span><span class="ss"> ms"</span>)</span>
<span id="cb139-26"><a href="#cb139-26" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Time per particle: </span><span class="sc">{</span>elapsed<span class="op">/</span>n_particles<span class="op">*</span><span class="dv">1000</span><span class="sc">:.2f}</span><span class="ss"> ms"</span>)</span>
<span id="cb139-27"><a href="#cb139-27" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss">Expectations for first 5 particles:"</span>)</span>
<span id="cb139-28"><a href="#cb139-28" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">min</span>(<span class="dv">5</span>, n_particles)):</span>
<span id="cb139-29"><a href="#cb139-29" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"  Particle </span><span class="sc">{</span>i<span class="sc">}</span><span class="ss">: </span><span class="sc">{</span>expectations[i]<span class="sc">:.6f}</span><span class="ss">"</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p>In a true distributed setting on a SLURM cluster, <code>jax.pmap</code> would distribute these particles across all devices on all nodes. Each node would compute a fraction of the particles, and JAX would handle all communication and synchronization automatically. The performance scaling is typically excellent—doubling the number of nodes roughly halves the computation time, up to the point where communication overhead becomes significant.</p>
<p>For a concrete example, imagine we have 1000 SVGD particles and 10 compute nodes with 40 cores each. Instead of evaluating all 1000 particles sequentially on one machine, we would evaluate 100 particles on each machine in parallel. If each particle takes 10ms to evaluate, sequential evaluation would take 10 seconds, but distributed evaluation would take just 100ms—a 100× speedup. Combined with symbolic elimination’s speedup of perhaps 100× over naive evaluation, we achieve a total speedup of 10,000× compared to the baseline approach.</p>
<p>The setup for distributed SLURM jobs typically involves three components: (1) a Python script containing the inference code (using <code>initialize_distributed()</code> for setup), (2) a SLURM batch script specifying resource requirements (nodes, tasks per node, time limit), and (3) the <code>srun</code> or <code>sbatch</code> command to launch the job. Here’s an example SLURM batch script:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb140"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb140-1"><a href="#cb140-1" aria-hidden="true" tabindex="-1"></a><span class="co">#!/bin/bash</span></span>
<span id="cb140-2"><a href="#cb140-2" aria-hidden="true" tabindex="-1"></a><span class="co">#SBATCH --job-name=rabbit_inference</span></span>
<span id="cb140-3"><a href="#cb140-3" aria-hidden="true" tabindex="-1"></a><span class="co">#SBATCH --nodes=10               # Request 10 compute nodes</span></span>
<span id="cb140-4"><a href="#cb140-4" aria-hidden="true" tabindex="-1"></a><span class="co">#SBATCH --ntasks-per-node=1      # One task per node (one JAX process)</span></span>
<span id="cb140-5"><a href="#cb140-5" aria-hidden="true" tabindex="-1"></a><span class="co">#SBATCH --cpus-per-task=40       # Use all cores on each node</span></span>
<span id="cb140-6"><a href="#cb140-6" aria-hidden="true" tabindex="-1"></a><span class="co">#SBATCH --time=02:00:00          # 2 hour time limit</span></span>
<span id="cb140-7"><a href="#cb140-7" aria-hidden="true" tabindex="-1"></a><span class="co">#SBATCH --partition=compute       # Cluster partition to use</span></span>
<span id="cb140-8"><a href="#cb140-8" aria-hidden="true" tabindex="-1"></a><span class="co">#SBATCH --output=logs/job_%j.out # Output file</span></span>
<span id="cb140-9"><a href="#cb140-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb140-10"><a href="#cb140-10" aria-hidden="true" tabindex="-1"></a><span class="co"># Load necessary modules (cluster-specific)</span></span>
<span id="cb140-11"><a href="#cb140-11" aria-hidden="true" tabindex="-1"></a><span class="ex">module</span> load python/3.9</span>
<span id="cb140-12"><a href="#cb140-12" aria-hidden="true" tabindex="-1"></a><span class="ex">module</span> load cuda/11.8  <span class="co"># If using GPUs</span></span>
<span id="cb140-13"><a href="#cb140-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb140-14"><a href="#cb140-14" aria-hidden="true" tabindex="-1"></a><span class="co"># Set environment variables for optimal performance</span></span>
<span id="cb140-15"><a href="#cb140-15" aria-hidden="true" tabindex="-1"></a><span class="bu">export</span> <span class="va">JAX_PLATFORMS</span><span class="op">=</span>cpu  <span class="co"># or 'gpu' for GPU clusters</span></span>
<span id="cb140-16"><a href="#cb140-16" aria-hidden="true" tabindex="-1"></a><span class="bu">export</span> <span class="va">XLA_FLAGS</span><span class="op">=</span><span class="st">"--xla_cpu_multi_thread_eigen=false"</span></span>
<span id="cb140-17"><a href="#cb140-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb140-18"><a href="#cb140-18" aria-hidden="true" tabindex="-1"></a><span class="co"># Run the distributed inference script</span></span>
<span id="cb140-19"><a href="#cb140-19" aria-hidden="true" tabindex="-1"></a><span class="ex">srun</span> python distributed_rabbit_inference.py <span class="dt">\</span></span>
<span id="cb140-20"><a href="#cb140-20" aria-hidden="true" tabindex="-1"></a>    <span class="at">--n-particles</span> 1000 <span class="dt">\</span></span>
<span id="cb140-21"><a href="#cb140-21" aria-hidden="true" tabindex="-1"></a>    <span class="at">--n-iterations</span> 500 <span class="dt">\</span></span>
<span id="cb140-22"><a href="#cb140-22" aria-hidden="true" tabindex="-1"></a>    <span class="at">--output</span> results/inference_run_<span class="va">${SLURM_JOB_ID}</span>.pkl</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>The script specifies that we want 10 nodes with one process per node. The <code>srun</code> command launches our Python script across all nodes simultaneously, with each process initialized by <code>initialize_distributed()</code> understanding its role in the computation. From inside our Python code, we can use <code>pmap</code> to distribute work, and JAX handles all the inter-node communication transparently.</p>
<p>The distributed computing framework integrates seamlessly with the rest of the ptdalgorithms ecosystem. You build your model, perform symbolic elimination, wrap it in a JAX function, and then use standard JAX parallelization primitives (<code>pmap</code>, <code>vmap</code>) to scale to arbitrary cluster sizes. The combination enables inference workflows that would be completely impractical on a single machine, opening up applications in population genetics, systems biology, and other fields where complex stochastic models meet large datasets.</p>
</section>
<section id="bayesian-inference-with-stein-variational-gradient-descent" class="level2">
<h2 class="anchored" data-anchor-id="bayesian-inference-with-stein-variational-gradient-descent">Bayesian Inference with Stein Variational Gradient Descent</h2>
<p>Having explored how to construct models, compute their properties, evaluate them efficiently through symbolic elimination, and scale computations across distributed clusters, we now turn to a fundamental question: given observed data, how do we estimate the parameters of our model? This is the domain of statistical inference. In a Bayesian framework, we seek not just point estimates but entire posterior distributions over parameters, quantifying our uncertainty about parameter values given the data we have observed.</p>
<p>Traditional Markov Chain Monte Carlo (MCMC) methods like Metropolis-Hastings and Hamiltonian Monte Carlo have been the workhorses of Bayesian inference for decades. However, these methods face challenges with high-dimensional parameter spaces, complex posterior geometries, and the need for many sequential samples to achieve convergence. Stein Variational Gradient Descent (SVGD) offers a compelling alternative. Instead of generating samples sequentially through a Markov chain, SVGD represents the posterior with a set of particles (parameter vectors) and updates these particles iteratively to move them toward the posterior distribution. The method combines ideas from optimization, kernel methods, and functional analysis to create a deterministic algorithm that is highly parallelizable and works well in high dimensions.</p>
<p>The key insight of SVGD is to treat inference as an optimization problem in the space of probability distributions. We start with an initial set of particles (typically drawn from the prior or from a simple distribution) and iteratively transport these particles toward the posterior using gradient information. Each particle interacts with all other particles through a kernel function, with the interaction strength depending on the distance between particles. This interaction ensures that particles spread out to cover the posterior distribution rather than collapsing to a single mode. The updates use gradients of the log-likelihood and log-prior, which we can compute efficiently using JAX’s automatic differentiation, combined with our symbolically eliminated model for fast likelihood evaluation.</p>
<p>For our rabbit model, imagine we have observed data: the time until all rabbits died. Based on this observation, we want to estimate the three parameters of our model—jump rate, left flooding rate, and right flooding rate—along with quantifying our uncertainty about these parameters. We will set up a likelihood function, specify a prior distribution, and use SVGD to approximate the posterior distribution with a set of particles. This workflow showcases the entire pipeline: model construction, symbolic elimination, JAX integration, gradient-based inference, and (optionally) distributed computing.</p>
<div id="cell-197" class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb141"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb141-1"><a href="#cb141-1" aria-hidden="true" tabindex="-1"></a><span class="co"># SVGD Inference Setup</span></span>
<span id="cb141-2"><a href="#cb141-2" aria-hidden="true" tabindex="-1"></a><span class="co"># First, let's generate some synthetic data from our rabbit model</span></span>
<span id="cb141-3"><a href="#cb141-3" aria-hidden="true" tabindex="-1"></a><span class="co"># In a real application, this would be actual observed data</span></span>
<span id="cb141-4"><a href="#cb141-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb141-5"><a href="#cb141-5" aria-hidden="true" tabindex="-1"></a><span class="co"># True parameter values (unknown to our inference procedure)</span></span>
<span id="cb141-6"><a href="#cb141-6" aria-hidden="true" tabindex="-1"></a>true_params <span class="op">=</span> np.array([<span class="fl">1.0</span>, <span class="fl">2.5</span>, <span class="fl">5.0</span>])  <span class="co"># jump_rate, flood_left, flood_right</span></span>
<span id="cb141-7"><a href="#cb141-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb141-8"><a href="#cb141-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Generate synthetic observations</span></span>
<span id="cb141-9"><a href="#cb141-9" aria-hidden="true" tabindex="-1"></a>np.random.seed(<span class="dv">123</span>)</span>
<span id="cb141-10"><a href="#cb141-10" aria-hidden="true" tabindex="-1"></a>graph_true <span class="op">=</span> construct_parameterized_rabbit_model(n_rabbits<span class="op">=</span><span class="dv">5</span>)</span>
<span id="cb141-11"><a href="#cb141-11" aria-hidden="true" tabindex="-1"></a>graph_true.update_parameterized_weights(true_params)</span>
<span id="cb141-12"><a href="#cb141-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb141-13"><a href="#cb141-13" aria-hidden="true" tabindex="-1"></a><span class="co"># Sample extinction times (our observed data)</span></span>
<span id="cb141-14"><a href="#cb141-14" aria-hidden="true" tabindex="-1"></a>n_observations <span class="op">=</span> <span class="dv">100</span></span>
<span id="cb141-15"><a href="#cb141-15" aria-hidden="true" tabindex="-1"></a>observed_times <span class="op">=</span> graph_true.sample(n_observations)</span>
<span id="cb141-16"><a href="#cb141-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb141-17"><a href="#cb141-17" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Synthetic Data Generated:"</span>)</span>
<span id="cb141-18"><a href="#cb141-18" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"  True parameters: </span><span class="sc">{</span>true_params<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb141-19"><a href="#cb141-19" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"  Number of observations: </span><span class="sc">{</span>n_observations<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb141-20"><a href="#cb141-20" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"  Observed times - mean: </span><span class="sc">{</span>np<span class="sc">.</span>mean(observed_times)<span class="sc">:.4f}</span><span class="ss">, std: </span><span class="sc">{</span>np<span class="sc">.</span>std(observed_times)<span class="sc">:.4f}</span><span class="ss">"</span>)</span>
<span id="cb141-21"><a href="#cb141-21" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"  True expectation: </span><span class="sc">{</span>graph_true<span class="sc">.</span>expectation()<span class="sc">:.4f}</span><span class="ss">"</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p>Now we need to define our inference problem in terms of a log-posterior function. According to Bayes’ theorem, the posterior is proportional to the likelihood times the prior: p(θ|data) ∝ p(data|θ) × p(θ). Taking logarithms gives us log p(θ|data) = log p(data|θ) + log p(θ) + constant. The SVGD algorithm requires us to provide a function that computes this log-posterior (up to an additive constant, which doesn’t affect gradients).</p>
<p>For the likelihood, we use the probability density function of our phase-type distribution evaluated at the observed times. For the prior, we will use independent log-normal distributions for each parameter, reflecting our prior belief that parameters are positive with uncertainty spanning orders of magnitude. The implementation leverages our symbolic DAG for fast likelihood evaluation and JAX for automatic differentiation of the entire log-posterior.</p>
<div id="cell-199" class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb142"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb142-1"><a href="#cb142-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> jax</span>
<span id="cb142-2"><a href="#cb142-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> jax.numpy <span class="im">as</span> jnp</span>
<span id="cb142-3"><a href="#cb142-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> jax.scipy.stats <span class="im">import</span> norm, lognorm</span>
<span id="cb142-4"><a href="#cb142-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb142-5"><a href="#cb142-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Set up the symbolic model for fast evaluation</span></span>
<span id="cb142-6"><a href="#cb142-6" aria-hidden="true" tabindex="-1"></a>symbolic_dag <span class="op">=</span> create_symbolic_rabbit_model(n_rabbits<span class="op">=</span><span class="dv">5</span>)</span>
<span id="cb142-7"><a href="#cb142-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb142-8"><a href="#cb142-8" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> log_likelihood(params, times):</span>
<span id="cb142-9"><a href="#cb142-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb142-10"><a href="#cb142-10" aria-hidden="true" tabindex="-1"></a><span class="co">    Compute log-likelihood of observed times given parameters.</span></span>
<span id="cb142-11"><a href="#cb142-11" aria-hidden="true" tabindex="-1"></a><span class="co">    Uses symbolic DAG for fast evaluation.</span></span>
<span id="cb142-12"><a href="#cb142-12" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb142-13"><a href="#cb142-13" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Instantiate the model with given parameters</span></span>
<span id="cb142-14"><a href="#cb142-14" aria-hidden="true" tabindex="-1"></a>    concrete <span class="op">=</span> symbolic_dag.instantiate(params)</span>
<span id="cb142-15"><a href="#cb142-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb142-16"><a href="#cb142-16" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Evaluate PDF at observed times</span></span>
<span id="cb142-17"><a href="#cb142-17" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Note: In practice, you would use the proper PDF evaluation from the library</span></span>
<span id="cb142-18"><a href="#cb142-18" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Here we approximate with density evaluation</span></span>
<span id="cb142-19"><a href="#cb142-19" aria-hidden="true" tabindex="-1"></a>    log_densities <span class="op">=</span> jnp.log(concrete.pdf(times) <span class="op">+</span> <span class="fl">1e-10</span>)  <span class="co"># Add small constant for numerical stability</span></span>
<span id="cb142-20"><a href="#cb142-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb142-21"><a href="#cb142-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> jnp.<span class="bu">sum</span>(log_densities)</span>
<span id="cb142-22"><a href="#cb142-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb142-23"><a href="#cb142-23" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> log_prior(params):</span>
<span id="cb142-24"><a href="#cb142-24" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb142-25"><a href="#cb142-25" aria-hidden="true" tabindex="-1"></a><span class="co">    Log-prior density for parameters.</span></span>
<span id="cb142-26"><a href="#cb142-26" aria-hidden="true" tabindex="-1"></a><span class="co">    Independent log-normal priors: log-normal(mean=0, sd=1)</span></span>
<span id="cb142-27"><a href="#cb142-27" aria-hidden="true" tabindex="-1"></a><span class="co">    This gives prior mass to positive values with wide uncertainty.</span></span>
<span id="cb142-28"><a href="#cb142-28" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb142-29"><a href="#cb142-29" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Log-normal prior for each parameter</span></span>
<span id="cb142-30"><a href="#cb142-30" aria-hidden="true" tabindex="-1"></a>    <span class="co"># log p(θ) = sum of log-normal densities</span></span>
<span id="cb142-31"><a href="#cb142-31" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> jnp.<span class="bu">sum</span>(lognorm.logpdf(params, s<span class="op">=</span><span class="fl">1.0</span>, scale<span class="op">=</span>np.exp(<span class="dv">0</span>)))</span>
<span id="cb142-32"><a href="#cb142-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb142-33"><a href="#cb142-33" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> log_posterior(params, times):</span>
<span id="cb142-34"><a href="#cb142-34" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb142-35"><a href="#cb142-35" aria-hidden="true" tabindex="-1"></a><span class="co">    Log-posterior = log-likelihood + log-prior</span></span>
<span id="cb142-36"><a href="#cb142-36" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb142-37"><a href="#cb142-37" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> log_likelihood(params, times) <span class="op">+</span> log_prior(params)</span>
<span id="cb142-38"><a href="#cb142-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb142-39"><a href="#cb142-39" aria-hidden="true" tabindex="-1"></a><span class="co"># Test the log-posterior function</span></span>
<span id="cb142-40"><a href="#cb142-40" aria-hidden="true" tabindex="-1"></a>test_params <span class="op">=</span> jnp.array([<span class="fl">1.0</span>, <span class="fl">2.0</span>, <span class="fl">4.0</span>])</span>
<span id="cb142-41"><a href="#cb142-41" aria-hidden="true" tabindex="-1"></a>test_times <span class="op">=</span> jnp.array(observed_times)</span>
<span id="cb142-42"><a href="#cb142-42" aria-hidden="true" tabindex="-1"></a>lp <span class="op">=</span> log_posterior(test_params, test_times)</span>
<span id="cb142-43"><a href="#cb142-43" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss">Log-posterior at test parameters: </span><span class="sc">{</span>lp<span class="sc">:.4f}</span><span class="ss">"</span>)</span>
<span id="cb142-44"><a href="#cb142-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb142-45"><a href="#cb142-45" aria-hidden="true" tabindex="-1"></a><span class="co"># Compute gradient using JAX automatic differentiation</span></span>
<span id="cb142-46"><a href="#cb142-46" aria-hidden="true" tabindex="-1"></a>grad_log_posterior <span class="op">=</span> jax.grad(log_posterior, argnums<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb142-47"><a href="#cb142-47" aria-hidden="true" tabindex="-1"></a>gradient <span class="op">=</span> grad_log_posterior(test_params, test_times)</span>
<span id="cb142-48"><a href="#cb142-48" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Gradient: </span><span class="sc">{</span>gradient<span class="sc">}</span><span class="ss">"</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p>With the log-posterior and its gradient defined, we can now implement SVGD. The algorithm maintains a set of particles (each a parameter vector) and updates them iteratively. Each update involves: (1) computing the gradient of the log-posterior for each particle, (2) computing kernel-weighted interactions between particles, and (3) taking a step that combines the gradient information with the particle interactions. The kernel typically used is the RBF (radial basis function) kernel, which gives stronger interactions between nearby particles.</p>
<p>The update rule for each particle is: θᵢ ← θᵢ + ε × φ(θᵢ), where φ(θᵢ) is the SVGD direction combining gradients and kernel interactions, and ε is a step size. The beauty of SVGD is that this update can be performed in parallel for all particles—each particle’s update depends on all other particles’ current positions, but not on their updates, so we can update all particles simultaneously. This is where distributed computing becomes powerful: we can distribute particles across many machines.</p>
<div id="cell-201" class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb143"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb143-1"><a href="#cb143-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Implement SVGD</span></span>
<span id="cb143-2"><a href="#cb143-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> rbf_kernel(x, y, h<span class="op">=-</span><span class="dv">1</span>):</span>
<span id="cb143-3"><a href="#cb143-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb143-4"><a href="#cb143-4" aria-hidden="true" tabindex="-1"></a><span class="co">    RBF (Gaussian) kernel: k(x,y) = exp(-||x-y||²/(2h²))</span></span>
<span id="cb143-5"><a href="#cb143-5" aria-hidden="true" tabindex="-1"></a><span class="co">    If h=-1, use median heuristic: h² = median(pairwise distances) / log(n_particles)</span></span>
<span id="cb143-6"><a href="#cb143-6" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb143-7"><a href="#cb143-7" aria-hidden="true" tabindex="-1"></a>    diff <span class="op">=</span> x[:, <span class="va">None</span>, :] <span class="op">-</span> y[<span class="va">None</span>, :, :]  <span class="co"># (n_particles, n_particles, n_params)</span></span>
<span id="cb143-8"><a href="#cb143-8" aria-hidden="true" tabindex="-1"></a>    pairwise_dists <span class="op">=</span> jnp.<span class="bu">sum</span>(diff<span class="op">**</span><span class="dv">2</span>, axis<span class="op">=</span><span class="dv">2</span>)  <span class="co"># (n_particles, n_particles)</span></span>
<span id="cb143-9"><a href="#cb143-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb143-10"><a href="#cb143-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> h <span class="op">&lt;</span> <span class="dv">0</span>:  <span class="co"># Median heuristic</span></span>
<span id="cb143-11"><a href="#cb143-11" aria-hidden="true" tabindex="-1"></a>        h <span class="op">=</span> jnp.median(pairwise_dists)</span>
<span id="cb143-12"><a href="#cb143-12" aria-hidden="true" tabindex="-1"></a>        h <span class="op">=</span> jnp.sqrt(<span class="fl">0.5</span> <span class="op">*</span> h <span class="op">/</span> jnp.log(x.shape[<span class="dv">0</span>] <span class="op">+</span> <span class="dv">1</span>))</span>
<span id="cb143-13"><a href="#cb143-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb143-14"><a href="#cb143-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> jnp.exp(<span class="op">-</span>pairwise_dists <span class="op">/</span> (<span class="dv">2</span> <span class="op">*</span> h<span class="op">**</span><span class="dv">2</span>)), h</span>
<span id="cb143-15"><a href="#cb143-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb143-16"><a href="#cb143-16" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> svgd_update(particles, times, step_size<span class="op">=</span><span class="fl">1e-3</span>):</span>
<span id="cb143-17"><a href="#cb143-17" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb143-18"><a href="#cb143-18" aria-hidden="true" tabindex="-1"></a><span class="co">    Single SVGD update step.</span></span>
<span id="cb143-19"><a href="#cb143-19" aria-hidden="true" tabindex="-1"></a><span class="co">    particles: (n_particles, n_params)</span></span>
<span id="cb143-20"><a href="#cb143-20" aria-hidden="true" tabindex="-1"></a><span class="co">    returns: updated particles</span></span>
<span id="cb143-21"><a href="#cb143-21" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb143-22"><a href="#cb143-22" aria-hidden="true" tabindex="-1"></a>    n_particles <span class="op">=</span> particles.shape[<span class="dv">0</span>]</span>
<span id="cb143-23"><a href="#cb143-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb143-24"><a href="#cb143-24" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Compute gradient of log-posterior for each particle</span></span>
<span id="cb143-25"><a href="#cb143-25" aria-hidden="true" tabindex="-1"></a>    grad_log_p <span class="op">=</span> jax.vmap(<span class="kw">lambda</span> theta: grad_log_posterior(theta, times))(particles)</span>
<span id="cb143-26"><a href="#cb143-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb143-27"><a href="#cb143-27" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Compute kernel matrix and its gradient</span></span>
<span id="cb143-28"><a href="#cb143-28" aria-hidden="true" tabindex="-1"></a>    kxx, h <span class="op">=</span> rbf_kernel(particles, particles)</span>
<span id="cb143-29"><a href="#cb143-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb143-30"><a href="#cb143-30" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Gradient of kernel</span></span>
<span id="cb143-31"><a href="#cb143-31" aria-hidden="true" tabindex="-1"></a>    diff <span class="op">=</span> particles[:, <span class="va">None</span>, :] <span class="op">-</span> particles[<span class="va">None</span>, :, :]</span>
<span id="cb143-32"><a href="#cb143-32" aria-hidden="true" tabindex="-1"></a>    grad_kxx <span class="op">=</span> <span class="op">-</span>diff <span class="op">/</span> (h<span class="op">**</span><span class="dv">2</span>) <span class="op">*</span> kxx[:, :, <span class="va">None</span>]  <span class="co"># (n_particles, n_particles, n_params)</span></span>
<span id="cb143-33"><a href="#cb143-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb143-34"><a href="#cb143-34" aria-hidden="true" tabindex="-1"></a>    <span class="co"># SVGD direction: φ(θ) = (1/n) Σⱼ [k(θⱼ,θ) ∇log p(θⱼ) + ∇k(θⱼ,θ)]</span></span>
<span id="cb143-35"><a href="#cb143-35" aria-hidden="true" tabindex="-1"></a>    svgd_direction <span class="op">=</span> (jnp.matmul(kxx, grad_log_p) <span class="op">+</span> jnp.<span class="bu">sum</span>(grad_kxx, axis<span class="op">=</span><span class="dv">1</span>)) <span class="op">/</span> n_particles</span>
<span id="cb143-36"><a href="#cb143-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb143-37"><a href="#cb143-37" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Update particles</span></span>
<span id="cb143-38"><a href="#cb143-38" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> particles <span class="op">+</span> step_size <span class="op">*</span> svgd_direction</span>
<span id="cb143-39"><a href="#cb143-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb143-40"><a href="#cb143-40" aria-hidden="true" tabindex="-1"></a><span class="co"># Initialize particles from prior</span></span>
<span id="cb143-41"><a href="#cb143-41" aria-hidden="true" tabindex="-1"></a>n_particles <span class="op">=</span> <span class="dv">20</span></span>
<span id="cb143-42"><a href="#cb143-42" aria-hidden="true" tabindex="-1"></a>np.random.seed(<span class="dv">456</span>)</span>
<span id="cb143-43"><a href="#cb143-43" aria-hidden="true" tabindex="-1"></a><span class="co"># Sample from log-normal prior</span></span>
<span id="cb143-44"><a href="#cb143-44" aria-hidden="true" tabindex="-1"></a>initial_particles <span class="op">=</span> np.random.lognormal(mean<span class="op">=</span><span class="dv">0</span>, sigma<span class="op">=</span><span class="dv">1</span>, size<span class="op">=</span>(n_particles, <span class="dv">3</span>))</span>
<span id="cb143-45"><a href="#cb143-45" aria-hidden="true" tabindex="-1"></a>particles_jax <span class="op">=</span> jnp.array(initial_particles)</span>
<span id="cb143-46"><a href="#cb143-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb143-47"><a href="#cb143-47" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"SVGD Inference with </span><span class="sc">{</span>n_particles<span class="sc">}</span><span class="ss"> particles"</span>)</span>
<span id="cb143-48"><a href="#cb143-48" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Initial particles - shape: </span><span class="sc">{</span>particles_jax<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb143-49"><a href="#cb143-49" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Initial particle means: </span><span class="sc">{</span>jnp<span class="sc">.</span>mean(particles_jax, axis<span class="op">=</span><span class="dv">0</span>)<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb143-50"><a href="#cb143-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb143-51"><a href="#cb143-51" aria-hidden="true" tabindex="-1"></a><span class="co"># Run SVGD for several iterations</span></span>
<span id="cb143-52"><a href="#cb143-52" aria-hidden="true" tabindex="-1"></a>n_iterations <span class="op">=</span> <span class="dv">100</span></span>
<span id="cb143-53"><a href="#cb143-53" aria-hidden="true" tabindex="-1"></a>step_size <span class="op">=</span> <span class="fl">1e-4</span></span>
<span id="cb143-54"><a href="#cb143-54" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb143-55"><a href="#cb143-55" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss">Running </span><span class="sc">{</span>n_iterations<span class="sc">}</span><span class="ss"> SVGD iterations..."</span>)</span>
<span id="cb143-56"><a href="#cb143-56" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n_iterations):</span>
<span id="cb143-57"><a href="#cb143-57" aria-hidden="true" tabindex="-1"></a>    particles_jax <span class="op">=</span> svgd_update(particles_jax, test_times, step_size<span class="op">=</span>step_size)</span>
<span id="cb143-58"><a href="#cb143-58" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (i <span class="op">+</span> <span class="dv">1</span>) <span class="op">%</span> <span class="dv">20</span> <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb143-59"><a href="#cb143-59" aria-hidden="true" tabindex="-1"></a>        particle_mean <span class="op">=</span> jnp.mean(particles_jax, axis<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb143-60"><a href="#cb143-60" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"  Iteration </span><span class="sc">{</span>i<span class="op">+</span><span class="dv">1</span><span class="sc">:3d}</span><span class="ss">: particle mean = </span><span class="sc">{</span>particle_mean<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb143-61"><a href="#cb143-61" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb143-62"><a href="#cb143-62" aria-hidden="true" tabindex="-1"></a><span class="co"># Final results</span></span>
<span id="cb143-63"><a href="#cb143-63" aria-hidden="true" tabindex="-1"></a>final_particles <span class="op">=</span> np.array(particles_jax)</span>
<span id="cb143-64"><a href="#cb143-64" aria-hidden="true" tabindex="-1"></a>posterior_mean <span class="op">=</span> np.mean(final_particles, axis<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb143-65"><a href="#cb143-65" aria-hidden="true" tabindex="-1"></a>posterior_std <span class="op">=</span> np.std(final_particles, axis<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb143-66"><a href="#cb143-66" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb143-67"><a href="#cb143-67" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss">Inference Results:"</span>)</span>
<span id="cb143-68"><a href="#cb143-68" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"  True parameters:      </span><span class="sc">{</span>true_params<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb143-69"><a href="#cb143-69" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"  Posterior mean:       </span><span class="sc">{</span>posterior_mean<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb143-70"><a href="#cb143-70" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"  Posterior std:        </span><span class="sc">{</span>posterior_std<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb143-71"><a href="#cb143-71" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"  Relative error:       </span><span class="sc">{</span>np<span class="sc">.</span><span class="bu">abs</span>(posterior_mean <span class="op">-</span> true_params) <span class="op">/</span> true_params <span class="op">*</span> <span class="dv">100</span><span class="sc">}</span><span class="ss"> %"</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p>The SVGD particles now represent our posterior distribution. Each particle is a plausible set of parameter values given the observed data, and the collection of particles approximates the full posterior. We can use these particles to compute posterior summaries (means, quantiles, credible intervals), make predictions, or perform model checking. The spread of the particles reflects our uncertainty—parameters with wide spread are less constrained by the data, while parameters with narrow spread are well-determined.</p>
<p>This inference workflow showcases the full power of the ptdalgorithms ecosystem. We constructed a complex stochastic model using graph-based state space representation. We parameterized it for efficient exploration of parameter space. We performed symbolic Gaussian elimination to enable ultra-fast repeated evaluation. We integrated with JAX for automatic differentiation and JIT compilation. We implemented a gradient-based inference algorithm (SVGD) that can be parallelized across devices and nodes. And we can scale this entire workflow to much larger problems—more complex models, more observations, more particles—by leveraging distributed computing.</p>
<p>For production inference runs, you would typically use more particles (100-1000), run for more iterations (1000-10000), use adaptive step sizes, monitor convergence diagnostics, and leverage the distributed computing infrastructure we described earlier to parallelize across many nodes. The combination of symbolic elimination (100× faster evaluation), distributed computing (100× more parallel evaluations), and gradient-based inference (100× fewer iterations than MCMC) can easily provide five or six orders of magnitude of speedup compared to naive approaches, transforming intractable problems into routine computations.</p>
</section>
<section id="building-the-state-space-in-c" class="level2">
<h2 class="anchored" data-anchor-id="building-the-state-space-in-c">Building the state space in C</h2>
<p>Very large models can be take a long time to construct. So if you have deloped a model that you need to construct repeatedly, the library allow you to implement the state construction as a stand-alone C/C++ extension available as python module.</p>
<p>The C code building the state space for the rabit model looks like this:</p>
<pre class="{c}"><code>ptdalgorithms::Graph build(int starting_rabbits, float flooding_left, float flooding_right) {

    size_t state_size = 2;
    struct ptd_graph *graph = ptd_graph_create(state_size);
    struct ptd_avl_tree *avl_tree = ptd_avl_tree_create(state_size);
    int *initial_state = (int*)calloc(graph-&gt;state_length, sizeof(*initial_state));
    int *child_state = (int*)calloc(graph-&gt;state_length, sizeof(*initial_state));
    initial_state[0] = starting_rabbits;
    ptd_graph_add_edge(
            graph-&gt;starting_vertex,
            ptd_find_or_create_vertex(graph, avl_tree, initial_state),
            1
    );
    for (size_t k = 1; k &lt; graph-&gt;vertices_length; k++) {
        struct ptd_vertex *vertex = graph-&gt;vertices[k];
        int *state = vertex-&gt;state;
        if (state[0] &gt; 0) {
            memcpy(child_state, vertex-&gt;state, graph-&gt;state_length * sizeof(int));
            child_state[0] -= 1;
            child_state[1] += 1;

            ptd_graph_add_edge(
                    vertex,
                    ptd_find_or_create_vertex(graph, avl_tree, child_state),
                    1
            );
            memcpy(child_state, vertex-&gt;state, graph-&gt;state_length * sizeof(int));
            child_state[0] = 0;
            ptd_graph_add_edge(
                    vertex,
                    ptd_find_or_create_vertex(graph, avl_tree, child_state),
                    flooding_left
            );
        }
        if (state[1] &gt; 0) {
            memcpy(child_state, vertex-&gt;state, graph-&gt;state_length * sizeof(int));
            child_state[1] -= 1;
            child_state[0] += 1;
            ptd_graph_add_edge(
                    vertex,
                    ptd_find_or_create_vertex(graph, avl_tree, child_state),
                    1
            );
            memcpy(child_state, vertex-&gt;state, graph-&gt;state_length * sizeof(int));
            child_state[1] = 0;
            ptd_graph_add_edge(
                    vertex,
                    ptd_find_or_create_vertex(graph, avl_tree, child_state),
                    flooding_right
            );
        }
    }
    free(child_state);
    ptdalgorithms::Graph *result = new ptdalgorithms::Graph(graph, avl_tree);
    return *result;
}

To access the function from python, you need to put it a separate file (`rabbit_state_space.cpp`) with the header and footer shown below:

```{c}
#include &lt;pybind11/pybind11.h&gt;
#include &lt;ptdalgorithms.h&gt;
#include "stdint.h"
#include "stdlib.h"

namespace py = pybind11;
using namespace pybind11::literals;
/*******************************************/


/* Your build function goes here */


/********************************************/
PYBIND11_MODULE(rabbit_state_space, m) {     /* &lt;- NB: the model name must match the file name */
     m.def("build", &amp;build);
}

/*
&lt;%
setup_pybind11(cfg)
%&gt;
*/</code></pre>
<p>You can see the complete code in <a href="rabbit_state_space.cpp">rabbit_state_space.cpp</a>.</p>
<p>Then all you need to do is install cppimport</p>
<div id="cell-211" class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb145"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb145-1"><a href="#cb145-1" aria-hidden="true" tabindex="-1"></a><span class="op">!</span> pip install cppimport</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<div class="ansi-escaped-output">
<pre>Collecting cppimport

  Downloading cppimport-22.8.2.tar.gz (26 kB)

  Installing build dependencies ... done

  Getting requirements to build wheel ... done

  Preparing metadata (pyproject.toml) ... done

Collecting mako (from cppimport)

  Downloading mako-1.3.10-py3-none-any.whl.metadata (2.9 kB)

Requirement already satisfied: pybind11 in /workspaces/PtDAlgorithms/.pixi/envs/default/lib/python3.11/site-packages (from cppimport) (3.0.1)

Requirement already satisfied: filelock in /workspaces/PtDAlgorithms/.pixi/envs/default/lib/python3.11/site-packages (from cppimport) (3.18.0)

Requirement already satisfied: MarkupSafe&gt;=0.9.2 in /workspaces/PtDAlgorithms/.pixi/envs/default/lib/python3.11/site-packages (from mako-&gt;cppimport) (3.0.2)

Downloading mako-1.3.10-py3-none-any.whl (78 kB)

Building wheels for collected packages: cppimport

  Building wheel for cppimport (pyproject.toml) ... done

  Created wheel for cppimport: filename=cppimport-22.8.2-py3-none-any.whl size=17789 sha256=5b9f7012934113dfe24790acebd6068143b2e838c83b84c779ecc582efb1e453

  Stored in directory: /home/vscode/.cache/pip/wheels/1b/74/c3/da98286e4d715a502b9ecbc9d439406597959debe0a0d0a079

Successfully built cppimport

Installing collected packages: mako, cppimport

   <span class="ansi-bright-black-fg">━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━</span> <span class="ansi-green-fg">2/2</span> [cppimport]/2 [cppimport]

Successfully installed cppimport-22.8.2 mako-1.3.10
</pre>
</div>
</div>
</div>
<p>and then run this code to import your build function.</p>
<div id="cell-213" class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb146"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb146-1"><a href="#cb146-1" aria-hidden="true" tabindex="-1"></a><span class="co"># import ptdalgorithms</span></span>
<span id="cb146-2"><a href="#cb146-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> cppimport.import_hook</span>
<span id="cb146-3"><a href="#cb146-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> rabbit_state_space <span class="co"># this will pause for a moment to compile the module</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-error">
<div class="ansi-escaped-output">
<pre><span class="ansi-red-fg">---------------------------------------------------------------------------</span>
<span class="ansi-red-fg">ModuleNotFoundError</span>                       Traceback (most recent call last)
<span class="ansi-cyan-fg">Cell</span><span class="ansi-cyan-fg"> </span><span class="ansi-green-fg">In[101]</span><span class="ansi-green-fg">, line 3</span>
<span class="ansi-green-fg">      1</span> <span style="font-style:italic;color:rgb(95,135,135)"># import ptdalgorithms</span>
<span class="ansi-green-fg">      2</span> <span style="font-weight:bold;color:rgb(0,135,0)">import</span><span style="color:rgb(188,188,188)"> </span><span class="ansi-blue-fg ansi-bold">cppimport</span><span class="ansi-blue-fg ansi-bold">.</span><span class="ansi-blue-fg ansi-bold">import_hook</span>
<span class="ansi-green-fg">----&gt; </span><span class="ansi-green-fg">3</span> <span style="font-weight:bold;color:rgb(0,135,0)">import</span><span style="color:rgb(188,188,188)"> </span><span class="ansi-blue-fg ansi-bold">rabbit_state_space</span> <span style="font-style:italic;color:rgb(95,135,135)"># this will pause for a moment to compile the module</span>

<span class="ansi-red-fg">ModuleNotFoundError</span>: No module named 'rabbit_state_space'</pre>
</div>
</div>
</div>
<p>Then you can use it to construct your graph like this:</p>
<div id="cell-215" class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb147"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb147-1"><a href="#cb147-1" aria-hidden="true" tabindex="-1"></a>graph <span class="op">=</span> ptd.Graph(rabbit_state_space.build(<span class="dv">2</span>, <span class="dv">2</span>, <span class="dv">4</span>))</span>
<span id="cb147-2"><a href="#cb147-2" aria-hidden="true" tabindex="-1"></a>graph.plot()</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/munch-group\.github\.io\/PtDAlgorithms\/");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="../../pages/getting_started.html" class="pagination-link" aria-label="Getting Started">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text">Getting Started</span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="../../pages/modelling/state_space_construction.html" class="pagination-link" aria-label="State space">
        <span class="nav-page-text">State space</span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->
<script>var lightboxQuarto = GLightbox({"closeEffect":"zoom","descPosition":"bottom","loop":false,"openEffect":"zoom","selector":".lightbox"});
(function() {
  let previousOnload = window.onload;
  window.onload = () => {
    if (previousOnload) {
      previousOnload();
    }
    lightboxQuarto.on('slide_before_load', (data) => {
      const { slideIndex, slideNode, slideConfig, player, trigger } = data;
      const href = trigger.getAttribute('href');
      if (href !== null) {
        const imgEl = window.document.querySelector(`a[href="${href}"] img`);
        if (imgEl !== null) {
          const srcAttr = imgEl.getAttribute("src");
          if (srcAttr && srcAttr.startsWith("data:")) {
            slideConfig.href = srcAttr;
          }
        }
      } 
    });
  
    lightboxQuarto.on('slide_after_load', (data) => {
      const { slideIndex, slideNode, slideConfig, player, trigger } = data;
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(slideNode);
      }
    });
  
  };
  
})();
          </script>




</body></html>