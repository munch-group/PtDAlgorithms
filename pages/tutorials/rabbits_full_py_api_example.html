<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.25">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Rabbits Islands - Full API</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" integrity="sha384-ZvpUoO/+PpLXR1lu4jmpXWu80pZlYUAfxl5NsBMWOEPSjUn/6Z/hRTt8+pR6L4N2" crossorigin="anonymous"></script><script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../../pages/tutorials/coalescent_full_py_api_example.html" rel="next">
<link href="../../pages/getting_started.html" rel="prev">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-7b89279ff1a6dce999919e0e67d4d9ec.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-69e0a66ffe0fe44e3bab073e7fd1e693.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script src="../../site_libs/quarto-contrib/glightbox/glightbox.min.js"></script>
<link href="../../site_libs/quarto-contrib/glightbox/glightbox.min.css" rel="stylesheet">
<link href="../../site_libs/quarto-contrib/glightbox/lightbox.css" rel="stylesheet">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script src="https://cdn.jsdelivr.net/npm/requirejs@2.3.6/require.min.js" integrity="sha384-c9c+LnTbwQ3aujuU7ULEPVvgLs+Fn6fJUvIGTsuu1ZcCf11fiEubah0ttpca4ntM sha384-6V1/AdqZRWk1KAlWbKBlGhN7VG4iE/yAZcO6NZPMF8od0vukrvr0tg4qY6NSrItx" crossorigin="anonymous"></script>

<script type="application/javascript">define('jquery', [],function() {return window.jQuery;})</script>


<link rel="stylesheet" href="../../api/_styles-quartodoc.css">
<link rel="stylesheet" href="../../numpy.css">
</head>

<body class="nav-sidebar floating nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="../../index.html" class="navbar-brand navbar-brand-logo">
    <img src="../../logo.png" alt="Phasic" class="navbar-logo light-content">
    <img src="../../logo.png" alt="Phasic" class="navbar-logo dark-content">
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../pages/index.html"> 
<span class="menu-text">Documentation</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../api/"> 
<span class="menu-text">Python API reference</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../r_api/"> 
<span class="menu-text">R API reference</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../c_api/"> 
<span class="menu-text">C API reference</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/munch-group/ptdalgorithms/"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item">Tutorials</li><li class="breadcrumb-item"><a href="../../pages/tutorials/rabbits_full_py_api_example.html">Rabbits Islands - Full API</a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header sidebar-header-stacked">
      <a href="../../index.html" class="sidebar-logo-link">
      </a>
      </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../pages/getting_started.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Getting Started</span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true">
 <span class="menu-text">Tutorials</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
 <span class="menu-text">pages/background/tldr.qmd</span>
  </li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../pages/tutorials/rabbits_full_py_api_example.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text">Rabbits Islands - Full API</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../pages/tutorials/coalescent_full_py_api_example.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Coalescent - Full API</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../pages/tutorials/state_space_construction.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Building models</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" role="navigation" aria-expanded="true">
 <span class="menu-text">Bayesian inference</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-2" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../pages/svgd/svgd.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">SVGD Inference</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../pages/svgd/svgd_with_symbolic_dag.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">SVGD Inference with Symbolic DAG Optimization</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" role="navigation" aria-expanded="true">
 <span class="menu-text">Distributed Computing</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-3" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../pages/distributed/distributed_computing_complete_guide.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Distributed Computing with PtDAlgorithms - Complete Guide</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../pages/distributed/slurm_cluster_setup.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">SLURM Cluster Setup and Configuration</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../pages/distributed/cpu_monitoring.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">CPU monitoring</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-4" role="navigation" aria-expanded="true">
 <span class="menu-text">State space patterns</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-4" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-4" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../pages/modelling/state_lumping.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">State lumping</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../pages/modelling/laplace.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Laplace transform</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../pages/modelling/epochs.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Epochs</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../pages/modelling/joint_prob.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Joint probabilities</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-5" role="navigation" aria-expanded="true">
 <span class="menu-text">Popgen examples</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-5" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-5" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
 <span class="menu-text">pages/modelling/coalescent-jointprob.ipynb</span>
  </li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../pages/popgen/isolation_migration.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">isolation_migration.html</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../pages/popgen/two-island-two-locus-arg.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Two Island Two Locus Argument</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-6" role="navigation" aria-expanded="true">
 <span class="menu-text">Phase-type distributions</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-6" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-6" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../pages/background/math_and_alg.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Math and Algorithms</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../pages/background/symbolic_gauss_elimination.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Symbolic Graph Elimination for Efficient Parameterized Phase-Type Distributions</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-7" role="navigation" aria-expanded="true">
 <span class="menu-text">Devel</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-7" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-7" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../pages/devel/architecture.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Library Architecture</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="https://github.com/munch-group/ptdalgorithms/issues" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Issue Tracker</span></a>
  </div>
</li>
      </ul>
  </li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#state-space-construction" id="toc-state-space-construction" class="nav-link active" data-scroll-target="#state-space-construction">State-space construction</a>
  <ul class="collapse">
  <li><a href="#matrix-interface" id="toc-matrix-interface" class="nav-link" data-scroll-target="#matrix-interface">Matrix interface</a></li>
  <li><a href="#continuous-phase-type-distribution" id="toc-continuous-phase-type-distribution" class="nav-link" data-scroll-target="#continuous-phase-type-distribution">Continuous phase-type distribution</a></li>
  <li><a href="#rewards" id="toc-rewards" class="nav-link" data-scroll-target="#rewards">Rewards</a></li>
  </ul></li>
  <li><a href="#random-sampling" id="toc-random-sampling" class="nav-link" data-scroll-target="#random-sampling">Random sampling</a>
  <ul class="collapse">
  <li><a href="#discrete-phase-type-distributions" id="toc-discrete-phase-type-distributions" class="nav-link" data-scroll-target="#discrete-phase-type-distributions">Discrete phase-type distributions</a></li>
  </ul></li>
  <li><a href="#multivariate-phase-type-distributions" id="toc-multivariate-phase-type-distributions" class="nav-link" data-scroll-target="#multivariate-phase-type-distributions">Multivariate phase-type distributions</a></li>
  <li><a href="#parameterized-edges" id="toc-parameterized-edges" class="nav-link" data-scroll-target="#parameterized-edges">Parameterized edges</a></li>
  <li><a href="#precomputing-trace-for-dag" id="toc-precomputing-trace-for-dag" class="nav-link" data-scroll-target="#precomputing-trace-for-dag">Precomputing trace for DAG</a></li>
  <li><a href="#caching-dags" id="toc-caching-dags" class="nav-link" data-scroll-target="#caching-dags">Caching DAGs</a>
  <ul class="collapse">
  <li><a href="#across-sessions" id="toc-across-sessions" class="nav-link" data-scroll-target="#across-sessions">Across Sessions</a></li>
  <li><a href="#cache-management-and-collaboration" id="toc-cache-management-and-collaboration" class="nav-link" data-scroll-target="#cache-management-and-collaboration">Cache Management and Collaboration</a></li>
  </ul></li>
  <li><a href="#state-space-modelling" id="toc-state-space-modelling" class="nav-link" data-scroll-target="#state-space-modelling">State space modelling</a>
  <ul class="collapse">
  <li><a href="#time-inhomogeneity" id="toc-time-inhomogeneity" class="nav-link" data-scroll-target="#time-inhomogeneity">Time inhomogeneity</a></li>
  <li><a href="#modelling-epochs-in-state-space" id="toc-modelling-epochs-in-state-space" class="nav-link" data-scroll-target="#modelling-epochs-in-state-space">Modelling epochs in state space</a></li>
  <li><a href="#laplace-transform" id="toc-laplace-transform" class="nav-link" data-scroll-target="#laplace-transform">Laplace transform</a></li>
  <li><a href="#joint-probability" id="toc-joint-probability" class="nav-link" data-scroll-target="#joint-probability">Joint probability</a></li>
  </ul></li>
  <li><a href="#building-the-state-space-in-c" id="toc-building-the-state-space-in-c" class="nav-link" data-scroll-target="#building-the-state-space-in-c">Building the state space in C</a></li>
  <li><a href="#inference" id="toc-inference" class="nav-link" data-scroll-target="#inference">Inference</a>
  <ul class="collapse">
  <li><a href="#bayesian-inference-with-svgd-stein-variational-gradient-descent" id="toc-bayesian-inference-with-svgd-stein-variational-gradient-descent" class="nav-link" data-scroll-target="#bayesian-inference-with-svgd-stein-variational-gradient-descent">Bayesian Inference with SVGD (Stein Variational Gradient Descent)</a></li>
  <li><a href="#distributed-computing" id="toc-distributed-computing" class="nav-link" data-scroll-target="#distributed-computing">Distributed Computing</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default"><nav class="quarto-page-breadcrumbs quarto-title-breadcrumbs d-none d-lg-block" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item">Tutorials</li><li class="breadcrumb-item"><a href="../../pages/tutorials/rabbits_full_py_api_example.html">Rabbits Islands - Full API</a></li></ol></nav>
<div class="quarto-title">
<h1 class="title">Rabbits Islands - Full API</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p>This comprehensive tutorial explores the complete Python API of the ptdalgorithms library, a high-performance computational framework for working with phase-type distributions. At its core, the library implements sophisticated graph-based algorithms published in peer-reviewed literature, offering performance improvements of several orders of magnitude compared to traditional matrix-based approaches that have dominated the field for decades. The implementation leverages C for computational efficiency, with carefully designed bindings to Python through C++ and pybind11, ensuring that Python users can access near-native performance without sacrificing the convenience and flexibility of high-level scripting.</p>
<p>Throughout this tutorial, we will construct increasingly sophisticated models using a simple but illustrative example: rabbits living on two islands that can jump between islands and face periodic flooding events. This seemingly simple scenario will allow us to explore the full richness of the library’s capabilities, from basic state space construction and moment calculations to advanced features like reward transformations, multivariate distributions, parameterized models, symbolic elimination for ultra-fast parameter sweeps, distributed computing across SLURM clusters, and Bayesian inference using Stein Variational Gradient Descent (SVGD).</p>
<p>The tutorial begins with fundamental operations—constructing state spaces, computing expectations and variances, evaluating distribution functions—and progressively builds toward advanced topics. We will see how to work with both continuous phase-type distributions (modeling time until absorption) and discrete phase-type distributions (modeling the number of transitions before absorption). We will explore rewards, which allow us to compute accumulated quantities along paths through the state space, and multivariate extensions that capture joint distributions of multiple quantities. We will learn how to parameterize edge weights, enabling efficient exploration of parameter space, and how symbolic elimination can accelerate this exploration by orders of magnitude.</p>
<p>In the advanced sections, we will discover how to leverage distributed computing infrastructure, scaling our computations from a single machine to hundreds of nodes on a SLURM cluster. We will see how the library integrates seamlessly with JAX, enabling automatic differentiation and GPU acceleration. Finally, we will apply these tools to Bayesian inference problems, using SVGD to estimate model parameters from observed data—a workflow that combines graph construction, symbolic elimination, distributed computing, and gradient-based optimization into a unified, high-performance pipeline.</p>
<p>By the end of this tutorial, you will have mastered not just the mechanics of the API, but the underlying concepts and workflows that make ptdalgorithms a powerful tool for probabilistic modeling, statistical inference, and computational biology.</p>
<div id="cell-2" class="cell" data-execution_count="1">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co"># %load_ext autoreload</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="co"># %autoreload 2</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<div id="cell-3" class="cell" data-execution_count="2">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>np.random.seed(<span class="dv">42</span>)</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> seaborn <span class="im">as</span> sns</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> ptdalgorithms <span class="im">import</span> Graph, set_theme</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>config InlineBackend.figure_format <span class="op">=</span> <span class="st">'retina'</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a><span class="co"># plt.style.use('dark_background')</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a><span class="co"># import matplotlib</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a><span class="co"># matplotlib.rcParams['axes.facecolor'] = '#1F1F1F'</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a><span class="co"># matplotlib.rcParams['figure.facecolor'] = '#1F1F1F'</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a><span class="co">#plt.rcParams.update({'figure.facecolor': '#1F1F1F', 'axes.facecolor': '#1F1F1F'})</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>set_theme(<span class="st">'light'</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<section id="state-space-construction" class="level1">
<h1>State-space construction</h1>
<div id="cell-5" class="cell" data-execution_count="3">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> c(<span class="op">*</span>args):</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    elem <span class="op">=</span> []</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> arg <span class="kw">in</span> args:</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">hasattr</span>(arg, <span class="st">'__len__'</span>) <span class="kw">and</span> <span class="bu">len</span>(arg) <span class="op">&gt;</span> <span class="dv">1</span>:</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>            elem.extend(arg)</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>            elem.append(arg)</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.array(elem)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<div id="cell-6" class="cell" data-execution_count="4">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> print_states(vertex):</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(vertex.state())</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> edge <span class="kw">in</span> vertex.edges():</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="st">" "</span>, edge.weight() , <span class="st">"-&gt;"</span>, edge.to().state())    </span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p>This phase-type distribution models the time until all rabits have died We can find the expectation, variance, moments</p>
<div id="cell-8" class="cell" data-execution_count="5">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> construct_rabbit_graph(nr_rabbits, flood_left, flood_right):</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    <span class="co"># we represent the vector as two integers, the number of </span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>    <span class="co"># rabbits on the left and right island</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>    state_vector_length <span class="op">=</span> <span class="dv">2</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>    graph <span class="op">=</span> Graph(state_vector_length)</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>    <span class="co"># the initial state is the only starting state, with probability 1</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>    initial_state <span class="op">=</span> [nr_rabbits, <span class="dv">0</span>]</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>    vertex <span class="op">=</span> graph.find_or_create_vertex(initial_state)</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>    graph.starting_vertex().add_edge(vertex, <span class="dv">1</span>)</span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>    index <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>    <span class="co"># iterate over all unvisited vertices</span></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> index <span class="op">&lt;</span> graph.vertices_length():</span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>        vertex <span class="op">=</span> graph.vertex_at(index)</span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a>        state <span class="op">=</span> vertex.state()</span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> state[<span class="dv">0</span>] <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a>            <span class="co"># rabbit jump left to right</span></span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a>            child_state <span class="op">=</span> [state[<span class="dv">0</span>] <span class="op">-</span> <span class="dv">1</span>, state[<span class="dv">1</span>] <span class="op">+</span> <span class="dv">1</span>]</span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a>            vertex.add_edge(</span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true" tabindex="-1"></a>                graph.find_or_create_vertex(child_state),</span>
<span id="cb5-24"><a href="#cb5-24" aria-hidden="true" tabindex="-1"></a>                weight<span class="op">=</span><span class="dv">1</span></span>
<span id="cb5-25"><a href="#cb5-25" aria-hidden="true" tabindex="-1"></a>            )</span>
<span id="cb5-26"><a href="#cb5-26" aria-hidden="true" tabindex="-1"></a>            <span class="co"># left island flooding</span></span>
<span id="cb5-27"><a href="#cb5-27" aria-hidden="true" tabindex="-1"></a>            child_state <span class="op">=</span> [<span class="dv">0</span>, state[<span class="dv">1</span>]]</span>
<span id="cb5-28"><a href="#cb5-28" aria-hidden="true" tabindex="-1"></a>            vertex.add_edge(</span>
<span id="cb5-29"><a href="#cb5-29" aria-hidden="true" tabindex="-1"></a>                graph.find_or_create_vertex(child_state), </span>
<span id="cb5-30"><a href="#cb5-30" aria-hidden="true" tabindex="-1"></a>                weight<span class="op">=</span>flood_left</span>
<span id="cb5-31"><a href="#cb5-31" aria-hidden="true" tabindex="-1"></a>            )</span>
<span id="cb5-32"><a href="#cb5-32" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> state[<span class="dv">1</span>] <span class="op">&gt;</span> <span class="dv">0</span>:   </span>
<span id="cb5-33"><a href="#cb5-33" aria-hidden="true" tabindex="-1"></a>            child_state <span class="op">=</span> [state[<span class="dv">0</span>] <span class="op">+</span> <span class="dv">1</span>, state[<span class="dv">1</span>] <span class="op">-</span> <span class="dv">1</span>]</span>
<span id="cb5-34"><a href="#cb5-34" aria-hidden="true" tabindex="-1"></a>            vertex.add_edge(</span>
<span id="cb5-35"><a href="#cb5-35" aria-hidden="true" tabindex="-1"></a>                graph.find_or_create_vertex(child_state),</span>
<span id="cb5-36"><a href="#cb5-36" aria-hidden="true" tabindex="-1"></a>                weight<span class="op">=</span><span class="dv">1</span></span>
<span id="cb5-37"><a href="#cb5-37" aria-hidden="true" tabindex="-1"></a>            )</span>
<span id="cb5-38"><a href="#cb5-38" aria-hidden="true" tabindex="-1"></a>            <span class="co"># right island flooding</span></span>
<span id="cb5-39"><a href="#cb5-39" aria-hidden="true" tabindex="-1"></a>            child_state <span class="op">=</span> [state[<span class="dv">0</span>], <span class="dv">0</span>]</span>
<span id="cb5-40"><a href="#cb5-40" aria-hidden="true" tabindex="-1"></a>            vertex.add_edge(</span>
<span id="cb5-41"><a href="#cb5-41" aria-hidden="true" tabindex="-1"></a>                graph.find_or_create_vertex(child_state), </span>
<span id="cb5-42"><a href="#cb5-42" aria-hidden="true" tabindex="-1"></a>                weight<span class="op">=</span>flood_right</span>
<span id="cb5-43"><a href="#cb5-43" aria-hidden="true" tabindex="-1"></a>            )</span>
<span id="cb5-44"><a href="#cb5-44" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb5-45"><a href="#cb5-45" aria-hidden="true" tabindex="-1"></a>        index <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb5-46"><a href="#cb5-46" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> graph</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<div id="cell-9" class="cell" data-execution_count="6">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>graph <span class="op">=</span> construct_rabbit_graph(<span class="dv">2</span>, <span class="dv">2</span>, <span class="dv">4</span>)        </span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>graph.states()</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display" data-execution_count="6">
<pre><code>array([[0, 0],
       [2, 0],
       [1, 1],
       [0, 0],
       [0, 2],
       [0, 1],
       [1, 0]], dtype=int32)</code></pre>
</div>
</div>
<p>You can plot the graph for visual inspection:</p>
<div id="cell-11" class="cell" data-execution_count="7">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>graph.plot()</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display" data-execution_count="7">
<div>
<figure class="figure">
<p><a href="rabbits_full_py_api_example_files/figure-html/cell-8-output-1.svg" class="lightbox" data-gallery="quarto-lightbox-gallery-1"><img src="rabbits_full_py_api_example_files/figure-html/cell-8-output-1.svg" class="img-fluid figure-img"></a></p>
</figure>
</div>
</div>
</div>
<p>and group, states by some property, by supplying a lambda function for the <code>subgraphfun</code> keyword argument:</p>
<div id="cell-13" class="cell" data-execution_count="8">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>graph.plot(subgraphfun<span class="op">=</span><span class="kw">lambda</span> state: <span class="ss">f"#rabbits: </span><span class="sc">{</span><span class="bu">sum</span>(state)<span class="sc">}</span><span class="ss">"</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display" data-execution_count="8">
<div>
<figure class="figure">
<p><a href="rabbits_full_py_api_example_files/figure-html/cell-9-output-1.svg" class="lightbox" data-gallery="quarto-lightbox-gallery-2"><img src="rabbits_full_py_api_example_files/figure-html/cell-9-output-1.svg" class="img-fluid figure-img"></a></p>
</figure>
</div>
</div>
</div>
<p>In an abbreviated version using the aliases <code>ae</code> and <code>focv</code> for <code>add_edge</code> and <code>find_and_create_vertex</code></p>
<div id="cell-15" class="cell" data-execution_count="9">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>nr_rabbits, flood_left, flood_right <span class="op">=</span> <span class="dv">2</span>, <span class="dv">2</span>, <span class="dv">4</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>graph <span class="op">=</span> Graph(<span class="dv">2</span>)</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>graph.starting_vertex().add_edge(graph.focv(c(nr_rabbits, <span class="dv">0</span>)), <span class="dv">1</span>)</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>i <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> i <span class="op">&lt;</span> graph.vertices_length():</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>    v <span class="op">=</span> graph.vertex_at(i)</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>    st <span class="op">=</span> v.state()</span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> st[<span class="dv">0</span>] <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>        v.ae(graph.focv([st[<span class="dv">0</span>]<span class="op">-</span><span class="dv">1</span>, st[<span class="dv">1</span>]<span class="op">+</span><span class="dv">1</span>]), <span class="dv">1</span>)</span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>        v.ae(graph.focv([<span class="dv">0</span>, st[<span class="dv">1</span>]]), flood_left)</span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> st[<span class="dv">1</span>] <span class="op">&gt;</span> <span class="dv">0</span>:   </span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>        v.ae(graph.focv([st[<span class="dv">0</span>]<span class="op">+</span><span class="dv">1</span>, st[<span class="dv">1</span>]<span class="op">-</span><span class="dv">1</span>]), <span class="dv">1</span>)</span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a>        v.ae(graph.focv([st[<span class="dv">0</span>], <span class="dv">0</span>]), flood_right)</span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a>    i <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a><span class="co">#graph.states()</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p>You can skip some of the boilerplate code by passing a callback function and an initial state to <code>Graph</code>. The call back function has the signature <code>callback(List[int]) -&gt; List[Dict]</code>. It takes a list argument specifying a state and returns a list of dictionaries each specifying a child state and an edge weight: <code>{'state': [0, 1], 'weight': 0.4}</code>. This approach is slower and is intended mainly for speed up model development and exploration, and to reduce the amount of code needed to represent many models.</p>
<p>To create a callback function, just think of rules of your model and ask yourself: “Given some state, what are the allowed transitions to other states and with what rates to these transititons occur?”. Make a small dictionary for each such transition with the child state and rate (weight) and return them as a list. Here is an example. If the current state is “two rabbits on the left island” (<code>[2, 0]</code>), the reachable states are: “one rabbit on each island” (<code>[1, 1]</code>) if one rabbit jumps and and “no rabbits” (<code>[0, 0]</code>) if the island is flodded. The callback function should in that case produce the mapping:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb11"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>[<span class="dv">2</span>, <span class="dv">0</span>] <span class="op">-&gt;</span> [{<span class="st">'state'</span>: [<span class="dv">1</span>, <span class="dv">1</span>], <span class="st">'weight'</span>: <span class="dv">1</span>, }, {<span class="st">'state'</span>: [<span class="dv">0</span>, <span class="dv">0</span>], <span class="st">'weight'</span>: flood_left}]</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Here is what the callback function looks like for the rabbit model:</p>
<div id="cell-17" class="cell" data-execution_count="10">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb12"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> rabbit_islands(state):</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>    children <span class="op">=</span> []</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> state[<span class="dv">0</span>] <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>        children.append({<span class="st">'state'</span>: [state[<span class="dv">0</span>]<span class="op">-</span><span class="dv">1</span>, state[<span class="dv">1</span>]<span class="op">+</span><span class="dv">1</span>], <span class="st">'weight'</span>: <span class="dv">1</span>})</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>        children.append({<span class="st">'state'</span>: [<span class="dv">0</span>,          state[<span class="dv">1</span>]  ], <span class="st">'weight'</span>: flood_left})</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> state[<span class="dv">1</span>] <span class="op">&gt;</span> <span class="dv">0</span>:   </span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>        children.append({<span class="st">'state'</span>: [state[<span class="dv">0</span>]<span class="op">+</span><span class="dv">1</span>, state[<span class="dv">1</span>]<span class="op">-</span><span class="dv">1</span>], <span class="st">'weight'</span>: <span class="dv">1</span>})</span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>        children.append({<span class="st">'state'</span>: [state[<span class="dv">0</span>],   <span class="dv">0</span>         ], <span class="st">'weight'</span>: flood_right})</span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> children</span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>initial_state <span class="op">=</span> [nr_rabbits, <span class="dv">0</span>]    </span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p>Notice that the usual scoping rules apply to the callback functions: the variables defined outside the function <code>flood_left</code> and <code>flood_right</code> are accessible to the function as for any Python function.</p>
<section id="matrix-interface" class="level2">
<h2 class="anchored" data-anchor-id="matrix-interface">Matrix interface</h2>
<p>To allow imbedding in a matrix based workflow, a matrix-based representation of the phase-type distribution can be extracted from the graph. Note that the indices in the matrix representation do not correspond to vertex indices in the graph.</p>
<div id="cell-21" class="cell" data-execution_count="11">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb13"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>mats <span class="op">=</span> graph.as_matrices()</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Initial probability vector:"</span>)</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(mats.ipv)</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Subintensity matrix:"</span>)</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(mats.sim)</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"States:"</span>)</span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(mats.states)</span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Indicies:"</span>)</span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(mats.indices)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>Initial probability vector:
[0. 0. 1. 0. 0.]
Subintensity matrix:
[[-5.  1.  0.  0.  0.]
 [ 1. -8.  1.  4.  2.]
 [ 0.  1. -3.  0.  0.]
 [ 0.  0.  0. -3.  1.]
 [ 0.  0.  0.  1. -5.]]
States:
[[0 2]
 [1 1]
 [2 0]
 [1 0]
 [0 1]]
Indicies:
[5 3 2 7 6]</code></pre>
</div>
</div>
<p>Although computationally inefficient, the graph can also be constructed from an initial probability vector and a subintensity matrix:</p>
<div id="cell-23" class="cell" data-execution_count="12">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb15"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>graph <span class="op">=</span> Graph.from_matrices(mats.ipv, mats.sim, mats.states)</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>graph.plot()</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display" data-execution_count="12">
<div>
<figure class="figure">
<p><a href="rabbits_full_py_api_example_files/figure-html/cell-13-output-1.svg" class="lightbox" data-gallery="quarto-lightbox-gallery-3"><img src="rabbits_full_py_api_example_files/figure-html/cell-13-output-1.svg" class="img-fluid figure-img"></a></p>
</figure>
</div>
</div>
</div>
<p>If the state argument is not provided, matrix indices are used as matrix states:</p>
<div id="cell-25" class="cell" data-execution_count="13">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb16"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>graph <span class="op">=</span> Graph.from_matrices(mats.ipv, mats.sim)</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>graph.plot()</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display" data-execution_count="13">
<div>
<figure class="figure">
<p><a href="rabbits_full_py_api_example_files/figure-html/cell-14-output-1.svg" class="lightbox" data-gallery="quarto-lightbox-gallery-4"><img src="rabbits_full_py_api_example_files/figure-html/cell-14-output-1.svg" class="img-fluid figure-img"></a></p>
</figure>
</div>
</div>
</div>
</section>
<section id="continuous-phase-type-distribution" class="level2">
<h2 class="anchored" data-anchor-id="continuous-phase-type-distribution">Continuous phase-type distribution</h2>
<p>We can now construct the graphs by the function. The flooding rates are set to 2 and 4</p>
<div id="cell-29" class="cell" data-execution_count="14">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb17"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>graph <span class="op">=</span> construct_rabbit_graph(<span class="dv">2</span>, <span class="dv">2</span>, <span class="dv">4</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p>Get the number of vertices in the graph:</p>
<div id="cell-31" class="cell" data-execution_count="15">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb18"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>graph.vertices_length()</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display" data-execution_count="15">
<pre><code>7</code></pre>
</div>
</div>
<p>as well as integer vector states that those vertices represent:</p>
<div id="cell-33" class="cell" data-execution_count="16">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb20"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>M <span class="op">=</span> graph.states()</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>M</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display" data-execution_count="16">
<pre><code>array([[0, 0],
       [2, 0],
       [1, 1],
       [0, 0],
       [0, 2],
       [0, 1],
       [1, 0]], dtype=int32)</code></pre>
</div>
</div>
<p>(or nicely as a dataframe):</p>
<div id="cell-35" class="cell" data-execution_count="17">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb22"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>pd.DataFrame(M, columns<span class="op">=</span>[<span class="st">"Rabbits left"</span>, <span class="st">"Rabbits right"</span>])<span class="co">#.style.hide()</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display" data-execution_count="17">
<div>


<table class="dataframe caption-top table table-sm table-striped small" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">Rabbits left</th>
<th data-quarto-table-cell-role="th">Rabbits right</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<th data-quarto-table-cell-role="th">0</th>
<td>0</td>
<td>0</td>
</tr>
<tr class="even">
<th data-quarto-table-cell-role="th">1</th>
<td>2</td>
<td>0</td>
</tr>
<tr class="odd">
<th data-quarto-table-cell-role="th">2</th>
<td>1</td>
<td>1</td>
</tr>
<tr class="even">
<th data-quarto-table-cell-role="th">3</th>
<td>0</td>
<td>0</td>
</tr>
<tr class="odd">
<th data-quarto-table-cell-role="th">4</th>
<td>0</td>
<td>2</td>
</tr>
<tr class="even">
<th data-quarto-table-cell-role="th">5</th>
<td>0</td>
<td>1</td>
</tr>
<tr class="odd">
<th data-quarto-table-cell-role="th">6</th>
<td>1</td>
<td>0</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<p>This phase-type distribution models the time until all rabits have died. For convenience, we can get its expectation and variance like this:</p>
<div id="cell-37" class="cell" data-execution_count="18">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb23"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>graph.expectation()</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stderr">
<pre><code>INFO: building reward compute graph...</code></pre>
</div>
<div class="cell-output cell-output-display" data-execution_count="18">
<pre><code>0.5038265306122448</code></pre>
</div>
</div>
<div id="cell-38" class="cell" data-execution_count="19">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb26"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a>graph.variance()</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display" data-execution_count="19">
<pre><code>0.2264567497917534</code></pre>
</div>
</div>
<p>But if you want you can get any number of moments like this (here three):</p>
<div id="cell-40" class="cell" data-execution_count="20">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb28"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a>graph.moments(<span class="dv">3</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display" data-execution_count="20">
<pre><code>[0.5038265306122448, 0.48029792274052463, 0.6559101757731152]</code></pre>
</div>
</div>
<p>We can find the expected waiting time given that we start in any of the states, not just the starting state:</p>
<div id="cell-42" class="cell" data-execution_count="21">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb30"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a>graph.expected_waiting_time()</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display" data-execution_count="21">
<pre><code>[0.5038265306122448,
 0.5038265306122448,
 0.5114795918367346,
 0.0,
 0.30229591836734687,
 0.28571428571428564,
 0.4285714285714285]</code></pre>
</div>
</div>
<p>We can get the CDF and PDF. The distribution methods reuse cached computations and recompute only if the graph changes. Compare the running times for the first and second call to the function:</p>
<div id="cell-45" class="cell" data-execution_count="22">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb32"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a>time <span class="op">=</span> np.arange(<span class="dv">0</span>, <span class="dv">4</span>, <span class="fl">0.001</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<div id="cell-46" class="cell" data-execution_count="23">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb33"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="op">%%</span>time</span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>cdf <span class="op">=</span> graph.cdf(time)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>CPU times: user 370 μs, sys: 28 μs, total: 398 μs
Wall time: 400 μs</code></pre>
</div>
</div>
<div id="cell-47" class="cell" data-execution_count="24">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb35"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="op">%%</span>time</span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a>cdf <span class="op">=</span> graph.cdf(time)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>CPU times: user 46 μs, sys: 17 μs, total: 63 μs
Wall time: 62 μs</code></pre>
</div>
</div>
<div id="cell-48" class="cell" data-execution_count="25">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb37"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="op">%%</span>time</span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a>pdf <span class="op">=</span> graph.pdf(time)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>CPU times: user 46 μs, sys: 19 μs, total: 65 μs
Wall time: 61 μs</code></pre>
</div>
</div>
<p>PDF and CDF of distribution. Observe the long tails!</p>
<div id="cell-50" class="cell" data-execution_count="26">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb39"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a>fig, (ax1, ax2) <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">2</span>, figsize<span class="op">=</span>(<span class="dv">8</span>, <span class="dv">3</span>))</span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a>ax1.plot(time, pdf)</span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a>ax1.set_title(<span class="st">"PDF"</span>)</span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true" tabindex="-1"></a>ax1.set_ylim(bottom<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb39-5"><a href="#cb39-5" aria-hidden="true" tabindex="-1"></a>ax2.plot(time, cdf)</span>
<span id="cb39-6"><a href="#cb39-6" aria-hidden="true" tabindex="-1"></a>ax2.set_title(<span class="st">"CDF"</span>)</span>
<span id="cb39-7"><a href="#cb39-7" aria-hidden="true" tabindex="-1"></a>ax2.set_ylim(bottom<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb39-8"><a href="#cb39-8" aria-hidden="true" tabindex="-1"></a>sns.despine()</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><a href="rabbits_full_py_api_example_files/figure-html/cell-29-output-1.png" class="lightbox" data-gallery="quarto-lightbox-gallery-5"><img src="rabbits_full_py_api_example_files/figure-html/cell-29-output-1.png" width="671" height="296" class="figure-img"></a></p>
</figure>
</div>
</div>
</div>
</section>
<section id="rewards" class="level2">
<h2 class="anchored" data-anchor-id="rewards">Rewards</h2>
<p>We can add rewards which are based on the number of rabbits on the second island.</p>
<div id="cell-53" class="cell" data-execution_count="27">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb40"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a>rewards <span class="op">=</span> graph.states()[:, <span class="dv">1</span>]</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p>Can also be computed like this:</p>
<div id="cell-55" class="cell" data-execution_count="28">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb41"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a>rewards <span class="op">=</span> np.array([graph.vertex_at(i).state()[<span class="dv">1</span>] <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(graph.vertices_length())])</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p>Adding these rewards, the phase-type distribution now represent the total accumulated time that any rabbits spends on the right island.</p>
<p>Using rewards to the moment functions etc. is much faster than changing the graph.</p>
<p>The expectation and variance are now:</p>
<div id="cell-59" class="cell" data-execution_count="29">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb42"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a>graph.expectation(rewards), graph.variance(rewards)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display" data-execution_count="29">
<pre><code>(0.09438775510204081, 0.04634787588504788)</code></pre>
</div>
</div>
<p>Using rewards to the moment functions etc. is much faster than actually changing the graph, but sometimes we might want to be interested in reward transforming the phase-type distribution, giving us the full distribution of accumulated rewards. For example if we want the pdf/cdf.</p>
<div id="cell-61" class="cell" data-execution_count="30">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb44"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a>right_graph <span class="op">=</span> graph.reward_transform(rewards)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p>Now we get the expectation and variance from before without adding any rewards:</p>
<div id="cell-63" class="cell" data-execution_count="31">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb45"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a>right_graph.expectation(), right_graph.variance()</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stderr">
<pre><code>INFO: building reward compute graph...</code></pre>
</div>
<div class="cell-output cell-output-display" data-execution_count="31">
<pre><code>(0.09438775510204078, 0.046347875885047865)</code></pre>
</div>
</div>
<p>We can find the distribution function for the the total accumulate time spent by any rabbit on an island. We show here the PDF and CDF</p>
<div id="cell-65" class="cell" data-execution_count="32">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb48"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a>accumulated_rewards <span class="op">=</span> np.arange(<span class="dv">0</span>, <span class="dv">2</span>, <span class="fl">0.01</span>)</span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-3"><a href="#cb48-3" aria-hidden="true" tabindex="-1"></a>pdf <span class="op">=</span> right_graph.pdf(accumulated_rewards)</span>
<span id="cb48-4"><a href="#cb48-4" aria-hidden="true" tabindex="-1"></a>cdf <span class="op">=</span> right_graph.cdf(accumulated_rewards)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p>PDF and CDF of distribution. Notice how we have a “defect” i.e.&nbsp;a probability of obtaining no rewards:</p>
<div id="cell-67" class="cell" data-tags="[]" data-execution_count="33">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb49"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a>right_graph.defect()</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display" data-execution_count="33">
<pre><code>0.6666666666666666</code></pre>
</div>
</div>
<p>The defect is shown with a dotted line below. Remember to always consider this defect.</p>
<div id="cell-69" class="cell" data-execution_count="34">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb51"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a>fig, (ax1, ax2) <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">2</span>, figsize<span class="op">=</span>(<span class="dv">8</span>, <span class="dv">3</span>), sharey<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true" tabindex="-1"></a>ax1.plot(accumulated_rewards, pdf)</span>
<span id="cb51-3"><a href="#cb51-3" aria-hidden="true" tabindex="-1"></a>ax1.set_title(<span class="st">"PDF"</span>)</span>
<span id="cb51-4"><a href="#cb51-4" aria-hidden="true" tabindex="-1"></a>ax1.set_ylim(bottom<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb51-5"><a href="#cb51-5" aria-hidden="true" tabindex="-1"></a>ax2.plot(accumulated_rewards, cdf)</span>
<span id="cb51-6"><a href="#cb51-6" aria-hidden="true" tabindex="-1"></a>ax2.set_title(<span class="st">"CDF"</span>)</span>
<span id="cb51-7"><a href="#cb51-7" aria-hidden="true" tabindex="-1"></a>ax2.set_ylim(bottom<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb51-8"><a href="#cb51-8" aria-hidden="true" tabindex="-1"></a>ax2.axhline(y<span class="op">=</span>right_graph.defect(), linestyle<span class="op">=</span><span class="st">'dotted'</span>, color<span class="op">=</span><span class="st">'black'</span>)</span>
<span id="cb51-9"><a href="#cb51-9" aria-hidden="true" tabindex="-1"></a>sns.despine()</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><a href="rabbits_full_py_api_example_files/figure-html/cell-37-output-1.png" class="lightbox" data-gallery="quarto-lightbox-gallery-6"><img src="rabbits_full_py_api_example_files/figure-html/cell-37-output-1.png" width="671" height="296" class="figure-img"></a></p>
</figure>
</div>
</div>
</div>
<p>There are also utility methods to get the stop probability i.e.&nbsp;probabilities of occupying each state at time t.</p>
<div id="cell-71" class="cell" data-execution_count="35">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb52"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a>graph.stop_probability(<span class="fl">0.2</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display" data-execution_count="35">
<pre><code>[0.0,
 0.5561531639166896,
 0.07040541534825098,
 0.0,
 0.007095725804629082,
 0.016348108066650276,
 0.03374890558205247]</code></pre>
</div>
</div>
<p>We can use that to compute the expected number of rabbits across time:</p>
<div id="cell-73" class="cell" data-execution_count="36">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb54"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a>times <span class="op">=</span> np.arange(<span class="dv">0</span>, <span class="dv">2</span>, <span class="fl">0.05</span>)</span>
<span id="cb54-2"><a href="#cb54-2" aria-hidden="true" tabindex="-1"></a>expected_rabbits_left <span class="op">=</span> [</span>
<span id="cb54-3"><a href="#cb54-3" aria-hidden="true" tabindex="-1"></a>    np.<span class="bu">sum</span>(graph.stop_probability(i) </span>
<span id="cb54-4"><a href="#cb54-4" aria-hidden="true" tabindex="-1"></a>           <span class="op">*</span> np.<span class="bu">sum</span>(graph.states(), axis<span class="op">=</span><span class="dv">1</span>)) </span>
<span id="cb54-5"><a href="#cb54-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> times</span>
<span id="cb54-6"><a href="#cb54-6" aria-hidden="true" tabindex="-1"></a>    ]</span>
<span id="cb54-7"><a href="#cb54-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-8"><a href="#cb54-8" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">1</span>, figsize<span class="op">=</span>(<span class="dv">4</span>, <span class="dv">3</span>))</span>
<span id="cb54-9"><a href="#cb54-9" aria-hidden="true" tabindex="-1"></a>ax.plot(times, expected_rabbits_left)</span>
<span id="cb54-10"><a href="#cb54-10" aria-hidden="true" tabindex="-1"></a>ax.set_xlabel(<span class="st">'time'</span>)</span>
<span id="cb54-11"><a href="#cb54-11" aria-hidden="true" tabindex="-1"></a>ax.set_ylabel(<span class="st">"Expected nr rabbits"</span>)</span>
<span id="cb54-12"><a href="#cb54-12" aria-hidden="true" tabindex="-1"></a>sns.despine()</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><a href="rabbits_full_py_api_example_files/figure-html/cell-39-output-1.png" class="lightbox" data-gallery="quarto-lightbox-gallery-7"><img src="rabbits_full_py_api_example_files/figure-html/cell-39-output-1.png" width="385" height="294" class="figure-img"></a></p>
</figure>
</div>
</div>
</div>
<p>We can also get the accumulated visiting time of a particular state. E.g. the total time before time t=0.5 where there was a rabbit on the right island:</p>
<div id="cell-75" class="cell" data-execution_count="37">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb55"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a>rewards <span class="op">=</span> (graph.states()[:,<span class="dv">1</span>]<span class="op">&gt;</span><span class="dv">0</span>).astype(<span class="bu">int</span>)</span>
<span id="cb55-2"><a href="#cb55-2" aria-hidden="true" tabindex="-1"></a>np.<span class="bu">sum</span>(graph.accumulated_visiting_time(time<span class="op">=</span><span class="fl">0.5</span>) <span class="op">*</span> rewards)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display" data-execution_count="37">
<pre><code>np.float64(0.04053231796047568)</code></pre>
</div>
</div>
<div id="cell-76" class="cell" data-execution_count="38">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb57"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a>graph.expected_residence_time()</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display" data-execution_count="38">
<pre><code>[0.0, 0.5038265306122448, 0.0, 0.0, 0.0, 0.0, 0.0]</code></pre>
</div>
</div>
</section>
</section>
<section id="random-sampling" class="level1">
<h1>Random sampling</h1>
<p>The library includes functions to do random sampling. These are useful to also validate the computations</p>
<div id="cell-79" class="cell" data-execution_count="39">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb59"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a>graph.sample(<span class="dv">5</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display" data-execution_count="39">
<pre><code>[0.10654450534134478,
 0.2096468961770757,
 0.15551459579961166,
 0.1302728624634086,
 0.008689251706179528]</code></pre>
</div>
</div>
<div id="cell-80" class="cell" data-execution_count="40">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb61"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(figsize<span class="op">=</span>(<span class="dv">4</span>, <span class="dv">3</span>))</span>
<span id="cb61-2"><a href="#cb61-2" aria-hidden="true" tabindex="-1"></a>samples <span class="op">=</span> graph.sample(<span class="dv">1000000</span>)</span>
<span id="cb61-3"><a href="#cb61-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-4"><a href="#cb61-4" aria-hidden="true" tabindex="-1"></a>ax.hist(samples, bins<span class="op">=</span><span class="dv">50</span>, density<span class="op">=</span><span class="va">True</span>, label<span class="op">=</span><span class="st">'Samples'</span>)</span>
<span id="cb61-5"><a href="#cb61-5" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> np.arange(<span class="dv">0</span>, <span class="dv">2</span>, <span class="fl">0.05</span>)</span>
<span id="cb61-6"><a href="#cb61-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-7"><a href="#cb61-7" aria-hidden="true" tabindex="-1"></a>ax.plot(x, [graph.pdf(t) <span class="cf">for</span> t <span class="kw">in</span> x], label<span class="op">=</span><span class="st">'PDF'</span>)</span>
<span id="cb61-8"><a href="#cb61-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-9"><a href="#cb61-9" aria-hidden="true" tabindex="-1"></a>ax.set_xlim(<span class="dv">0</span>, <span class="dv">2</span>)</span>
<span id="cb61-10"><a href="#cb61-10" aria-hidden="true" tabindex="-1"></a>ax.legend()</span>
<span id="cb61-11"><a href="#cb61-11" aria-hidden="true" tabindex="-1"></a>sns.despine()</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><a href="rabbits_full_py_api_example_files/figure-html/cell-43-output-1.png" class="lightbox" data-gallery="quarto-lightbox-gallery-8"><img src="rabbits_full_py_api_example_files/figure-html/cell-43-output-1.png" width="372" height="274" class="figure-img"></a></p>
</figure>
</div>
</div>
</div>
<p>You can produce the moments from sampling if needed. Compare to the sampled and exact second moments:</p>
<div id="cell-82" class="cell" data-execution_count="41">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb62"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb62-1"><a href="#cb62-1" aria-hidden="true" tabindex="-1"></a>np.<span class="bu">sum</span>(np.array(graph.sample(<span class="dv">1000000</span>))<span class="op">**</span><span class="dv">2</span>)<span class="op">/</span><span class="dv">1000000</span>, graph.moments(<span class="dv">2</span>)[<span class="dv">1</span>]</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display" data-execution_count="41">
<pre><code>(np.float64(0.4802356496588736), 0.48029792274052463)</code></pre>
</div>
</div>
<div id="cell-83" class="cell" data-execution_count="42">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb64"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb64-1"><a href="#cb64-1" aria-hidden="true" tabindex="-1"></a>rewards <span class="op">=</span> graph.states()[:,<span class="dv">1</span>]</span>
<span id="cb64-2"><a href="#cb64-2" aria-hidden="true" tabindex="-1"></a>np.<span class="bu">sum</span>(np.array(graph.sample(<span class="dv">1000000</span>, rewards))<span class="op">**</span><span class="dv">2</span>)<span class="op">/</span><span class="dv">1000000</span>, graph.moments(<span class="dv">2</span>, rewards)[<span class="dv">1</span>]</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display" data-execution_count="42">
<pre><code>(np.float64(0.05480396506822537), 0.055256924198250706)</code></pre>
</div>
</div>
<p>Reward-transforming first and then computing without rewards achieves the same thing:</p>
<div id="cell-85" class="cell" data-execution_count="43">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb66"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb66-1"><a href="#cb66-1" aria-hidden="true" tabindex="-1"></a>revtr_graph <span class="op">=</span> graph.reward_transform(rewards)</span>
<span id="cb66-2"><a href="#cb66-2" aria-hidden="true" tabindex="-1"></a>np.<span class="bu">sum</span>(np.array(revtr_graph.sample(<span class="dv">1000000</span>))<span class="op">**</span><span class="dv">2</span>)<span class="op">/</span><span class="dv">1000000</span>, revtr_graph.moments(<span class="dv">2</span>)[<span class="dv">1</span>]</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stderr">
<pre><code>INFO: building reward compute graph...</code></pre>
</div>
<div class="cell-output cell-output-display" data-execution_count="43">
<pre><code>(np.float64(0.05577553177571136), 0.05525692419825069)</code></pre>
</div>
</div>
<section id="discrete-phase-type-distributions" class="level2">
<h2 class="anchored" data-anchor-id="discrete-phase-type-distributions">Discrete phase-type distributions</h2>
<p>We can also work with discrete phase-type distributions. This is the number of jumps in a Markov Chain before absorption. We will model that any rabbit can find a carrot at each time with rate 0.1 and see how many carrots the rabbits will have found. We could of course just make a new state-space creation function, but we can also manipulate existing.</p>
<div id="cell-88" class="cell" data-execution_count="44">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb69"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb69-1"><a href="#cb69-1" aria-hidden="true" tabindex="-1"></a>carrot_graph <span class="op">=</span> graph.copy()</span>
<span id="cb69-2"><a href="#cb69-2" aria-hidden="true" tabindex="-1"></a>vlength <span class="op">=</span> carrot_graph.vertices_length()</span>
<span id="cb69-3"><a href="#cb69-3" aria-hidden="true" tabindex="-1"></a>carrot_vertices <span class="op">=</span> np.repeat(<span class="va">False</span>, vlength<span class="op">*</span><span class="dv">2</span>)</span>
<span id="cb69-4"><a href="#cb69-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb69-5"><a href="#cb69-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb69-6"><a href="#cb69-6" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(vlength):</span>
<span id="cb69-7"><a href="#cb69-7" aria-hidden="true" tabindex="-1"></a>    vertex <span class="op">=</span> carrot_graph.vertex_at(i)</span>
<span id="cb69-8"><a href="#cb69-8" aria-hidden="true" tabindex="-1"></a>    rabbits <span class="op">=</span> <span class="bu">sum</span>(vertex.state())</span>
<span id="cb69-9"><a href="#cb69-9" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb69-10"><a href="#cb69-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> rabbits <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb69-11"><a href="#cb69-11" aria-hidden="true" tabindex="-1"></a>        obtained_carrot_vertex <span class="op">=</span> carrot_graph.create_vertex([<span class="dv">0</span>])</span>
<span id="cb69-12"><a href="#cb69-12" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Go directly back to the state we came from</span></span>
<span id="cb69-13"><a href="#cb69-13" aria-hidden="true" tabindex="-1"></a>        obtained_carrot_vertex.add_edge(vertex, <span class="dv">1</span>)</span>
<span id="cb69-14"><a href="#cb69-14" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Rate of finding carrot</span></span>
<span id="cb69-15"><a href="#cb69-15" aria-hidden="true" tabindex="-1"></a>        vertex.add_edge(obtained_carrot_vertex, rabbits <span class="op">*</span> <span class="fl">0.1</span>)</span>
<span id="cb69-16"><a href="#cb69-16" aria-hidden="true" tabindex="-1"></a>        carrot_vertices[obtained_carrot_vertex.index()] <span class="op">=</span> <span class="va">True</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<div id="cell-89" class="cell" data-execution_count="45">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb70"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb70-1"><a href="#cb70-1" aria-hidden="true" tabindex="-1"></a>carrot_graph.plot()</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display" data-execution_count="45">
<div>
<figure class="figure">
<p><a href="rabbits_full_py_api_example_files/figure-html/cell-48-output-1.svg" class="lightbox" data-gallery="quarto-lightbox-gallery-9"><img src="rabbits_full_py_api_example_files/figure-html/cell-48-output-1.svg" class="img-fluid figure-img"></a></p>
</figure>
</div>
</div>
</div>
<div id="cell-90" class="cell" data-execution_count="46">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb71"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb71-1"><a href="#cb71-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb71-2"><a href="#cb71-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb71-3"><a href="#cb71-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb71-4"><a href="#cb71-4" aria-hidden="true" tabindex="-1"></a>vlength <span class="op">=</span> carrot_graph.vertices_length()</span>
<span id="cb71-5"><a href="#cb71-5" aria-hidden="true" tabindex="-1"></a>carrot_vertices <span class="op">=</span> np.repeat(<span class="va">False</span>, vlength<span class="op">*</span><span class="dv">2</span>)</span>
<span id="cb71-6"><a href="#cb71-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb71-7"><a href="#cb71-7" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(vlength):</span>
<span id="cb71-8"><a href="#cb71-8" aria-hidden="true" tabindex="-1"></a>    vertex <span class="op">=</span> carrot_graph.vertex_at(i)</span>
<span id="cb71-9"><a href="#cb71-9" aria-hidden="true" tabindex="-1"></a>    rabbits <span class="op">=</span> <span class="bu">sum</span>(vertex.state())</span>
<span id="cb71-10"><a href="#cb71-10" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb71-11"><a href="#cb71-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> rabbits <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb71-12"><a href="#cb71-12" aria-hidden="true" tabindex="-1"></a>        obtained_carrot_vertex <span class="op">=</span> carrot_graph.create_vertex([<span class="dv">0</span>])</span>
<span id="cb71-13"><a href="#cb71-13" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Go directly back to the state we came from</span></span>
<span id="cb71-14"><a href="#cb71-14" aria-hidden="true" tabindex="-1"></a>        obtained_carrot_vertex.add_edge(vertex, <span class="dv">1</span>)</span>
<span id="cb71-15"><a href="#cb71-15" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Rate of finding carrot</span></span>
<span id="cb71-16"><a href="#cb71-16" aria-hidden="true" tabindex="-1"></a>        vertex.add_edge(obtained_carrot_vertex, rabbits <span class="op">*</span> <span class="fl">0.1</span>)</span>
<span id="cb71-17"><a href="#cb71-17" aria-hidden="true" tabindex="-1"></a>        carrot_vertices[obtained_carrot_vertex.index()] <span class="op">=</span> <span class="va">True</span></span>
<span id="cb71-18"><a href="#cb71-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb71-19"><a href="#cb71-19" aria-hidden="true" tabindex="-1"></a>carrot_vertices <span class="op">=</span> carrot_vertices[np.arange(carrot_graph.vertices_length())]</span>
<span id="cb71-20"><a href="#cb71-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb71-21"><a href="#cb71-21" aria-hidden="true" tabindex="-1"></a><span class="co"># We now want to make the graph discrete. We do this by 'normalizing' the edges</span></span>
<span id="cb71-22"><a href="#cb71-22" aria-hidden="true" tabindex="-1"></a><span class="co"># This is imply scaling the vertices such that the total out-going rate is 1</span></span>
<span id="cb71-23"><a href="#cb71-23" aria-hidden="true" tabindex="-1"></a><span class="co"># As it is now the probability of transitions</span></span>
<span id="cb71-24"><a href="#cb71-24" aria-hidden="true" tabindex="-1"></a>weights_were_multiplied_with <span class="op">=</span> carrot_graph.normalize()</span>
<span id="cb71-25"><a href="#cb71-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb71-26"><a href="#cb71-26" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"This is the discrete state space as a sub-transition matrix:"</span>)</span>
<span id="cb71-27"><a href="#cb71-27" aria-hidden="true" tabindex="-1"></a><span class="co">#carrot_graph.as_matrices()</span></span>
<span id="cb71-28"><a href="#cb71-28" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'GRAPH AS MATRIX MAKES THE KERNEL DIE...'</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>This is the discrete state space as a sub-transition matrix:
GRAPH AS MATRIX MAKES THE KERNEL DIE...</code></pre>
</div>
</div>
<div id="cell-91" class="cell" data-execution_count="47">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb73"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb73-1"><a href="#cb73-1" aria-hidden="true" tabindex="-1"></a><span class="co"># for vertex in carrot_graph.vertices():</span></span>
<span id="cb73-2"><a href="#cb73-2" aria-hidden="true" tabindex="-1"></a><span class="co">#     print(vertex.index(),vertex.state(), vertex.edges())</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<div id="cell-92" class="cell" data-execution_count="48">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb74"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb74-1"><a href="#cb74-1" aria-hidden="true" tabindex="-1"></a><span class="co"># for vertex in carrot_graph.vertices():</span></span>
<span id="cb74-2"><a href="#cb74-2" aria-hidden="true" tabindex="-1"></a><span class="co">#     print(vertex)</span></span>
<span id="cb74-3"><a href="#cb74-3" aria-hidden="true" tabindex="-1"></a><span class="co">#     for edge in vertex.edges():</span></span>
<span id="cb74-4"><a href="#cb74-4" aria-hidden="true" tabindex="-1"></a><span class="co">#         print("  ", edge)</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<div id="cell-93" class="cell" data-execution_count="49">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb75"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb75-1"><a href="#cb75-1" aria-hidden="true" tabindex="-1"></a><span class="co"># carrot_vertices.astype(int)</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p>We now want to find the expected number of eaten carrots. We set the reward such that the carrot vertex has a reward of ‘1’.</p>
<div id="cell-95" class="cell" data-execution_count="50">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb76"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb76-1"><a href="#cb76-1" aria-hidden="true" tabindex="-1"></a>rewards <span class="op">=</span> carrot_vertices.astype(<span class="bu">int</span>)</span>
<span id="cb76-2"><a href="#cb76-2" aria-hidden="true" tabindex="-1"></a>carrot_graph.expectation_discrete(rewards)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stderr">
<pre><code>INFO: building reward compute graph...</code></pre>
</div>
<div class="cell-output cell-output-display" data-execution_count="50">
<pre><code>0.09056122448979592</code></pre>
</div>
</div>
<p>We can verify that the number of carrots correspond to scaling the continuous graph:</p>
<div id="cell-97" class="cell" data-execution_count="51">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb79"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb79-1"><a href="#cb79-1" aria-hidden="true" tabindex="-1"></a>graph.expectation(graph.states().<span class="bu">sum</span>(axis<span class="op">=</span><span class="dv">1</span>)) <span class="op">*</span> <span class="fl">0.1</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display" data-execution_count="51">
<pre><code>0.09056122448979591</code></pre>
</div>
</div>
<p>Of course we cannot do this for other moments:</p>
<div id="cell-99" class="cell" data-execution_count="52">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb81"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb81-1"><a href="#cb81-1" aria-hidden="true" tabindex="-1"></a>carrot_graph.variance_discrete(rewards)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display" data-execution_count="52">
<pre><code>0.09723142700957937</code></pre>
</div>
</div>
<p>Verified by sampling:</p>
<div id="cell-101" class="cell" data-execution_count="53">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb83"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb83-1"><a href="#cb83-1" aria-hidden="true" tabindex="-1"></a>samples <span class="op">=</span> carrot_graph.sample_discrete(<span class="dv">1000000</span>, rewards)</span>
<span id="cb83-2"><a href="#cb83-2" aria-hidden="true" tabindex="-1"></a>samples <span class="op">=</span> np.array(samples)</span>
<span id="cb83-3"><a href="#cb83-3" aria-hidden="true" tabindex="-1"></a>np.<span class="bu">sum</span>(samples<span class="op">**</span><span class="dv">2</span>) <span class="op">/</span> <span class="dv">1000000</span> <span class="op">-</span> ((np.<span class="bu">sum</span>(samples)) <span class="op">/</span> <span class="dv">1000000</span>)<span class="op">**</span><span class="dv">2</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display" data-execution_count="53">
<pre><code>np.float64(0.096806053376)</code></pre>
</div>
</div>
<div id="cell-102" class="cell" data-execution_count="54">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb85"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb85-1"><a href="#cb85-1" aria-hidden="true" tabindex="-1"></a><span class="co"># We can find the distribution function for the the total number of carrots found</span></span>
<span id="cb85-2"><a href="#cb85-2" aria-hidden="true" tabindex="-1"></a>carrots <span class="op">=</span> np.arange(<span class="dv">10</span>)</span>
<span id="cb85-3"><a href="#cb85-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Notice that with this reward transformation the graph is no longer sparse, as all paths through</span></span>
<span id="cb85-4"><a href="#cb85-4" aria-hidden="true" tabindex="-1"></a><span class="co"># the graph are represented!!</span></span>
<span id="cb85-5"><a href="#cb85-5" aria-hidden="true" tabindex="-1"></a>found_carrots_graph  <span class="op">=</span> carrot_graph.reward_transform_discrete(rewards)</span>
<span id="cb85-6"><a href="#cb85-6" aria-hidden="true" tabindex="-1"></a>pmf <span class="op">=</span> found_carrots_graph.pmf_discrete(carrots)</span>
<span id="cb85-7"><a href="#cb85-7" aria-hidden="true" tabindex="-1"></a>cdf <span class="op">=</span> found_carrots_graph.cdf_discrete(carrots)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<div id="cell-103" class="cell" data-execution_count="55">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb86"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb86-1"><a href="#cb86-1" aria-hidden="true" tabindex="-1"></a>fig, (ax1, ax2) <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">2</span>, figsize<span class="op">=</span>(<span class="dv">8</span>, <span class="dv">3</span>), sharey<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb86-2"><a href="#cb86-2" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> np.arange(<span class="dv">0</span>, <span class="dv">10</span>, <span class="dv">1</span>)</span>
<span id="cb86-3"><a href="#cb86-3" aria-hidden="true" tabindex="-1"></a>ax1.bar(x, pmf)</span>
<span id="cb86-4"><a href="#cb86-4" aria-hidden="true" tabindex="-1"></a>ax1.set_title(<span class="st">"PDF"</span>)</span>
<span id="cb86-5"><a href="#cb86-5" aria-hidden="true" tabindex="-1"></a>ax1.set_xlabel(<span class="st">'Total number of carrots found'</span>)</span>
<span id="cb86-6"><a href="#cb86-6" aria-hidden="true" tabindex="-1"></a><span class="co"># ax1.set_ylim(bottom=0)</span></span>
<span id="cb86-7"><a href="#cb86-7" aria-hidden="true" tabindex="-1"></a><span class="co">#ax2.plot(x, cdf)</span></span>
<span id="cb86-8"><a href="#cb86-8" aria-hidden="true" tabindex="-1"></a>left, right <span class="op">=</span> x, np.arange(<span class="dv">1</span>, x.size<span class="op">+</span><span class="dv">1</span>, <span class="dv">1</span>)</span>
<span id="cb86-9"><a href="#cb86-9" aria-hidden="true" tabindex="-1"></a>ax2.hlines(y<span class="op">=</span>cdf, xmin<span class="op">=</span>left, xmax<span class="op">=</span>right, zorder<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb86-10"><a href="#cb86-10" aria-hidden="true" tabindex="-1"></a>ax2.scatter(left, cdf, s<span class="op">=</span><span class="dv">18</span>, zorder<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb86-11"><a href="#cb86-11" aria-hidden="true" tabindex="-1"></a>ax2.set_title(<span class="st">"CDF"</span>)</span>
<span id="cb86-12"><a href="#cb86-12" aria-hidden="true" tabindex="-1"></a><span class="co"># ax2.set_ylim(bottom=0)</span></span>
<span id="cb86-13"><a href="#cb86-13" aria-hidden="true" tabindex="-1"></a>ax2.set_xlabel(<span class="st">'Total number of carrots found'</span>)</span>
<span id="cb86-14"><a href="#cb86-14" aria-hidden="true" tabindex="-1"></a>ax2.axhline(y<span class="op">=</span>right_graph.defect(), linestyle<span class="op">=</span><span class="st">'dotted'</span>)</span>
<span id="cb86-15"><a href="#cb86-15" aria-hidden="true" tabindex="-1"></a>sns.despine()</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><a href="rabbits_full_py_api_example_files/figure-html/cell-58-output-1.png" class="lightbox" data-gallery="quarto-lightbox-gallery-10"><img src="rabbits_full_py_api_example_files/figure-html/cell-58-output-1.png" width="671" height="315" class="figure-img"></a></p>
</figure>
</div>
</div>
</div>
</section>
</section>
<section id="multivariate-phase-type-distributions" class="level1">
<h1>Multivariate phase-type distributions</h1>
<p>Instead of a univariate reward, we can have the distribution earn a <em>vector</em> of rewards for each time unit spent at a vertex. We will continue with the rabbit example. We will now show the relationship between total time spent by any rabbit on either of the two islands.</p>
<div id="cell-106" class="cell" data-execution_count="56">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb87"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb87-1"><a href="#cb87-1" aria-hidden="true" tabindex="-1"></a>states <span class="op">=</span> graph.states()</span>
<span id="cb87-2"><a href="#cb87-2" aria-hidden="true" tabindex="-1"></a>states[:, <span class="dv">1</span>]</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display" data-execution_count="56">
<pre><code>array([0, 0, 1, 0, 2, 1, 0], dtype=int32)</code></pre>
</div>
</div>
<div id="cell-107" class="cell" data-execution_count="57">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb89"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb89-1"><a href="#cb89-1" aria-hidden="true" tabindex="-1"></a>states <span class="op">=</span> graph.states()</span>
<span id="cb89-2"><a href="#cb89-2" aria-hidden="true" tabindex="-1"></a>graph.covariance(states[:,<span class="dv">0</span>], states[:,<span class="dv">1</span>])</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display" data-execution_count="57">
<pre><code>0.030003774468971296</code></pre>
</div>
</div>
<div id="cell-108" class="cell" data-execution_count="58">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb91"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb91-1"><a href="#cb91-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb91-2"><a href="#cb91-2" aria-hidden="true" tabindex="-1"></a>simulations <span class="op">=</span> graph.sample_multivariate(<span class="dv">100000</span>, graph.states())</span>
<span id="cb91-3"><a href="#cb91-3" aria-hidden="true" tabindex="-1"></a>simulated_cov <span class="op">=</span> <span class="bu">sum</span>(simulations[<span class="dv">0</span>,:]<span class="op">*</span>simulations[<span class="dv">1</span>,:])<span class="op">/</span><span class="dv">100000</span> <span class="op">-</span> <span class="op">\</span></span>
<span id="cb91-4"><a href="#cb91-4" aria-hidden="true" tabindex="-1"></a>                    <span class="bu">sum</span>(simulations[<span class="dv">0</span>,:])<span class="op">/</span><span class="dv">100000</span><span class="op">*</span><span class="bu">sum</span>(simulations[<span class="dv">1</span>,:])<span class="op">/</span><span class="dv">100000</span></span>
<span id="cb91-5"><a href="#cb91-5" aria-hidden="true" tabindex="-1"></a>simulated_cov</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display" data-execution_count="58">
<pre><code>np.float64(0.03018146675774415)</code></pre>
</div>
</div>
<p>The api also supports multivariate <em>discrete</em> phase-type distributions. We show the covariance between carrots found on either island.</p>
<div id="cell-110" class="cell" data-execution_count="59">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb93"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb93-1"><a href="#cb93-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb93-2"><a href="#cb93-2" aria-hidden="true" tabindex="-1"></a>mdph_carrot_graph <span class="op">=</span> graph.clone()</span>
<span id="cb93-3"><a href="#cb93-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb93-4"><a href="#cb93-4" aria-hidden="true" tabindex="-1"></a>vlength <span class="op">=</span> mdph_carrot_graph.vertices_length()</span>
<span id="cb93-5"><a href="#cb93-5" aria-hidden="true" tabindex="-1"></a>carrot_vertices_left <span class="op">=</span> np.repeat(<span class="va">False</span>, vlength<span class="op">*</span><span class="dv">2</span>)</span>
<span id="cb93-6"><a href="#cb93-6" aria-hidden="true" tabindex="-1"></a>carrot_vertices_right <span class="op">=</span> np.repeat(<span class="va">False</span>, vlength<span class="op">*</span><span class="dv">2</span>)</span>
<span id="cb93-7"><a href="#cb93-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb93-8"><a href="#cb93-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb93-9"><a href="#cb93-9" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(vlength):</span>
<span id="cb93-10"><a href="#cb93-10" aria-hidden="true" tabindex="-1"></a>    vertex <span class="op">=</span> mdph_carrot_graph.vertex_at(i)</span>
<span id="cb93-11"><a href="#cb93-11" aria-hidden="true" tabindex="-1"></a>    rabbits <span class="op">=</span> vertex.state()</span>
<span id="cb93-12"><a href="#cb93-12" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb93-13"><a href="#cb93-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> rabbits[<span class="dv">0</span>] <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb93-14"><a href="#cb93-14" aria-hidden="true" tabindex="-1"></a>        obtained_carrot_vertex <span class="op">=</span> mdph_carrot_graph.create_vertex([<span class="dv">0</span>])</span>
<span id="cb93-15"><a href="#cb93-15" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Go directly back to the state we came from</span></span>
<span id="cb93-16"><a href="#cb93-16" aria-hidden="true" tabindex="-1"></a>        obtained_carrot_vertex.add_edge(vertex, <span class="dv">1</span>)</span>
<span id="cb93-17"><a href="#cb93-17" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Rate of finding carrot</span></span>
<span id="cb93-18"><a href="#cb93-18" aria-hidden="true" tabindex="-1"></a>        vertex.add_edge(obtained_carrot_vertex, rabbits[<span class="dv">0</span>] <span class="op">*</span> <span class="fl">0.1</span>)</span>
<span id="cb93-19"><a href="#cb93-19" aria-hidden="true" tabindex="-1"></a>        carrot_vertices_left[obtained_carrot_vertex.index()] <span class="op">=</span> <span class="va">True</span></span>
<span id="cb93-20"><a href="#cb93-20" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb93-21"><a href="#cb93-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> rabbits[<span class="dv">1</span>] <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb93-22"><a href="#cb93-22" aria-hidden="true" tabindex="-1"></a>        obtained_carrot_vertex <span class="op">=</span> mdph_carrot_graph.create_vertex([<span class="dv">0</span>])</span>
<span id="cb93-23"><a href="#cb93-23" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Go directly back to the state we came from</span></span>
<span id="cb93-24"><a href="#cb93-24" aria-hidden="true" tabindex="-1"></a>        obtained_carrot_vertex.add_edge(vertex, <span class="dv">1</span>)</span>
<span id="cb93-25"><a href="#cb93-25" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Rate of finding carrot</span></span>
<span id="cb93-26"><a href="#cb93-26" aria-hidden="true" tabindex="-1"></a>        vertex.add_edge(obtained_carrot_vertex, rabbits[<span class="dv">1</span>] <span class="op">*</span> <span class="fl">0.1</span>)</span>
<span id="cb93-27"><a href="#cb93-27" aria-hidden="true" tabindex="-1"></a>        carrot_vertices_right[obtained_carrot_vertex.index()] <span class="op">=</span> <span class="va">True</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p>Covariance:</p>
<div id="cell-112" class="cell" data-execution_count="60">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb94"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb94-1"><a href="#cb94-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb94-2"><a href="#cb94-2" aria-hidden="true" tabindex="-1"></a>carrot_vertices_left <span class="op">=</span> carrot_vertices_left[<span class="dv">0</span>:mdph_carrot_graph.vertices_length()]</span>
<span id="cb94-3"><a href="#cb94-3" aria-hidden="true" tabindex="-1"></a>carrot_vertices_right <span class="op">=</span> carrot_vertices_right[<span class="dv">0</span>:mdph_carrot_graph.vertices_length()]</span>
<span id="cb94-4"><a href="#cb94-4" aria-hidden="true" tabindex="-1"></a>mdph_carrot_graph.normalize()</span>
<span id="cb94-5"><a href="#cb94-5" aria-hidden="true" tabindex="-1"></a>rewards <span class="op">=</span> np.column_stack((carrot_vertices_left, carrot_vertices_right)).astype(<span class="bu">int</span>)</span>
<span id="cb94-6"><a href="#cb94-6" aria-hidden="true" tabindex="-1"></a>mdph_carrot_graph.covariance_discrete(rewards[:,<span class="dv">0</span>], rewards[:,<span class="dv">1</span>])</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stderr">
<pre><code>INFO: building reward compute graph...</code></pre>
</div>
<div class="cell-output cell-output-display" data-execution_count="60">
<pre><code>-0.0005338270512286547</code></pre>
</div>
</div>
<p>Sampled covariance:</p>
<div id="cell-114" class="cell" data-execution_count="61">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb97"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb97-1"><a href="#cb97-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb97-2"><a href="#cb97-2" aria-hidden="true" tabindex="-1"></a>simulations <span class="op">=</span> mdph_carrot_graph.sample_multivariate_discrete(<span class="dv">1000000</span>, rewards)</span>
<span id="cb97-3"><a href="#cb97-3" aria-hidden="true" tabindex="-1"></a>simulated_cov <span class="op">&lt;-</span> np.<span class="bu">sum</span>(simulations[<span class="dv">0</span>,:]<span class="op">*</span>simulations[<span class="dv">1</span>,:])<span class="op">/</span><span class="dv">1000000</span> <span class="op">-</span> <span class="op">\</span></span>
<span id="cb97-4"><a href="#cb97-4" aria-hidden="true" tabindex="-1"></a>                    np.<span class="bu">sum</span>(simulations[<span class="dv">0</span>,:])<span class="op">/</span><span class="dv">1000000</span><span class="op">*</span>np.<span class="bu">sum</span>(simulations[<span class="dv">1</span>,:])<span class="op">/</span><span class="dv">1000000</span></span>
<span id="cb97-5"><a href="#cb97-5" aria-hidden="true" tabindex="-1"></a>simulated_cov</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display" data-execution_count="61">
<pre><code>np.float64(0.03018146675774415)</code></pre>
</div>
</div>
</section>
<section id="parameterized-edges" class="level1">
<h1>Parameterized edges</h1>
<p>We can <em>parameterize</em> the edges to easily update the weights of the edge</p>
<p>We do this by assigning a <em>state</em> to the <em>edge</em>.</p>
<p>We will now also say that the rate of rabbits jumping is proportional to the number of rabbits on the island.</p>
<p>Our state is [rabbits able to jump, left flooding, right flooding]</p>
<div id="cell-117" class="cell" data-execution_count="62">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb99"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb99-1"><a href="#cb99-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb99-2"><a href="#cb99-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> construct_rabbit_graph_params(nr_rabbits):</span>
<span id="cb99-3"><a href="#cb99-3" aria-hidden="true" tabindex="-1"></a>    <span class="co"># We represent the vector as two integers, the number of rabbits on the left and right island</span></span>
<span id="cb99-4"><a href="#cb99-4" aria-hidden="true" tabindex="-1"></a>    state_vector_length <span class="op">=</span> <span class="dv">2</span></span>
<span id="cb99-5"><a href="#cb99-5" aria-hidden="true" tabindex="-1"></a>    graph <span class="op">=</span> Graph(state_vector_length)</span>
<span id="cb99-6"><a href="#cb99-6" aria-hidden="true" tabindex="-1"></a>    initial_state <span class="op">=</span> [nr_rabbits, <span class="dv">0</span>]</span>
<span id="cb99-7"><a href="#cb99-7" aria-hidden="true" tabindex="-1"></a>    <span class="co"># The initial state is the only starting state, with 100% starting probability</span></span>
<span id="cb99-8"><a href="#cb99-8" aria-hidden="true" tabindex="-1"></a>    graph.starting_vertex().add_edge(</span>
<span id="cb99-9"><a href="#cb99-9" aria-hidden="true" tabindex="-1"></a>      graph.find_or_create_vertex(initial_state),</span>
<span id="cb99-10"><a href="#cb99-10" aria-hidden="true" tabindex="-1"></a>      <span class="dv">1</span></span>
<span id="cb99-11"><a href="#cb99-11" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb99-12"><a href="#cb99-12" aria-hidden="true" tabindex="-1"></a>    index <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb99-13"><a href="#cb99-13" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Iterate over all unvisited vertices</span></span>
<span id="cb99-14"><a href="#cb99-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> index <span class="op">&lt;</span> graph.vertices_length():</span>
<span id="cb99-15"><a href="#cb99-15" aria-hidden="true" tabindex="-1"></a>      vertex <span class="op">=</span> graph.vertex_at(index)</span>
<span id="cb99-16"><a href="#cb99-16" aria-hidden="true" tabindex="-1"></a>      state <span class="op">=</span> vertex.state()</span>
<span id="cb99-17"><a href="#cb99-17" aria-hidden="true" tabindex="-1"></a>      <span class="cf">if</span> state[<span class="dv">0</span>] <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb99-18"><a href="#cb99-18" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Rabbit jump left to right</span></span>
<span id="cb99-19"><a href="#cb99-19" aria-hidden="true" tabindex="-1"></a>        child_state <span class="op">=</span> [state[<span class="dv">0</span>] <span class="op">-</span> <span class="dv">1</span>, state[<span class="dv">1</span>] <span class="op">+</span> <span class="dv">1</span>]</span>
<span id="cb99-20"><a href="#cb99-20" aria-hidden="true" tabindex="-1"></a>        vertex.add_edge_parameterized(</span>
<span id="cb99-21"><a href="#cb99-21" aria-hidden="true" tabindex="-1"></a>          graph.find_or_create_vertex(child_state),</span>
<span id="cb99-22"><a href="#cb99-22" aria-hidden="true" tabindex="-1"></a>          <span class="dv">0</span>,</span>
<span id="cb99-23"><a href="#cb99-23" aria-hidden="true" tabindex="-1"></a>          [state[<span class="dv">0</span>],<span class="dv">0</span>,<span class="dv">0</span>]</span>
<span id="cb99-24"><a href="#cb99-24" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb99-25"><a href="#cb99-25" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Left island flooding</span></span>
<span id="cb99-26"><a href="#cb99-26" aria-hidden="true" tabindex="-1"></a>        child_state <span class="op">=</span> c(<span class="dv">0</span>, state[<span class="dv">1</span>])</span>
<span id="cb99-27"><a href="#cb99-27" aria-hidden="true" tabindex="-1"></a>        vertex.add_edge_parameterized(</span>
<span id="cb99-28"><a href="#cb99-28" aria-hidden="true" tabindex="-1"></a>          graph.find_or_create_vertex(child_state),</span>
<span id="cb99-29"><a href="#cb99-29" aria-hidden="true" tabindex="-1"></a>          <span class="dv">0</span>,</span>
<span id="cb99-30"><a href="#cb99-30" aria-hidden="true" tabindex="-1"></a>          [<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">0</span>]</span>
<span id="cb99-31"><a href="#cb99-31" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb99-32"><a href="#cb99-32" aria-hidden="true" tabindex="-1"></a>      <span class="cf">if</span> state[<span class="dv">1</span>] <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb99-33"><a href="#cb99-33" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Rabbit jump right to left</span></span>
<span id="cb99-34"><a href="#cb99-34" aria-hidden="true" tabindex="-1"></a>        child_state <span class="op">=</span> [state[<span class="dv">0</span>] <span class="op">+</span> <span class="dv">1</span>, state[<span class="dv">1</span>] <span class="op">-</span> <span class="dv">1</span>]</span>
<span id="cb99-35"><a href="#cb99-35" aria-hidden="true" tabindex="-1"></a>        vertex.add_edge_parameterized(</span>
<span id="cb99-36"><a href="#cb99-36" aria-hidden="true" tabindex="-1"></a>          graph.find_or_create_vertex(child_state),</span>
<span id="cb99-37"><a href="#cb99-37" aria-hidden="true" tabindex="-1"></a>          <span class="dv">0</span>, </span>
<span id="cb99-38"><a href="#cb99-38" aria-hidden="true" tabindex="-1"></a>          [state[<span class="dv">1</span>],<span class="dv">0</span>,<span class="dv">0</span>]</span>
<span id="cb99-39"><a href="#cb99-39" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb99-40"><a href="#cb99-40" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Right island flooding with rate of 4</span></span>
<span id="cb99-41"><a href="#cb99-41" aria-hidden="true" tabindex="-1"></a>        child_state <span class="op">=</span> [state[<span class="dv">0</span>], <span class="dv">0</span>]</span>
<span id="cb99-42"><a href="#cb99-42" aria-hidden="true" tabindex="-1"></a>        vertex.add_edge_parameterized(</span>
<span id="cb99-43"><a href="#cb99-43" aria-hidden="true" tabindex="-1"></a>          graph.find_or_create_vertex(child_state),</span>
<span id="cb99-44"><a href="#cb99-44" aria-hidden="true" tabindex="-1"></a>          <span class="dv">0</span>,</span>
<span id="cb99-45"><a href="#cb99-45" aria-hidden="true" tabindex="-1"></a>          [<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">1</span>]</span>
<span id="cb99-46"><a href="#cb99-46" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb99-47"><a href="#cb99-47" aria-hidden="true" tabindex="-1"></a>      index <span class="op">=</span> index <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb99-48"><a href="#cb99-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb99-49"><a href="#cb99-49" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span>(graph)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p>The parameterized edges have what ever weight is assigned to them, and the state does not by itself mean anything.</p>
<div id="cell-119" class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb100"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb100-1"><a href="#cb100-1" aria-hidden="true" tabindex="-1"></a>param_graph <span class="op">=</span> construct_rabbit_graph_params(<span class="dv">2</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p>If we let the edge have a state, this gives us an easy way of changing the weights based on some model parameters. In this case, it is the rate of jumping left rate of flooding and right rate of flooding.</p>
<p>The update simply takes the inner product of the state vector and the model parameters, e.g.&nbsp;if the state is x1, x2 and the parameters are p1, p2, then the weight of the edge become x1<em>p1+x2</em>p2</p>
<div id="cell-121" class="cell" data-execution_count="65">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb101"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb101-1"><a href="#cb101-1" aria-hidden="true" tabindex="-1"></a>param_graph.update_parameterized_weights([<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">4</span>])</span>
<span id="cb101-2"><a href="#cb101-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Expectation (1,2,4):"</span>, param_graph.expectation())</span>
<span id="cb101-3"><a href="#cb101-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-4"><a href="#cb101-4" aria-hidden="true" tabindex="-1"></a>param_graph.update_parameterized_weights([<span class="dv">2</span>, <span class="dv">2</span>, <span class="dv">4</span>])</span>
<span id="cb101-5"><a href="#cb101-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Expectation (1,2,4):"</span>, param_graph.expectation())</span>
<span id="cb101-6"><a href="#cb101-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-7"><a href="#cb101-7" aria-hidden="true" tabindex="-1"></a>param_graph.update_parameterized_weights([<span class="dv">2</span>, <span class="dv">4</span>, <span class="dv">4</span>])</span>
<span id="cb101-8"><a href="#cb101-8" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Expectation (1,2,4):"</span>, param_graph.expectation())</span>
<span id="cb101-9"><a href="#cb101-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-10"><a href="#cb101-10" aria-hidden="true" tabindex="-1"></a>param_graph.update_parameterized_weights([<span class="dv">2</span>, <span class="dv">4</span>, <span class="dv">18</span>])</span>
<span id="cb101-11"><a href="#cb101-11" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Expectation (1,2,4):"</span>, param_graph.expectation())</span>
<span id="cb101-12"><a href="#cb101-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-13"><a href="#cb101-13" aria-hidden="true" tabindex="-1"></a>param_graph.update_parameterized_weights([<span class="dv">8</span>, <span class="dv">4</span>, <span class="dv">18</span>])</span>
<span id="cb101-14"><a href="#cb101-14" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Expectation (1,2,4):"</span>, param_graph.expectation())</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>Expectation (1,2,4): 0.453843669250646
Expectation (1,2,4): 0.3829988851727981
Expectation (1,2,4): 0.2558080808080808
Expectation (1,2,4): 0.2123466140255808
Expectation (1,2,4): 0.1274895365841465</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>INFO: recording elimination trace for parameterized graph...
INFO: using trace-based path for reward compute graph...
INFO: trace-based reward compute graph built successfully
INFO: using trace-based path for reward compute graph...
INFO: trace-based reward compute graph built successfully
INFO: using trace-based path for reward compute graph...
INFO: trace-based reward compute graph built successfully
INFO: using trace-based path for reward compute graph...
INFO: trace-based reward compute graph built successfully
INFO: using trace-based path for reward compute graph...
INFO: trace-based reward compute graph built successfully</code></pre>
</div>
</div>
<p>Note that the moment graph <em>has</em> to be recalculated after updating weights</p>
<div id="cell-123" class="cell" data-execution_count="66">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb104"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb104-1"><a href="#cb104-1" aria-hidden="true" tabindex="-1"></a>param_graph.update_parameterized_weights([<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">4</span>])</span>
<span id="cb104-2"><a href="#cb104-2" aria-hidden="true" tabindex="-1"></a><span class="co">#param_graph.as_matrices()</span></span>
<span id="cb104-3"><a href="#cb104-3" aria-hidden="true" tabindex="-1"></a>      </span>
<span id="cb104-4"><a href="#cb104-4" aria-hidden="true" tabindex="-1"></a>param_graph.update_parameterized_weights([<span class="dv">8</span>, <span class="dv">4</span>, <span class="dv">18</span>])</span>
<span id="cb104-5"><a href="#cb104-5" aria-hidden="true" tabindex="-1"></a><span class="co">#param_graph.as_matrices()</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
</section>
<section id="precomputing-trace-for-dag" class="level1">
<h1>Precomputing trace for DAG</h1>
<div id="cell-125" class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb105"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb105-1"><a href="#cb105-1" aria-hidden="true" tabindex="-1"></a><span class="co"># First, let's create a parameterized rabbit model with more rabbits to see the performance benefit</span></span>
<span id="cb105-2"><a href="#cb105-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> construct_parameterized_rabbit_model(nr_rabbits):</span>
<span id="cb105-3"><a href="#cb105-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb105-4"><a href="#cb105-4" aria-hidden="true" tabindex="-1"></a><span class="co">    Construct a parameterized rabbit model where edge weights are linear combinations of parameters.</span></span>
<span id="cb105-5"><a href="#cb105-5" aria-hidden="true" tabindex="-1"></a><span class="co">    Parameters: [jump_rate, flood_left_rate, flood_right_rate]</span></span>
<span id="cb105-6"><a href="#cb105-6" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb105-7"><a href="#cb105-7" aria-hidden="true" tabindex="-1"></a>    <span class="im">import</span> ptdalgorithms <span class="im">as</span> ptd</span>
<span id="cb105-8"><a href="#cb105-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb105-9"><a href="#cb105-9" aria-hidden="true" tabindex="-1"></a>    graph <span class="op">=</span> ptd.Graph(state_length<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb105-10"><a href="#cb105-10" aria-hidden="true" tabindex="-1"></a>    initial_state <span class="op">=</span> [nr_rabbits, <span class="dv">0</span>]</span>
<span id="cb105-11"><a href="#cb105-11" aria-hidden="true" tabindex="-1"></a>    graph.starting_vertex().add_edge(graph.find_or_create_vertex(initial_state), <span class="dv">1</span>)</span>
<span id="cb105-12"><a href="#cb105-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb105-13"><a href="#cb105-13" aria-hidden="true" tabindex="-1"></a>    index <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb105-14"><a href="#cb105-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> index <span class="op">&lt;</span> graph.vertices_length():</span>
<span id="cb105-15"><a href="#cb105-15" aria-hidden="true" tabindex="-1"></a>        vertex <span class="op">=</span> graph.vertex_at(index)</span>
<span id="cb105-16"><a href="#cb105-16" aria-hidden="true" tabindex="-1"></a>        state <span class="op">=</span> vertex.state()</span>
<span id="cb105-17"><a href="#cb105-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb105-18"><a href="#cb105-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> state[<span class="dv">0</span>] <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb105-19"><a href="#cb105-19" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Jump left to right - rate proportional to number of rabbits</span></span>
<span id="cb105-20"><a href="#cb105-20" aria-hidden="true" tabindex="-1"></a>            child_state <span class="op">=</span> [state[<span class="dv">0</span>] <span class="op">-</span> <span class="dv">1</span>, state[<span class="dv">1</span>] <span class="op">+</span> <span class="dv">1</span>]</span>
<span id="cb105-21"><a href="#cb105-21" aria-hidden="true" tabindex="-1"></a>            vertex.add_edge_parameterized(</span>
<span id="cb105-22"><a href="#cb105-22" aria-hidden="true" tabindex="-1"></a>                graph.find_or_create_vertex(child_state),</span>
<span id="cb105-23"><a href="#cb105-23" aria-hidden="true" tabindex="-1"></a>                <span class="dv">0</span>,</span>
<span id="cb105-24"><a href="#cb105-24" aria-hidden="true" tabindex="-1"></a>                [state[<span class="dv">0</span>], <span class="dv">0</span>, <span class="dv">0</span>]  <span class="co"># jump_rate * n_rabbits</span></span>
<span id="cb105-25"><a href="#cb105-25" aria-hidden="true" tabindex="-1"></a>            )</span>
<span id="cb105-26"><a href="#cb105-26" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Left island flooding</span></span>
<span id="cb105-27"><a href="#cb105-27" aria-hidden="true" tabindex="-1"></a>            child_state <span class="op">=</span> [<span class="dv">0</span>, state[<span class="dv">1</span>]]</span>
<span id="cb105-28"><a href="#cb105-28" aria-hidden="true" tabindex="-1"></a>            vertex.add_edge_parameterized(</span>
<span id="cb105-29"><a href="#cb105-29" aria-hidden="true" tabindex="-1"></a>                graph.find_or_create_vertex(child_state),</span>
<span id="cb105-30"><a href="#cb105-30" aria-hidden="true" tabindex="-1"></a>                <span class="dv">0</span>,</span>
<span id="cb105-31"><a href="#cb105-31" aria-hidden="true" tabindex="-1"></a>                [<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">0</span>]  <span class="co"># flood_left_rate</span></span>
<span id="cb105-32"><a href="#cb105-32" aria-hidden="true" tabindex="-1"></a>            )</span>
<span id="cb105-33"><a href="#cb105-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb105-34"><a href="#cb105-34" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> state[<span class="dv">1</span>] <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb105-35"><a href="#cb105-35" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Jump right to left</span></span>
<span id="cb105-36"><a href="#cb105-36" aria-hidden="true" tabindex="-1"></a>            child_state <span class="op">=</span> [state[<span class="dv">0</span>] <span class="op">+</span> <span class="dv">1</span>, state[<span class="dv">1</span>] <span class="op">-</span> <span class="dv">1</span>]</span>
<span id="cb105-37"><a href="#cb105-37" aria-hidden="true" tabindex="-1"></a>            vertex.add_edge_parameterized(</span>
<span id="cb105-38"><a href="#cb105-38" aria-hidden="true" tabindex="-1"></a>                graph.find_or_create_vertex(child_state),</span>
<span id="cb105-39"><a href="#cb105-39" aria-hidden="true" tabindex="-1"></a>                <span class="dv">0</span>,</span>
<span id="cb105-40"><a href="#cb105-40" aria-hidden="true" tabindex="-1"></a>                [state[<span class="dv">1</span>], <span class="dv">0</span>, <span class="dv">0</span>]  <span class="co"># jump_rate * n_rabbits</span></span>
<span id="cb105-41"><a href="#cb105-41" aria-hidden="true" tabindex="-1"></a>            )</span>
<span id="cb105-42"><a href="#cb105-42" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Right island flooding</span></span>
<span id="cb105-43"><a href="#cb105-43" aria-hidden="true" tabindex="-1"></a>            child_state <span class="op">=</span> [state[<span class="dv">0</span>], <span class="dv">0</span>]</span>
<span id="cb105-44"><a href="#cb105-44" aria-hidden="true" tabindex="-1"></a>            vertex.add_edge_parameterized(</span>
<span id="cb105-45"><a href="#cb105-45" aria-hidden="true" tabindex="-1"></a>                graph.find_or_create_vertex(child_state),</span>
<span id="cb105-46"><a href="#cb105-46" aria-hidden="true" tabindex="-1"></a>                <span class="dv">0</span>,</span>
<span id="cb105-47"><a href="#cb105-47" aria-hidden="true" tabindex="-1"></a>                [<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>]  <span class="co"># flood_right_rate</span></span>
<span id="cb105-48"><a href="#cb105-48" aria-hidden="true" tabindex="-1"></a>            )</span>
<span id="cb105-49"><a href="#cb105-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb105-50"><a href="#cb105-50" aria-hidden="true" tabindex="-1"></a>        index <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb105-51"><a href="#cb105-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb105-52"><a href="#cb105-52" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> graph</span>
<span id="cb105-53"><a href="#cb105-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb105-54"><a href="#cb105-54" aria-hidden="true" tabindex="-1"></a><span class="co"># Create a model with 5 rabbits</span></span>
<span id="cb105-55"><a href="#cb105-55" aria-hidden="true" tabindex="-1"></a>symbolic_graph <span class="op">=</span> construct_parameterized_rabbit_model(<span class="dv">5</span>)</span>
<span id="cb105-56"><a href="#cb105-56" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Created parameterized model with </span><span class="sc">{</span>symbolic_graph<span class="sc">.</span>vertices_length()<span class="sc">}</span><span class="ss"> states"</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>Created parameterized model with 67 states</code></pre>
</div>
<div class="cell-output cell-output-error">
<div class="ansi-escaped-output">
<pre><span class="ansi-red-fg ansi-bold">The Kernel crashed while executing code in the current cell or a previous cell. 

</span><span class="ansi-red-fg ansi-bold">Please review the code in the cell(s) to identify a possible cause of the failure. 

</span><span class="ansi-red-fg ansi-bold">Click &lt;a href='https://aka.ms/vscodeJupyterKernelCrash'&gt;here&lt;/a&gt; for more info. 

</span><span class="ansi-red-fg ansi-bold">View Jupyter &lt;a href='command:jupyter.viewOutput'&gt;log&lt;/a&gt; for further details.</span></pre>
</div>
</div>
</div>
<p>Now we perform the key operation: symbolic elimination. This analyzes the graph structure and builds a directed acyclic graph (DAG) of symbolic expressions. The DAG encodes all the dependencies and operations needed to compute moments and distribution functions as a function of the parameter vector. This is the expensive O(n³) operation, but we only do it once.</p>
<div id="cell-127" class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb107"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb107-1"><a href="#cb107-1" aria-hidden="true" tabindex="-1"></a><span class="co"># First set initial parameters (required before elimination)</span></span>
<span id="cb107-2"><a href="#cb107-2" aria-hidden="true" tabindex="-1"></a>initial_params <span class="op">=</span> np.array([<span class="fl">1.0</span>, <span class="fl">2.0</span>, <span class="fl">4.0</span>])  <span class="co"># jump_rate, flood_left, flood_right</span></span>
<span id="cb107-3"><a href="#cb107-3" aria-hidden="true" tabindex="-1"></a>symbolic_graph.update_parameterized_weights(initial_params)</span>
<span id="cb107-4"><a href="#cb107-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-5"><a href="#cb107-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Perform symbolic elimination - this is O(n³) but done once</span></span>
<span id="cb107-6"><a href="#cb107-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Performing symbolic Gaussian elimination..."</span>)</span>
<span id="cb107-7"><a href="#cb107-7" aria-hidden="true" tabindex="-1"></a>dag <span class="op">=</span> symbolic_graph.eliminate_to_dag()</span>
<span id="cb107-8"><a href="#cb107-8" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Created symbolic DAG with </span><span class="sc">{</span>dag<span class="sc">.</span>vertices_length<span class="sc">}</span><span class="ss"> expression nodes"</span>)</span>
<span id="cb107-9"><a href="#cb107-9" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"This DAG can now be evaluated in O(n) time for any parameter vector"</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-error">
<div class="ansi-escaped-output">
<pre><span class="ansi-red-fg ansi-bold">The Kernel crashed while executing code in the current cell or a previous cell. 

</span><span class="ansi-red-fg ansi-bold">Please review the code in the cell(s) to identify a possible cause of the failure. 

</span><span class="ansi-red-fg ansi-bold">Click &lt;a href='https://aka.ms/vscodeJupyterKernelCrash'&gt;here&lt;/a&gt; for more info. 

</span><span class="ansi-red-fg ansi-bold">View Jupyter &lt;a href='command:jupyter.viewOutput'&gt;log&lt;/a&gt; for further details.</span></pre>
</div>
</div>
</div>
<p>With the symbolic DAG created, we can now evaluate it rapidly for different parameter values. Each evaluation is O(n) instead of O(n³). Let’s compare the performance of the traditional approach (updating weights and recomputing) versus the symbolic approach (instantiating the DAG).</p>
<div id="cell-129" class="cell" data-execution_count="1">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb108"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb108-1"><a href="#cb108-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> time</span>
<span id="cb108-2"><a href="#cb108-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-3"><a href="#cb108-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Generate 1000 random parameter vectors to test</span></span>
<span id="cb108-4"><a href="#cb108-4" aria-hidden="true" tabindex="-1"></a>n_evaluations <span class="op">=</span> <span class="dv">1000</span></span>
<span id="cb108-5"><a href="#cb108-5" aria-hidden="true" tabindex="-1"></a>param_vectors <span class="op">=</span> np.random.uniform(<span class="fl">0.5</span>, <span class="fl">5.0</span>, size<span class="op">=</span>(n_evaluations, <span class="dv">3</span>))</span>
<span id="cb108-6"><a href="#cb108-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-7"><a href="#cb108-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Method 1: Traditional approach - update weights each time</span></span>
<span id="cb108-8"><a href="#cb108-8" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Method 1: Traditional update_parameterized_weights approach"</span>)</span>
<span id="cb108-9"><a href="#cb108-9" aria-hidden="true" tabindex="-1"></a>start <span class="op">=</span> time.time()</span>
<span id="cb108-10"><a href="#cb108-10" aria-hidden="true" tabindex="-1"></a>traditional_expectations <span class="op">=</span> []</span>
<span id="cb108-11"><a href="#cb108-11" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> params <span class="kw">in</span> param_vectors[:<span class="dv">100</span>]:  <span class="co"># Just 100 to avoid taking too long</span></span>
<span id="cb108-12"><a href="#cb108-12" aria-hidden="true" tabindex="-1"></a>    symbolic_graph.update_parameterized_weights(params)</span>
<span id="cb108-13"><a href="#cb108-13" aria-hidden="true" tabindex="-1"></a>    traditional_expectations.append(symbolic_graph.expectation())</span>
<span id="cb108-14"><a href="#cb108-14" aria-hidden="true" tabindex="-1"></a>traditional_time <span class="op">=</span> time.time() <span class="op">-</span> start</span>
<span id="cb108-15"><a href="#cb108-15" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"  Time for 100 evaluations: </span><span class="sc">{</span>traditional_time<span class="sc">:.3f}</span><span class="ss"> seconds"</span>)</span>
<span id="cb108-16"><a href="#cb108-16" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"  Time per evaluation: </span><span class="sc">{</span>traditional_time<span class="op">/</span><span class="dv">100</span><span class="op">*</span><span class="dv">1000</span><span class="sc">:.2f}</span><span class="ss"> ms"</span>)</span>
<span id="cb108-17"><a href="#cb108-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-18"><a href="#cb108-18" aria-hidden="true" tabindex="-1"></a><span class="co"># Method 2: Symbolic elimination approach - instantiate DAG</span></span>
<span id="cb108-19"><a href="#cb108-19" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">Method 2: Symbolic elimination with DAG instantiation"</span>)</span>
<span id="cb108-20"><a href="#cb108-20" aria-hidden="true" tabindex="-1"></a>start <span class="op">=</span> time.time()</span>
<span id="cb108-21"><a href="#cb108-21" aria-hidden="true" tabindex="-1"></a>symbolic_expectations <span class="op">=</span> []</span>
<span id="cb108-22"><a href="#cb108-22" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> params <span class="kw">in</span> param_vectors:</span>
<span id="cb108-23"><a href="#cb108-23" aria-hidden="true" tabindex="-1"></a>    concrete_dag <span class="op">=</span> dag.instantiate(params)</span>
<span id="cb108-24"><a href="#cb108-24" aria-hidden="true" tabindex="-1"></a>    symbolic_expectations.append(concrete_dag.expectation())</span>
<span id="cb108-25"><a href="#cb108-25" aria-hidden="true" tabindex="-1"></a>symbolic_time <span class="op">=</span> time.time() <span class="op">-</span> start</span>
<span id="cb108-26"><a href="#cb108-26" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"  Time for 1000 evaluations: </span><span class="sc">{</span>symbolic_time<span class="sc">:.3f}</span><span class="ss"> seconds"</span>)</span>
<span id="cb108-27"><a href="#cb108-27" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"  Time per evaluation: </span><span class="sc">{</span>symbolic_time<span class="op">/</span><span class="dv">1000</span><span class="op">*</span><span class="dv">1000</span><span class="sc">:.2f}</span><span class="ss"> ms"</span>)</span>
<span id="cb108-28"><a href="#cb108-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-29"><a href="#cb108-29" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss">Speedup: </span><span class="sc">{</span>(traditional_time<span class="op">/</span><span class="dv">100</span>) <span class="op">/</span> (symbolic_time<span class="op">/</span><span class="dv">1000</span>)<span class="sc">:.1f}</span><span class="ss">x faster"</span>)</span>
<span id="cb108-30"><a href="#cb108-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-31"><a href="#cb108-31" aria-hidden="true" tabindex="-1"></a><span class="co"># Verify results match</span></span>
<span id="cb108-32"><a href="#cb108-32" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss">Verification: expectations match = </span><span class="sc">{</span>np<span class="sc">.</span>allclose(traditional_expectations, symbolic_expectations[:<span class="dv">100</span>], rtol<span class="op">=</span><span class="fl">1e-10</span>)<span class="sc">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-error">
<div class="ansi-escaped-output">
<pre>  <span class="ansi-cyan-fg">Cell</span><span class="ansi-cyan-fg"> </span><span class="ansi-green-fg">In[1]</span><span class="ansi-green-fg">, line 32</span>
<span class="ansi-red-fg">    </span><span class="ansi-red-fg">print(f"\nVerification: expectations match = {np.allclose(traditional_expectations, symbolic_expectations[:100], rtol=1e-10)}</span>
          ^
<span class="ansi-red-fg">SyntaxError</span><span class="ansi-red-fg">:</span> unterminated f-string literal (detected at line 32)
</pre>
</div>
</div>
</div>
<p>The speedup is substantial even for this modestly-sized model with only ~10 states. For larger models with hundreds or thousands of states, the speedup can easily reach 100× or 1000×. This makes the difference between inference being computationally infeasible and running in reasonable time.</p>
<p>The symbolic elimination approach is particularly powerful when combined with JAX for automatic differentiation and JIT compilation. The JAX integration allows us to convert the symbolic DAG into a JAX function that can be differentiated (for gradient-based inference) and compiled to highly optimized machine code. Let’s see how this works.</p>
<div id="cell-131" class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb109"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb109-1"><a href="#cb109-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Check if JAX is available</span></span>
<span id="cb109-2"><a href="#cb109-2" aria-hidden="true" tabindex="-1"></a><span class="cf">try</span>:</span>
<span id="cb109-3"><a href="#cb109-3" aria-hidden="true" tabindex="-1"></a>    <span class="im">import</span> jax</span>
<span id="cb109-4"><a href="#cb109-4" aria-hidden="true" tabindex="-1"></a>    <span class="im">import</span> jax.numpy <span class="im">as</span> jnp</span>
<span id="cb109-5"><a href="#cb109-5" aria-hidden="true" tabindex="-1"></a>    HAS_JAX <span class="op">=</span> <span class="va">True</span></span>
<span id="cb109-6"><a href="#cb109-6" aria-hidden="true" tabindex="-1"></a><span class="cf">except</span> <span class="pp">ImportError</span>:</span>
<span id="cb109-7"><a href="#cb109-7" aria-hidden="true" tabindex="-1"></a>    HAS_JAX <span class="op">=</span> <span class="va">False</span></span>
<span id="cb109-8"><a href="#cb109-8" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"JAX not available - install with: pip install jax"</span>)</span>
<span id="cb109-9"><a href="#cb109-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb109-10"><a href="#cb109-10" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> HAS_JAX:</span>
<span id="cb109-11"><a href="#cb109-11" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Convert the symbolic DAG to a JAX-compatible function</span></span>
<span id="cb109-12"><a href="#cb109-12" aria-hidden="true" tabindex="-1"></a>    <span class="co"># This creates a pure function that can be JIT compiled and differentiated</span></span>
<span id="cb109-13"><a href="#cb109-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> expectation_fn(theta):</span>
<span id="cb109-14"><a href="#cb109-14" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""Compute expectation given parameter vector theta"""</span></span>
<span id="cb109-15"><a href="#cb109-15" aria-hidden="true" tabindex="-1"></a>        concrete <span class="op">=</span> dag.instantiate(theta)</span>
<span id="cb109-16"><a href="#cb109-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> concrete.expectation()</span>
<span id="cb109-17"><a href="#cb109-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb109-18"><a href="#cb109-18" aria-hidden="true" tabindex="-1"></a>    <span class="co"># JIT compile the function for maximum performance</span></span>
<span id="cb109-19"><a href="#cb109-19" aria-hidden="true" tabindex="-1"></a>    expectation_jit <span class="op">=</span> jax.jit(expectation_fn)</span>
<span id="cb109-20"><a href="#cb109-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb109-21"><a href="#cb109-21" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Create a gradient function for gradient-based optimization/inference</span></span>
<span id="cb109-22"><a href="#cb109-22" aria-hidden="true" tabindex="-1"></a>    grad_expectation <span class="op">=</span> jax.grad(expectation_fn)</span>
<span id="cb109-23"><a href="#cb109-23" aria-hidden="true" tabindex="-1"></a>    grad_expectation_jit <span class="op">=</span> jax.jit(grad_expectation)</span>
<span id="cb109-24"><a href="#cb109-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb109-25"><a href="#cb109-25" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Test the JIT-compiled function</span></span>
<span id="cb109-26"><a href="#cb109-26" aria-hidden="true" tabindex="-1"></a>    test_params <span class="op">=</span> jnp.array([<span class="fl">1.0</span>, <span class="fl">2.0</span>, <span class="fl">4.0</span>])</span>
<span id="cb109-27"><a href="#cb109-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb109-28"><a href="#cb109-28" aria-hidden="true" tabindex="-1"></a>    <span class="co"># First call includes compilation time</span></span>
<span id="cb109-29"><a href="#cb109-29" aria-hidden="true" tabindex="-1"></a>    start <span class="op">=</span> time.time()</span>
<span id="cb109-30"><a href="#cb109-30" aria-hidden="true" tabindex="-1"></a>    result1 <span class="op">=</span> expectation_jit(test_params)</span>
<span id="cb109-31"><a href="#cb109-31" aria-hidden="true" tabindex="-1"></a>    first_time <span class="op">=</span> time.time() <span class="op">-</span> start</span>
<span id="cb109-32"><a href="#cb109-32" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"First JIT call (includes compilation): </span><span class="sc">{</span>first_time<span class="op">*</span><span class="dv">1000</span><span class="sc">:.2f}</span><span class="ss"> ms"</span>)</span>
<span id="cb109-33"><a href="#cb109-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb109-34"><a href="#cb109-34" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Subsequent calls use compiled code</span></span>
<span id="cb109-35"><a href="#cb109-35" aria-hidden="true" tabindex="-1"></a>    start <span class="op">=</span> time.time()</span>
<span id="cb109-36"><a href="#cb109-36" aria-hidden="true" tabindex="-1"></a>    result2 <span class="op">=</span> expectation_jit(test_params)</span>
<span id="cb109-37"><a href="#cb109-37" aria-hidden="true" tabindex="-1"></a>    second_time <span class="op">=</span> time.time() <span class="op">-</span> start</span>
<span id="cb109-38"><a href="#cb109-38" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Second JIT call (compiled): </span><span class="sc">{</span>second_time<span class="op">*</span><span class="dv">1000</span><span class="sc">:.2f}</span><span class="ss"> ms"</span>)</span>
<span id="cb109-39"><a href="#cb109-39" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Expectation: </span><span class="sc">{</span>result2<span class="sc">:.6f}</span><span class="ss">"</span>)</span>
<span id="cb109-40"><a href="#cb109-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb109-41"><a href="#cb109-41" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Compute gradient</span></span>
<span id="cb109-42"><a href="#cb109-42" aria-hidden="true" tabindex="-1"></a>    start <span class="op">=</span> time.time()</span>
<span id="cb109-43"><a href="#cb109-43" aria-hidden="true" tabindex="-1"></a>    gradient <span class="op">=</span> grad_expectation_jit(test_params)</span>
<span id="cb109-44"><a href="#cb109-44" aria-hidden="true" tabindex="-1"></a>    grad_time <span class="op">=</span> time.time() <span class="op">-</span> start</span>
<span id="cb109-45"><a href="#cb109-45" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss">Gradient computation: </span><span class="sc">{</span>grad_time<span class="op">*</span><span class="dv">1000</span><span class="sc">:.2f}</span><span class="ss"> ms"</span>)</span>
<span id="cb109-46"><a href="#cb109-46" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Gradient: </span><span class="sc">{</span>gradient<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb109-47"><a href="#cb109-47" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">These gradients are exact (via automatic differentiation) and can be used"</span>)</span>
<span id="cb109-48"><a href="#cb109-48" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"for gradient-based inference methods like SVGD, HMC, or variational inference"</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p>The combination of symbolic elimination, JAX compilation, and automatic differentiation creates a powerful workflow for parameter inference. The symbolic DAG removes the O(n³) bottleneck, JIT compilation optimizes the resulting O(n) evaluation, and automatic differentiation provides exact gradients without manual derivation or finite differences. This is precisely the workflow we will use in the SVGD section later in this tutorial, where we will estimate rabbit model parameters from observed data.</p>
<p>For now, the key takeaway is that whenever you have a parameterized model that you need to evaluate many times—whether for parameter exploration, sensitivity analysis, or Bayesian inference—symbolic elimination should be your default choice. The performance improvement is dramatic, and the integration with JAX opens the door to gradient-based methods and GPU acceleration.</p>
</section>
<section id="caching-dags" class="level1">
<h1>Caching DAGs</h1>
<section id="across-sessions" class="level2">
<h2 class="anchored" data-anchor-id="across-sessions">Across Sessions</h2>
<p>Discription here…</p>
<p>Now let’s see caching in action by creating models and observing cache hits and misses. When we create a model for the first time, the cache will miss (no entry exists) and symbolic elimination will run normally. When we create the same model again—even with different initial parameter values—the cache will hit and return the pre-computed symbolic DAG instantly.</p>
<div id="cell-135" class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb110"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb110-1"><a href="#cb110-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> time</span>
<span id="cb110-2"><a href="#cb110-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb110-3"><a href="#cb110-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Create a larger rabbit model to see timing differences more clearly</span></span>
<span id="cb110-4"><a href="#cb110-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> larger_rabbit_callback(state, max_rabbits<span class="op">=</span><span class="dv">5</span>):</span>
<span id="cb110-5"><a href="#cb110-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">len</span>(state) <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb110-6"><a href="#cb110-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> [([<span class="dv">5</span>, <span class="dv">5</span>], <span class="fl">1.0</span>, [<span class="fl">1.0</span>, <span class="fl">0.0</span>, <span class="fl">0.0</span>])]</span>
<span id="cb110-7"><a href="#cb110-7" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb110-8"><a href="#cb110-8" aria-hidden="true" tabindex="-1"></a>    n1, n2 <span class="op">=</span> state[<span class="dv">0</span>], state[<span class="dv">1</span>]</span>
<span id="cb110-9"><a href="#cb110-9" aria-hidden="true" tabindex="-1"></a>    transitions <span class="op">=</span> []</span>
<span id="cb110-10"><a href="#cb110-10" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb110-11"><a href="#cb110-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n1 <span class="op">+</span> n2 <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb110-12"><a href="#cb110-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> []  <span class="co"># Absorbing state</span></span>
<span id="cb110-13"><a href="#cb110-13" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb110-14"><a href="#cb110-14" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Births (parameter 0)</span></span>
<span id="cb110-15"><a href="#cb110-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n1 <span class="op">&gt;</span> <span class="dv">0</span> <span class="kw">and</span> n1 <span class="op">+</span> n2 <span class="op">&lt;</span> max_rabbits:</span>
<span id="cb110-16"><a href="#cb110-16" aria-hidden="true" tabindex="-1"></a>        transitions.append(([n1 <span class="op">+</span> <span class="dv">1</span>, n2], <span class="fl">0.0</span>, [n1 <span class="op">*</span> <span class="fl">0.5</span>, <span class="fl">0.0</span>, <span class="fl">0.0</span>]))</span>
<span id="cb110-17"><a href="#cb110-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n2 <span class="op">&gt;</span> <span class="dv">0</span> <span class="kw">and</span> n1 <span class="op">+</span> n2 <span class="op">&lt;</span> max_rabbits:</span>
<span id="cb110-18"><a href="#cb110-18" aria-hidden="true" tabindex="-1"></a>        transitions.append(([n1, n2 <span class="op">+</span> <span class="dv">1</span>], <span class="fl">0.0</span>, [n2 <span class="op">*</span> <span class="fl">0.5</span>, <span class="fl">0.0</span>, <span class="fl">0.0</span>]))</span>
<span id="cb110-19"><a href="#cb110-19" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb110-20"><a href="#cb110-20" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Deaths (parameter 1)</span></span>
<span id="cb110-21"><a href="#cb110-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n1 <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb110-22"><a href="#cb110-22" aria-hidden="true" tabindex="-1"></a>        transitions.append(([n1 <span class="op">-</span> <span class="dv">1</span>, n2], <span class="fl">0.0</span>, [<span class="fl">0.0</span>, n1 <span class="op">*</span> <span class="fl">0.3</span>, <span class="fl">0.0</span>]))</span>
<span id="cb110-23"><a href="#cb110-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n2 <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb110-24"><a href="#cb110-24" aria-hidden="true" tabindex="-1"></a>        transitions.append(([n1, n2 <span class="op">-</span> <span class="dv">1</span>], <span class="fl">0.0</span>, [<span class="fl">0.0</span>, n2 <span class="op">*</span> <span class="fl">0.3</span>, <span class="fl">0.0</span>]))</span>
<span id="cb110-25"><a href="#cb110-25" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb110-26"><a href="#cb110-26" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Migration (parameter 2)</span></span>
<span id="cb110-27"><a href="#cb110-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n1 <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb110-28"><a href="#cb110-28" aria-hidden="true" tabindex="-1"></a>        transitions.append(([n1 <span class="op">-</span> <span class="dv">1</span>, n2 <span class="op">+</span> <span class="dv">1</span>], <span class="fl">0.0</span>, [<span class="fl">0.0</span>, <span class="fl">0.0</span>, n1 <span class="op">*</span> <span class="fl">0.2</span>]))</span>
<span id="cb110-29"><a href="#cb110-29" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n2 <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb110-30"><a href="#cb110-30" aria-hidden="true" tabindex="-1"></a>        transitions.append(([n1 <span class="op">+</span> <span class="dv">1</span>, n2 <span class="op">-</span> <span class="dv">1</span>], <span class="fl">0.0</span>, [<span class="fl">0.0</span>, <span class="fl">0.0</span>, n2 <span class="op">*</span> <span class="fl">0.2</span>]))</span>
<span id="cb110-31"><a href="#cb110-31" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb110-32"><a href="#cb110-32" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> transitions</span>
<span id="cb110-33"><a href="#cb110-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb110-34"><a href="#cb110-34" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"First construction (cache miss expected)..."</span>)</span>
<span id="cb110-35"><a href="#cb110-35" aria-hidden="true" tabindex="-1"></a>start <span class="op">=</span> time.time()</span>
<span id="cb110-36"><a href="#cb110-36" aria-hidden="true" tabindex="-1"></a>graph1 <span class="op">=</span> Graph(callback<span class="op">=</span>larger_rabbit_callback, parameterized<span class="op">=</span><span class="va">True</span>, max_rabbits<span class="op">=</span><span class="dv">5</span>)</span>
<span id="cb110-37"><a href="#cb110-37" aria-hidden="true" tabindex="-1"></a>model1 <span class="op">=</span> Graph.pmf_from_graph(graph1, use_cache<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb110-38"><a href="#cb110-38" aria-hidden="true" tabindex="-1"></a>time1 <span class="op">=</span> time.time() <span class="op">-</span> start</span>
<span id="cb110-39"><a href="#cb110-39" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"✓ Completed in </span><span class="sc">{</span>time1<span class="sc">:.4f}</span><span class="ss">s (includes symbolic elimination + caching)</span><span class="ch">\n</span><span class="ss">"</span>)</span>
<span id="cb110-40"><a href="#cb110-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb110-41"><a href="#cb110-41" aria-hidden="true" tabindex="-1"></a><span class="co"># Simulate a new Python session: create the same model with different initial parameters</span></span>
<span id="cb110-42"><a href="#cb110-42" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Second construction with same structure (cache hit expected)..."</span>)</span>
<span id="cb110-43"><a href="#cb110-43" aria-hidden="true" tabindex="-1"></a>start <span class="op">=</span> time.time()</span>
<span id="cb110-44"><a href="#cb110-44" aria-hidden="true" tabindex="-1"></a>graph2 <span class="op">=</span> Graph(callback<span class="op">=</span>larger_rabbit_callback, parameterized<span class="op">=</span><span class="va">True</span>, max_rabbits<span class="op">=</span><span class="dv">5</span>)</span>
<span id="cb110-45"><a href="#cb110-45" aria-hidden="true" tabindex="-1"></a>model2 <span class="op">=</span> Graph.pmf_from_graph(graph2, use_cache<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb110-46"><a href="#cb110-46" aria-hidden="true" tabindex="-1"></a>time2 <span class="op">=</span> time.time() <span class="op">-</span> start</span>
<span id="cb110-47"><a href="#cb110-47" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"✓ Completed in </span><span class="sc">{</span>time2<span class="sc">:.4f}</span><span class="ss">s (loaded from cache!)</span><span class="ch">\n</span><span class="ss">"</span>)</span>
<span id="cb110-48"><a href="#cb110-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb110-49"><a href="#cb110-49" aria-hidden="true" tabindex="-1"></a>speedup <span class="op">=</span> time1 <span class="op">/</span> time2 <span class="cf">if</span> time2 <span class="op">&gt;</span> <span class="dv">0</span> <span class="cf">else</span> <span class="dv">0</span></span>
<span id="cb110-50"><a href="#cb110-50" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"🚀 Speedup from caching: </span><span class="sc">{</span>speedup<span class="sc">:.1f}</span><span class="ss">×"</span>)</span>
<span id="cb110-51"><a href="#cb110-51" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss">Key Insight:"</span>)</span>
<span id="cb110-52"><a href="#cb110-52" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"  • Graph topology and parameterization are identical"</span>)</span>
<span id="cb110-53"><a href="#cb110-53" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"  • Symbolic DAG is the same regardless of parameter values"</span>)</span>
<span id="cb110-54"><a href="#cb110-54" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"  • Cache recognizes this and avoids redundant computation"</span>)</span>
<span id="cb110-55"><a href="#cb110-55" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"  • This speedup applies across all Python sessions!"</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>First construction (cache miss expected)...</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>/Users/kmt/PtDAlgorithms/src/ptdalgorithms/__init__.py:1161: UserWarning: Symbolic cache unavailable: Object of type ndarray is not JSON serializable
  warnings.warn(f"Symbolic cache unavailable: {e}", UserWarning)</code></pre>
</div>
<div class="cell-output cell-output-error">
<div class="ansi-escaped-output">
<pre><span class="ansi-red-fg">---------------------------------------------------------------------------</span>
<span class="ansi-red-fg">RuntimeError</span>                              Traceback (most recent call last)
<span class="ansi-cyan-fg">Cell</span><span class="ansi-cyan-fg"> </span><span class="ansi-green-fg">In[67]</span><span class="ansi-green-fg">, line 37</span>
<span class="ansi-green-fg">     35</span> start = time.time()
<span class="ansi-green-fg">     36</span> graph1 = Graph(callback=larger_rabbit_callback, parameterized=<span style="font-weight:bold;color:rgb(0,135,0)">True</span>, max_rabbits=<span class="ansi-green-fg">5</span>)
<span class="ansi-green-fg">---&gt; </span><span class="ansi-green-fg">37</span> model1 = <span class="ansi-yellow-bg">Graph</span><span class="ansi-yellow-bg">.</span><span class="ansi-yellow-bg">pmf_from_graph</span><span class="ansi-yellow-bg">(</span><span class="ansi-yellow-bg">graph1</span><span class="ansi-yellow-bg">,</span><span class="ansi-yellow-bg"> </span><span class="ansi-yellow-bg">use_cache</span><span class="ansi-yellow-bg">=</span><span style="font-weight:bold;color:rgb(0,135,0)" class="ansi-yellow-bg">True</span><span class="ansi-yellow-bg">)</span>
<span class="ansi-green-fg">     38</span> time1 = time.time() - start
<span class="ansi-green-fg">     39</span> <span style="color:rgb(0,135,0)">print</span>(<span class="ansi-yellow-fg">f</span><span class="ansi-yellow-fg">"</span><span class="ansi-yellow-fg">✓ Completed in </span><span style="font-weight:bold;color:rgb(175,95,135)">{</span>time1<span style="font-weight:bold;color:rgb(175,95,135)">:</span><span class="ansi-yellow-fg">.4f</span><span style="font-weight:bold;color:rgb(175,95,135)">}</span><span class="ansi-yellow-fg">s (includes symbolic elimination + caching)</span><span style="font-weight:bold;color:rgb(175,95,0)">\n</span><span class="ansi-yellow-fg">"</span>)

<span class="ansi-cyan-fg">File </span><span class="ansi-green-fg">~/PtDAlgorithms/src/ptdalgorithms/__init__.py:1181</span>, in <span class="ansi-cyan-fg">Graph.pmf_from_graph</span><span class="ansi-blue-fg">(cls, graph, discrete, use_cache)</span>
<span class="ansi-green-fg">   1177</span>     f.write(cpp_code)
<span class="ansi-green-fg">   1179</span> <span style="font-style:italic;color:rgb(95,135,135)"># Use pmf_from_cpp() to compile and create JAX-compatible function</span>
<span class="ansi-green-fg">   1180</span> <span style="font-style:italic;color:rgb(95,135,135)"># This gives us full JAX support (jit, grad, vmap)</span>
<span class="ansi-green-fg">-&gt; </span><span class="ansi-green-fg">1181</span> base_model = <span style="color:rgb(0,135,0)" class="ansi-yellow-bg">cls</span><span class="ansi-yellow-bg">.</span><span class="ansi-yellow-bg">pmf_from_cpp</span><span class="ansi-yellow-bg">(</span><span class="ansi-yellow-bg">temp_file</span><span class="ansi-yellow-bg">,</span><span class="ansi-yellow-bg"> </span><span class="ansi-yellow-bg">discrete</span><span class="ansi-yellow-bg">=</span><span class="ansi-yellow-bg">discrete</span><span class="ansi-yellow-bg">)</span>
<span class="ansi-green-fg">   1183</span> <span style="font-style:italic;color:rgb(95,135,135)"># Return appropriate signature based on parameterization</span>
<span class="ansi-green-fg">   1184</span> <span style="font-weight:bold;color:rgb(0,135,0)">if</span> has_param_edges:
<span class="ansi-green-fg">   1185</span>     <span style="font-style:italic;color:rgb(95,135,135)"># Parameterized: return (theta, times) -&gt; pmf</span>

<span class="ansi-cyan-fg">File </span><span class="ansi-green-fg">~/PtDAlgorithms/src/ptdalgorithms/__init__.py:1471</span>, in <span class="ansi-cyan-fg">Graph.pmf_from_cpp</span><span class="ansi-blue-fg">(cls, cpp_file, discrete)</span>
<span class="ansi-green-fg">   1469</span> cache_key = <span class="ansi-yellow-fg">f</span><span class="ansi-yellow-fg">"</span><span style="font-weight:bold;color:rgb(175,95,135)">{</span>lib_name<span style="font-weight:bold;color:rgb(175,95,135)">}</span><span class="ansi-yellow-fg">_discrete_</span><span style="font-weight:bold;color:rgb(175,95,135)">{</span>discrete<span style="font-weight:bold;color:rgb(175,95,135)">}</span><span class="ansi-yellow-fg">"</span>
<span class="ansi-green-fg">   1470</span> <span style="font-weight:bold;color:rgb(0,135,0)">if</span> cache_key <span style="font-weight:bold;color:rgb(175,0,255)">not</span> <span style="font-weight:bold;color:rgb(175,0,255)">in</span> _lib_cache:
<span class="ansi-green-fg">-&gt; </span><span class="ansi-green-fg">1471</span>     lib_path = <span class="ansi-yellow-bg">_compile_wrapper_library</span><span class="ansi-yellow-bg">(</span><span class="ansi-yellow-bg">wrapper_code</span><span class="ansi-yellow-bg">,</span><span class="ansi-yellow-bg"> </span><span class="ansi-yellow-bg">lib_name</span><span class="ansi-yellow-bg">)</span>
<span class="ansi-green-fg">   1472</span>     <span style="font-style:italic;color:rgb(95,135,135)"># Use PyDLL instead of CDLL to manage GIL automatically</span>
<span class="ansi-green-fg">   1473</span>     lib = ctypes.PyDLL(lib_path)

<span class="ansi-cyan-fg">File </span><span class="ansi-green-fg">~/PtDAlgorithms/src/ptdalgorithms/__init__.py:605</span>, in <span class="ansi-cyan-fg">_compile_wrapper_library</span><span class="ansi-blue-fg">(wrapper_code, lib_name, extra_includes)</span>
<span class="ansi-green-fg">    603</span>     result = subprocess.run(cmd, capture_output=<span style="font-weight:bold;color:rgb(0,135,0)">True</span>, text=<span style="font-weight:bold;color:rgb(0,135,0)">True</span>)
<span class="ansi-green-fg">    604</span>     <span style="font-weight:bold;color:rgb(0,135,0)">if</span> result.returncode != <span class="ansi-green-fg">0</span>:
<span class="ansi-green-fg">--&gt; </span><span class="ansi-green-fg">605</span>         <span style="font-weight:bold;color:rgb(0,135,0)">raise</span> <span style="font-weight:bold;color:rgb(215,95,95)">RuntimeError</span>(<span class="ansi-yellow-fg">f</span><span class="ansi-yellow-fg">"</span><span class="ansi-yellow-fg">Compilation failed:</span><span style="font-weight:bold;color:rgb(175,95,0)">\n</span><span style="font-weight:bold;color:rgb(175,95,135)">{</span>result.stderr<span style="font-weight:bold;color:rgb(175,95,135)">}</span><span class="ansi-yellow-fg">"</span>)
<span class="ansi-green-fg">    606</span> <span style="font-weight:bold;color:rgb(0,135,0)">finally</span>:
<span class="ansi-green-fg">    607</span>     os.unlink(wrapper_file)

<span class="ansi-red-fg">RuntimeError</span>: Compilation failed:
clang++: warning: treating 'c' input as 'c++' when in C++ mode, this behavior is deprecated [-Wdeprecated]
/Users/kmt/PtDAlgorithms/src/c/ptdalgorithms.c:6351:33: error: cannot initialize a variable of type 'struct ptd_trace_operation *' with an rvalue of type 'void *'
 6351 |     struct ptd_trace_operation *new_ops = realloc(
      |                                 ^         ~~~~~~~~
 6352 |         trace-&gt;operations,
      |         ~~~~~~~~~~~~~~~~~~
 6353 |         new_capacity * sizeof(struct ptd_trace_operation)
      |         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 6354 |     );
      |     ~
/Users/kmt/PtDAlgorithms/src/c/ptdalgorithms.c:6408:24: error: assigning to 'double *' from incompatible type 'void *'
 6408 |     op-&gt;coefficients = malloc(coefficients_length * sizeof(double));
      |                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/Users/kmt/PtDAlgorithms/src/c/ptdalgorithms.c:6442:20: error: assigning to 'size_t *' (aka 'unsigned long *') from incompatible type 'void *'
 6442 |     op-&gt;operands = malloc(2 * sizeof(size_t));
      |                    ^~~~~~~~~~~~~~~~~~~~~~~~~~
/Users/kmt/PtDAlgorithms/src/c/ptdalgorithms.c:6477:20: error: assigning to 'size_t *' (aka 'unsigned long *') from incompatible type 'void *'
 6477 |     op-&gt;operands = malloc(2 * sizeof(size_t));
      |                    ^~~~~~~~~~~~~~~~~~~~~~~~~~
/Users/kmt/PtDAlgorithms/src/c/ptdalgorithms.c:6512:20: error: assigning to 'size_t *' (aka 'unsigned long *') from incompatible type 'void *'
 6512 |     op-&gt;operands = malloc(2 * sizeof(size_t));
      |                    ^~~~~~~~~~~~~~~~~~~~~~~~~~
/Users/kmt/PtDAlgorithms/src/c/ptdalgorithms.c:6546:20: error: assigning to 'size_t *' (aka 'unsigned long *') from incompatible type 'void *'
 6546 |     op-&gt;operands = malloc(1 * sizeof(size_t));
      |                    ^~~~~~~~~~~~~~~~~~~~~~~~~~
/Users/kmt/PtDAlgorithms/src/c/ptdalgorithms.c:6580:20: error: assigning to 'size_t *' (aka 'unsigned long *') from incompatible type 'void *'
 6580 |     op-&gt;operands = malloc(n_operands * sizeof(size_t));
      |                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/Users/kmt/PtDAlgorithms/src/c/ptdalgorithms.c:6606:9: warning: 'sprintf' is deprecated: This function is provided for compatibility reasons only.  Due to security concerns inherent in the design of sprintf(3), it is highly recommended that you use snprintf(3) instead. [-Wdeprecated-declarations]
 6606 |         sprintf((char*)ptd_err, "ptd_record_elimination_trace: graph is not parameterized");
      |         ^
/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_stdio.h:278:1: note: 'sprintf' has been explicitly marked deprecated here
  278 | __deprecated_msg("This function is provided for compatibility reasons only.  Due to security concerns inherent in the design of sprintf(3), it is highly recommended that you use snprintf(3) instead.")
      | ^
/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/cdefs.h:218:48: note: expanded from macro '__deprecated_msg'
  218 |         #define __deprecated_msg(_msg) __attribute__((__deprecated__(_msg)))
      |                                                       ^
/Users/kmt/PtDAlgorithms/src/c/ptdalgorithms.c:6611:35: error: cannot initialize a variable of type 'struct ptd_elimination_trace *' with an rvalue of type 'void *'
 6611 |     struct ptd_elimination_trace *trace = malloc(sizeof(*trace));
      |                                   ^       ~~~~~~~~~~~~~~~~~~~~~~
/Users/kmt/PtDAlgorithms/src/c/ptdalgorithms.c:6613:9: warning: 'sprintf' is deprecated: This function is provided for compatibility reasons only.  Due to security concerns inherent in the design of sprintf(3), it is highly recommended that you use snprintf(3) instead. [-Wdeprecated-declarations]
 6613 |         sprintf((char*)ptd_err, "ptd_record_elimination_trace: failed to allocate trace");
      |         ^
/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_stdio.h:278:1: note: 'sprintf' has been explicitly marked deprecated here
  278 | __deprecated_msg("This function is provided for compatibility reasons only.  Due to security concerns inherent in the design of sprintf(3), it is highly recommended that you use snprintf(3) instead.")
      | ^
/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/cdefs.h:218:48: note: expanded from macro '__deprecated_msg'
  218 |         #define __deprecated_msg(_msg) __attribute__((__deprecated__(_msg)))
      |                                                       ^
/Users/kmt/PtDAlgorithms/src/c/ptdalgorithms.c:6631:25: error: assigning to 'struct ptd_trace_operation *' from incompatible type 'void *'
 6631 |     trace-&gt;operations = malloc(operations_capacity * sizeof(struct ptd_trace_operation));
      |                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/Users/kmt/PtDAlgorithms/src/c/ptdalgorithms.c:6633:9: warning: 'sprintf' is deprecated: This function is provided for compatibility reasons only.  Due to security concerns inherent in the design of sprintf(3), it is highly recommended that you use snprintf(3) instead. [-Wdeprecated-declarations]
 6633 |         sprintf((char*)ptd_err, "ptd_record_elimination_trace: failed to allocate operations");
      |         ^
/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_stdio.h:278:1: note: 'sprintf' has been explicitly marked deprecated here
  278 | __deprecated_msg("This function is provided for compatibility reasons only.  Due to security concerns inherent in the design of sprintf(3), it is highly recommended that you use snprintf(3) instead.")
      | ^
/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/cdefs.h:218:48: note: expanded from macro '__deprecated_msg'
  218 |         #define __deprecated_msg(_msg) __attribute__((__deprecated__(_msg)))
      |                                                       ^
/Users/kmt/PtDAlgorithms/src/c/ptdalgorithms.c:6640:27: error: assigning to 'size_t *' (aka 'unsigned long *') from incompatible type 'void *'
 6640 |     trace-&gt;vertex_rates = malloc(trace-&gt;n_vertices * sizeof(size_t));
      |                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/Users/kmt/PtDAlgorithms/src/c/ptdalgorithms.c:6641:25: error: assigning to 'size_t **' (aka 'unsigned long **') from incompatible type 'void *'
 6641 |     trace-&gt;edge_probs = malloc(trace-&gt;n_vertices * sizeof(size_t*));
      |                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/Users/kmt/PtDAlgorithms/src/c/ptdalgorithms.c:6642:33: error: assigning to 'size_t *' (aka 'unsigned long *') from incompatible type 'void *'
 6642 |     trace-&gt;edge_probs_lengths = calloc(trace-&gt;n_vertices, sizeof(size_t));
      |                                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/Users/kmt/PtDAlgorithms/src/c/ptdalgorithms.c:6643:29: error: assigning to 'size_t **' (aka 'unsigned long **') from incompatible type 'void *'
 6643 |     trace-&gt;vertex_targets = malloc(trace-&gt;n_vertices * sizeof(size_t*));
      |                             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/Users/kmt/PtDAlgorithms/src/c/ptdalgorithms.c:6644:37: error: assigning to 'size_t *' (aka 'unsigned long *') from incompatible type 'void *'
 6644 |     trace-&gt;vertex_targets_lengths = calloc(trace-&gt;n_vertices, sizeof(size_t));
      |                                     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/Users/kmt/PtDAlgorithms/src/c/ptdalgorithms.c:6649:9: warning: 'sprintf' is deprecated: This function is provided for compatibility reasons only.  Due to security concerns inherent in the design of sprintf(3), it is highly recommended that you use snprintf(3) instead. [-Wdeprecated-declarations]
 6649 |         sprintf((char*)ptd_err, "ptd_record_elimination_trace: failed to allocate vertex mappings");
      |         ^
/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_stdio.h:278:1: note: 'sprintf' has been explicitly marked deprecated here
  278 | __deprecated_msg("This function is provided for compatibility reasons only.  Due to security concerns inherent in the design of sprintf(3), it is highly recommended that you use snprintf(3) instead.")
      | ^
/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/cdefs.h:218:48: note: expanded from macro '__deprecated_msg'
  218 |         #define __deprecated_msg(_msg) __attribute__((__deprecated__(_msg)))
      |                                                       ^
/Users/kmt/PtDAlgorithms/src/c/ptdalgorithms.c:6661:21: error: assigning to 'int **' from incompatible type 'void *'
 6661 |     trace-&gt;states = malloc(trace-&gt;n_vertices * sizeof(int*));
      |                     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/Users/kmt/PtDAlgorithms/src/c/ptdalgorithms.c:6663:9: warning: 'sprintf' is deprecated: This function is provided for compatibility reasons only.  Due to security concerns inherent in the design of sprintf(3), it is highly recommended that you use snprintf(3) instead. [-Wdeprecated-declarations]
 6663 |         sprintf((char*)ptd_err, "ptd_record_elimination_trace: failed to allocate states");
      |         ^
/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_stdio.h:278:1: note: 'sprintf' has been explicitly marked deprecated here
  278 | __deprecated_msg("This function is provided for compatibility reasons only.  Due to security concerns inherent in the design of sprintf(3), it is highly recommended that you use snprintf(3) instead.")
      | ^
/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/cdefs.h:218:48: note: expanded from macro '__deprecated_msg'
  218 |         #define __deprecated_msg(_msg) __attribute__((__deprecated__(_msg)))
      |                                                       ^
/Users/kmt/PtDAlgorithms/src/c/ptdalgorithms.c:6669:28: error: assigning to 'int *' from incompatible type 'void *'
 6669 |         trace-&gt;states[i] = malloc(trace-&gt;state_length * sizeof(int));
      |                            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/Users/kmt/PtDAlgorithms/src/c/ptdalgorithms.c:6671:13: warning: 'sprintf' is deprecated: This function is provided for compatibility reasons only.  Due to security concerns inherent in the design of sprintf(3), it is highly recommended that you use snprintf(3) instead. [-Wdeprecated-declarations]
 6671 |             sprintf((char*)ptd_err, "ptd_record_elimination_trace: failed to allocate state for vertex %zu", i);
      |             ^
/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_stdio.h:278:1: note: 'sprintf' has been explicitly marked deprecated here
  278 | __deprecated_msg("This function is provided for compatibility reasons only.  Due to security concerns inherent in the design of sprintf(3), it is highly recommended that you use snprintf(3) instead.")
      | ^
/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/cdefs.h:218:48: note: expanded from macro '__deprecated_msg'
  218 |         #define __deprecated_msg(_msg) __attribute__((__deprecated__(_msg)))
      |                                                       ^
/Users/kmt/PtDAlgorithms/src/c/ptdalgorithms.c:6699:21: error: cannot initialize a variable of type 'size_t *' (aka 'unsigned long *') with an rvalue of type 'void *'
 6699 |             size_t *weight_indices = malloc(v-&gt;edges_length * sizeof(size_t));
      |                     ^                ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/Users/kmt/PtDAlgorithms/src/c/ptdalgorithms.c:6701:17: warning: 'sprintf' is deprecated: This function is provided for compatibility reasons only.  Due to security concerns inherent in the design of sprintf(3), it is highly recommended that you use snprintf(3) instead. [-Wdeprecated-declarations]
 6701 |                 sprintf((char*)ptd_err, "ptd_record_elimination_trace: failed to allocate weight_indices");
      |                 ^
/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_stdio.h:278:1: note: 'sprintf' has been explicitly marked deprecated here
  278 | __deprecated_msg("This function is provided for compatibility reasons only.  Due to security concerns inherent in the design of sprintf(3), it is highly recommended that you use snprintf(3) instead.")
      | ^
/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/cdefs.h:218:48: note: expanded from macro '__deprecated_msg'
  218 |         #define __deprecated_msg(_msg) __attribute__((__deprecated__(_msg)))
      |                                                       ^
/Users/kmt/PtDAlgorithms/src/c/ptdalgorithms.c:6759:13: error: cannot initialize a variable of type 'size_t *' (aka 'unsigned long *') with an rvalue of type 'void *'
 6759 |     size_t *edge_capacities = malloc(trace-&gt;n_vertices * sizeof(size_t));
      |             ^                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/Users/kmt/PtDAlgorithms/src/c/ptdalgorithms.c:6761:9: warning: 'sprintf' is deprecated: This function is provided for compatibility reasons only.  Due to security concerns inherent in the design of sprintf(3), it is highly recommended that you use snprintf(3) instead. [-Wdeprecated-declarations]
 6761 |         sprintf((char*)ptd_err, "ptd_record_elimination_trace: failed to allocate edge_capacities");
      |         ^
/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_stdio.h:278:1: note: 'sprintf' has been explicitly marked deprecated here
  278 | __deprecated_msg("This function is provided for compatibility reasons only.  Due to security concerns inherent in the design of sprintf(3), it is highly recommended that you use snprintf(3) instead.")
      | ^
/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/cdefs.h:218:48: note: expanded from macro '__deprecated_msg'
  218 |         #define __deprecated_msg(_msg) __attribute__((__deprecated__(_msg)))
      |                                                       ^
/Users/kmt/PtDAlgorithms/src/c/ptdalgorithms.c:6775:36: error: assigning to 'size_t *' (aka 'unsigned long *') from incompatible type 'void *'
 6775 |             trace-&gt;edge_probs[i] = malloc(edge_capacities[i] * sizeof(size_t));
      |                                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
fatal error: too many errors emitted, stopping now [-ferror-limit=]
8 warnings and 20 errors generated.
</pre>
</div>
</div>
</div>
</section>
<section id="cache-management-and-collaboration" class="level2">
<h2 class="anchored" data-anchor-id="cache-management-and-collaboration">Cache Management and Collaboration</h2>
<p>The cache is designed to be low-maintenance, but several tools are available for power users:</p>
<p><strong>Inspecting the cache:</strong> Use <code>cache.info()</code> to see summary statistics, or <code>cache.list_entries(limit=N)</code> to see individual entries with their hashes, timestamps, and sizes.</p>
<p><strong>Sharing with collaborators:</strong> Export your cache with <code>cache.export_library(output_dir)</code> to create a shareable directory containing symbolic DAGs. Collaborators can then run <code>cache.import_library(exported_dir)</code> to add these pre-computed models to their cache. This is especially useful for complex models that take minutes to eliminate—once one person computes it, everyone else gets instant loading.</p>
<p><strong>CLI tool:</strong> The <code>ptd-cache</code> command-line tool provides convenient cache management:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb113"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb113-1"><a href="#cb113-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Show cache statistics</span></span>
<span id="cb113-2"><a href="#cb113-2" aria-hidden="true" tabindex="-1"></a><span class="ex">ptd-cache</span> info</span>
<span id="cb113-3"><a href="#cb113-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb113-4"><a href="#cb113-4" aria-hidden="true" tabindex="-1"></a><span class="co"># List cached models</span></span>
<span id="cb113-5"><a href="#cb113-5" aria-hidden="true" tabindex="-1"></a><span class="ex">ptd-cache</span> list <span class="at">--limit</span> 10</span>
<span id="cb113-6"><a href="#cb113-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb113-7"><a href="#cb113-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Export cache for sharing</span></span>
<span id="cb113-8"><a href="#cb113-8" aria-hidden="true" tabindex="-1"></a><span class="ex">ptd-cache</span> export my_models.tar.gz</span>
<span id="cb113-9"><a href="#cb113-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb113-10"><a href="#cb113-10" aria-hidden="true" tabindex="-1"></a><span class="co"># Import someone else's cache</span></span>
<span id="cb113-11"><a href="#cb113-11" aria-hidden="true" tabindex="-1"></a><span class="ex">ptd-cache</span> import downloaded_models.tar.gz</span>
<span id="cb113-12"><a href="#cb113-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb113-13"><a href="#cb113-13" aria-hidden="true" tabindex="-1"></a><span class="co"># Clean up old entries</span></span>
<span id="cb113-14"><a href="#cb113-14" aria-hidden="true" tabindex="-1"></a><span class="ex">ptd-cache</span> vacuum <span class="at">--max-age-days</span> 30</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p><strong>Distributed computing:</strong> In HPC environments with shared filesystems, you can configure multiple compute nodes to share a cache by pointing the cache directory to network storage. The cache uses file locking to safely handle concurrent access, allowing distributed jobs to share symbolic DAGs without redundant computation. See the <a href="../../pages/distributed/distributed_computing_complete_guide.html">distributed computing guide</a> for details.</p>
<p><strong>Disabling caching:</strong> If needed, you can disable automatic caching with <code>use_cache=False</code>:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb114"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb114-1"><a href="#cb114-1" aria-hidden="true" tabindex="-1"></a>model <span class="op">=</span> Graph.pmf_from_graph(graph, use_cache<span class="op">=</span><span class="va">False</span>)  <span class="co"># Always recompute</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>This is rarely necessary but can be useful for testing or when you suspect cache corruption.</p>
</section>
</section>
<section id="state-space-modelling" class="level1">
<h1>State space modelling</h1>
<section id="time-inhomogeneity" class="level2">
<h2 class="anchored" data-anchor-id="time-inhomogeneity">Time inhomogeneity</h2>
<p>If the weights change over time - or new edges are added!</p>
<p>Then the distribution is time inhomogeneous. The api also supports such distributions, but in limited manner.</p>
<p>Like the pph, dph, etc. functions, it is a (very good) approximation based on very small steps. If the rates change dramatically, set the granularity as an argument to the functions!! E.g. set it to a high enough value.</p>
<p>If we pick a time far into the future, we can integrate under the pdf to find the expectation!</p>
<p>Integrating over accumulated visiting time:</p>
<div id="cell-141" class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb115"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb115-1"><a href="#cb115-1" aria-hidden="true" tabindex="-1"></a><span class="bu">sum</span>(graph.accumulated_visiting_time(<span class="dv">10</span>))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display" data-execution_count="64">
<pre><code>0.5038265306014538</code></pre>
</div>
</div>
<p>The first moment (expectation):</p>
<div id="cell-143" class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb117"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb117-1"><a href="#cb117-1" aria-hidden="true" tabindex="-1"></a>graph.expectation()</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display" data-execution_count="65">
<pre><code>0.5038265306122448</code></pre>
</div>
</div>
<p>Say at a certain point in time, the flooding starts!</p>
<p>In the beginning, there is <em>no</em> flooding</p>
<div id="cell-145" class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb119"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb119-1"><a href="#cb119-1" aria-hidden="true" tabindex="-1"></a>param_graph.update_parameterized_weights([<span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>])</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p>We can build a context to step over the distribution. Weights can be freely changed and edges added in such a context</p>
<div id="cell-147" class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb120"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb120-1"><a href="#cb120-1" aria-hidden="true" tabindex="-1"></a><span class="co"># import ptdalgorithms as ptd</span></span>
<span id="cb120-2"><a href="#cb120-2" aria-hidden="true" tabindex="-1"></a><span class="co"># import numpy as np</span></span>
<span id="cb120-3"><a href="#cb120-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb120-4"><a href="#cb120-4" aria-hidden="true" tabindex="-1"></a><span class="co"># def c(*args):</span></span>
<span id="cb120-5"><a href="#cb120-5" aria-hidden="true" tabindex="-1"></a><span class="co">#     elem = []</span></span>
<span id="cb120-6"><a href="#cb120-6" aria-hidden="true" tabindex="-1"></a><span class="co">#     for arg in args:</span></span>
<span id="cb120-7"><a href="#cb120-7" aria-hidden="true" tabindex="-1"></a><span class="co">#         if hasattr(arg, '__len__') and len(arg) &gt; 1:</span></span>
<span id="cb120-8"><a href="#cb120-8" aria-hidden="true" tabindex="-1"></a><span class="co">#             elem.extend(arg)</span></span>
<span id="cb120-9"><a href="#cb120-9" aria-hidden="true" tabindex="-1"></a><span class="co">#         else:</span></span>
<span id="cb120-10"><a href="#cb120-10" aria-hidden="true" tabindex="-1"></a><span class="co">#             elem.append(arg)</span></span>
<span id="cb120-11"><a href="#cb120-11" aria-hidden="true" tabindex="-1"></a><span class="co">#     return np.array(elem)</span></span>
<span id="cb120-12"><a href="#cb120-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb120-13"><a href="#cb120-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb120-14"><a href="#cb120-14" aria-hidden="true" tabindex="-1"></a><span class="co"># nr_rabbits, flood_left, flood_right = 2, 2, 4</span></span>
<span id="cb120-15"><a href="#cb120-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb120-16"><a href="#cb120-16" aria-hidden="true" tabindex="-1"></a><span class="co"># # we represent the vector as two integers, the number of </span></span>
<span id="cb120-17"><a href="#cb120-17" aria-hidden="true" tabindex="-1"></a><span class="co"># # rabbits on the left and right island</span></span>
<span id="cb120-18"><a href="#cb120-18" aria-hidden="true" tabindex="-1"></a><span class="co"># state_vector_length = 2</span></span>
<span id="cb120-19"><a href="#cb120-19" aria-hidden="true" tabindex="-1"></a><span class="co"># graph = ptd.Graph(state_vector_length)</span></span>
<span id="cb120-20"><a href="#cb120-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb120-21"><a href="#cb120-21" aria-hidden="true" tabindex="-1"></a><span class="co"># # the initial state is the only starting state, with probability 1</span></span>
<span id="cb120-22"><a href="#cb120-22" aria-hidden="true" tabindex="-1"></a><span class="co"># initial_state = c(nr_rabbits, 0)</span></span>
<span id="cb120-23"><a href="#cb120-23" aria-hidden="true" tabindex="-1"></a><span class="co"># vertex = graph.find_or_create_vertex(initial_state)</span></span>
<span id="cb120-24"><a href="#cb120-24" aria-hidden="true" tabindex="-1"></a><span class="co"># graph.starting_vertex().add_edge(vertex, 1)</span></span>
<span id="cb120-25"><a href="#cb120-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb120-26"><a href="#cb120-26" aria-hidden="true" tabindex="-1"></a><span class="co"># index = 1</span></span>
<span id="cb120-27"><a href="#cb120-27" aria-hidden="true" tabindex="-1"></a><span class="co"># # iterate over all unvisited vertices</span></span>
<span id="cb120-28"><a href="#cb120-28" aria-hidden="true" tabindex="-1"></a><span class="co"># while index &lt; graph.vertices_length():</span></span>
<span id="cb120-29"><a href="#cb120-29" aria-hidden="true" tabindex="-1"></a><span class="co">#     vertex = graph.vertex_at(index)</span></span>
<span id="cb120-30"><a href="#cb120-30" aria-hidden="true" tabindex="-1"></a><span class="co">#     state = vertex.state()</span></span>
<span id="cb120-31"><a href="#cb120-31" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb120-32"><a href="#cb120-32" aria-hidden="true" tabindex="-1"></a><span class="co">#     if state[0] &gt; 0:</span></span>
<span id="cb120-33"><a href="#cb120-33" aria-hidden="true" tabindex="-1"></a><span class="co">#         # rabbit jump left to right</span></span>
<span id="cb120-34"><a href="#cb120-34" aria-hidden="true" tabindex="-1"></a><span class="co">#         child_state = c(state[0] - 1, state[1] + 1)</span></span>
<span id="cb120-35"><a href="#cb120-35" aria-hidden="true" tabindex="-1"></a><span class="co">#         vertex.add_edge(</span></span>
<span id="cb120-36"><a href="#cb120-36" aria-hidden="true" tabindex="-1"></a><span class="co">#             graph.find_or_create_vertex(child_state),</span></span>
<span id="cb120-37"><a href="#cb120-37" aria-hidden="true" tabindex="-1"></a><span class="co">#             weight=1</span></span>
<span id="cb120-38"><a href="#cb120-38" aria-hidden="true" tabindex="-1"></a><span class="co">#         )</span></span>
<span id="cb120-39"><a href="#cb120-39" aria-hidden="true" tabindex="-1"></a><span class="co">#         # left island flooding</span></span>
<span id="cb120-40"><a href="#cb120-40" aria-hidden="true" tabindex="-1"></a><span class="co">#         child_state = c(0, state[1])</span></span>
<span id="cb120-41"><a href="#cb120-41" aria-hidden="true" tabindex="-1"></a><span class="co">#         vertex.add_edge(</span></span>
<span id="cb120-42"><a href="#cb120-42" aria-hidden="true" tabindex="-1"></a><span class="co">#             graph.find_or_create_vertex(child_state), </span></span>
<span id="cb120-43"><a href="#cb120-43" aria-hidden="true" tabindex="-1"></a><span class="co">#             weight=flood_left</span></span>
<span id="cb120-44"><a href="#cb120-44" aria-hidden="true" tabindex="-1"></a><span class="co">#         )</span></span>
<span id="cb120-45"><a href="#cb120-45" aria-hidden="true" tabindex="-1"></a><span class="co">#     if state[1] &gt; 0:   </span></span>
<span id="cb120-46"><a href="#cb120-46" aria-hidden="true" tabindex="-1"></a><span class="co">#         child_state = c(state[0] + 1, state[1] - 1)</span></span>
<span id="cb120-47"><a href="#cb120-47" aria-hidden="true" tabindex="-1"></a><span class="co">#         vertex.add_edge(</span></span>
<span id="cb120-48"><a href="#cb120-48" aria-hidden="true" tabindex="-1"></a><span class="co">#             graph.find_or_create_vertex(child_state),</span></span>
<span id="cb120-49"><a href="#cb120-49" aria-hidden="true" tabindex="-1"></a><span class="co">#             weight=1</span></span>
<span id="cb120-50"><a href="#cb120-50" aria-hidden="true" tabindex="-1"></a><span class="co">#         )</span></span>
<span id="cb120-51"><a href="#cb120-51" aria-hidden="true" tabindex="-1"></a><span class="co">#         # right island flooding</span></span>
<span id="cb120-52"><a href="#cb120-52" aria-hidden="true" tabindex="-1"></a><span class="co">#         child_state = c(state[0], 0)</span></span>
<span id="cb120-53"><a href="#cb120-53" aria-hidden="true" tabindex="-1"></a><span class="co">#         vertex.add_edge(</span></span>
<span id="cb120-54"><a href="#cb120-54" aria-hidden="true" tabindex="-1"></a><span class="co">#             graph.find_or_create_vertex(child_state), </span></span>
<span id="cb120-55"><a href="#cb120-55" aria-hidden="true" tabindex="-1"></a><span class="co">#             weight=flood_right</span></span>
<span id="cb120-56"><a href="#cb120-56" aria-hidden="true" tabindex="-1"></a><span class="co">#         )</span></span>
<span id="cb120-57"><a href="#cb120-57" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb120-58"><a href="#cb120-58" aria-hidden="true" tabindex="-1"></a><span class="co">#     index += 1</span></span>
<span id="cb120-59"><a href="#cb120-59" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb120-60"><a href="#cb120-60" aria-hidden="true" tabindex="-1"></a><span class="co"># # graph.plot(nodesep=1, ranksep=0.1)</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<div id="cell-148" class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb121"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb121-1"><a href="#cb121-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb121-2"><a href="#cb121-2" aria-hidden="true" tabindex="-1"></a><span class="co"># ctx = graph.distribution_context()</span></span>
<span id="cb121-3"><a href="#cb121-3" aria-hidden="true" tabindex="-1"></a><span class="co"># cdfs = []</span></span>
<span id="cb121-4"><a href="#cb121-4" aria-hidden="true" tabindex="-1"></a><span class="co"># times = []</span></span>
<span id="cb121-5"><a href="#cb121-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb121-6"><a href="#cb121-6" aria-hidden="true" tabindex="-1"></a><span class="co"># # while ctx.time() &lt; 1.5:</span></span>
<span id="cb121-7"><a href="#cb121-7" aria-hidden="true" tabindex="-1"></a><span class="co"># while ctx.cdf() &lt; 0.999:</span></span>
<span id="cb121-8"><a href="#cb121-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb121-9"><a href="#cb121-9" aria-hidden="true" tabindex="-1"></a><span class="co">#     cdfs.append(ctx.cdf())</span></span>
<span id="cb121-10"><a href="#cb121-10" aria-hidden="true" tabindex="-1"></a><span class="co">#     times.append(ctx.time())</span></span>
<span id="cb121-11"><a href="#cb121-11" aria-hidden="true" tabindex="-1"></a><span class="co">#     param_graph.update_parameterized_weights(</span></span>
<span id="cb121-12"><a href="#cb121-12" aria-hidden="true" tabindex="-1"></a><span class="co">#         [1,</span></span>
<span id="cb121-13"><a href="#cb121-13" aria-hidden="true" tabindex="-1"></a><span class="co">#         ctx.time() - 1.5, </span></span>
<span id="cb121-14"><a href="#cb121-14" aria-hidden="true" tabindex="-1"></a><span class="co">#         2 * ctx.time() - 1.5</span></span>
<span id="cb121-15"><a href="#cb121-15" aria-hidden="true" tabindex="-1"></a><span class="co">#         ]</span></span>
<span id="cb121-16"><a href="#cb121-16" aria-hidden="true" tabindex="-1"></a><span class="co">#     )</span></span>
<span id="cb121-17"><a href="#cb121-17" aria-hidden="true" tabindex="-1"></a><span class="co">#     ctx.step()</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p>It increases by every time step. Time until all rabbits are dead. Flooding increases linearly after 1.5 time units:</p>
<div id="cell-150" class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb122"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb122-1"><a href="#cb122-1" aria-hidden="true" tabindex="-1"></a>param_graph.update_parameterized_weights([<span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>])</span>
<span id="cb122-2"><a href="#cb122-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-3"><a href="#cb122-3" aria-hidden="true" tabindex="-1"></a>ctx <span class="op">=</span> param_graph.distribution_context()</span>
<span id="cb122-4"><a href="#cb122-4" aria-hidden="true" tabindex="-1"></a>cdfs <span class="op">=</span> []</span>
<span id="cb122-5"><a href="#cb122-5" aria-hidden="true" tabindex="-1"></a>times <span class="op">=</span> []</span>
<span id="cb122-6"><a href="#cb122-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-7"><a href="#cb122-7" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> ctx.time() <span class="op">&lt;</span> <span class="fl">1.5</span>:</span>
<span id="cb122-8"><a href="#cb122-8" aria-hidden="true" tabindex="-1"></a>    cdfs.append(ctx.cdf())</span>
<span id="cb122-9"><a href="#cb122-9" aria-hidden="true" tabindex="-1"></a>    times.append(ctx.time())</span>
<span id="cb122-10"><a href="#cb122-10" aria-hidden="true" tabindex="-1"></a>    ctx.step()</span>
<span id="cb122-11"><a href="#cb122-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-12"><a href="#cb122-12" aria-hidden="true" tabindex="-1"></a><span class="co">#param_graph.update_parameterized_weights([1, 1, 1])</span></span>
<span id="cb122-13"><a href="#cb122-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-14"><a href="#cb122-14" aria-hidden="true" tabindex="-1"></a><span class="co"># at time 1.5, the flooding starts!</span></span>
<span id="cb122-15"><a href="#cb122-15" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> ctx.cdf() <span class="op">&lt;</span> <span class="fl">0.999</span>:</span>
<span id="cb122-16"><a href="#cb122-16" aria-hidden="true" tabindex="-1"></a>    cdfs.append(ctx.cdf())</span>
<span id="cb122-17"><a href="#cb122-17" aria-hidden="true" tabindex="-1"></a>    times.append(ctx.time())</span>
<span id="cb122-18"><a href="#cb122-18" aria-hidden="true" tabindex="-1"></a>    param_graph.update_parameterized_weights(</span>
<span id="cb122-19"><a href="#cb122-19" aria-hidden="true" tabindex="-1"></a>        [<span class="dv">1</span>,</span>
<span id="cb122-20"><a href="#cb122-20" aria-hidden="true" tabindex="-1"></a>        ctx.time() <span class="op">-</span> <span class="fl">1.5</span>, </span>
<span id="cb122-21"><a href="#cb122-21" aria-hidden="true" tabindex="-1"></a>        <span class="dv">2</span> <span class="op">*</span> ctx.time() <span class="op">-</span> <span class="fl">1.5</span></span>
<span id="cb122-22"><a href="#cb122-22" aria-hidden="true" tabindex="-1"></a>        ]</span>
<span id="cb122-23"><a href="#cb122-23" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb122-24"><a href="#cb122-24" aria-hidden="true" tabindex="-1"></a>    ctx.step()</span>
<span id="cb122-25"><a href="#cb122-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-26"><a href="#cb122-26" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">1</span>, figsize<span class="op">=</span>(<span class="dv">4</span>, <span class="dv">3</span>))</span>
<span id="cb122-27"><a href="#cb122-27" aria-hidden="true" tabindex="-1"></a>ax.plot(times, cdfs)</span>
<span id="cb122-28"><a href="#cb122-28" aria-hidden="true" tabindex="-1"></a>sns.despine()</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><a href="rabbits_full_py_api_example_files/figure-html/cell-79-output-1.png" class="lightbox" data-gallery="quarto-lightbox-gallery-11"><img src="rabbits_full_py_api_example_files/figure-html/cell-79-output-1.png" width="361" height="274" class="figure-img"></a></p>
</figure>
</div>
</div>
</div>
<p>If we pick a time far into the future, we can integrate under it to find the expectation. This means that we can scale by a reward, and thereby find the marginal expectation.</p>
<p>Summing over accumulated visiting time (with reward):</p>
<div id="cell-153" class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb123"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb123-1"><a href="#cb123-1" aria-hidden="true" tabindex="-1"></a>np.<span class="bu">sum</span>(graph.accumulated_visiting_time(<span class="dv">10</span>)<span class="op">*</span>graph.states()[:,<span class="dv">1</span>])</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display" data-execution_count="70">
<pre><code>np.float64(0.09438775509887067)</code></pre>
</div>
</div>
<p>The first moment (expectation) (with reward):</p>
<div id="cell-155" class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb125"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb125-1"><a href="#cb125-1" aria-hidden="true" tabindex="-1"></a>graph.expectation(graph.states()[:,<span class="dv">1</span>])</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display" data-execution_count="71">
<pre><code>0.09438775510204081</code></pre>
</div>
</div>
<p>But if the time is <em>not</em> far into the future, we get the expectation up to a certain point in time.</p>
<p>Expectation (rewarded) when truncating at 0.05 time:</p>
<div id="cell-158" class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb127"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb127-1"><a href="#cb127-1" aria-hidden="true" tabindex="-1"></a>np.<span class="bu">sum</span>(graph.accumulated_visiting_time(<span class="fl">0.05</span>)<span class="op">*</span>graph.states()[:,<span class="dv">1</span>])</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display" data-execution_count="72">
<pre><code>np.float64(0.0011713234985744549)</code></pre>
</div>
</div>
<p>Untruncated expectation:</p>
<div id="cell-160" class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb129"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb129-1"><a href="#cb129-1" aria-hidden="true" tabindex="-1"></a>graph.expectation(graph.states()[:,<span class="dv">1</span>])</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display" data-execution_count="73">
<pre><code>0.09438775510204081</code></pre>
</div>
</div>
<p>Expectation (rewarded) when <em>starting</em> at 0.05 time:</p>
</section>
<section id="modelling-epochs-in-state-space" class="level2">
<h2 class="anchored" data-anchor-id="modelling-epochs-in-state-space">Modelling epochs in state space</h2>
</section>
<section id="laplace-transform" class="level2">
<h2 class="anchored" data-anchor-id="laplace-transform">Laplace transform</h2>
<p>The Laplace transform is a fundamental tool for analyzing continuous phase-type distributions. For a random variable T with probability density function f(t), the Laplace transform is defined as L(s) = E[e^(-sT)] = ∫₀^∞ e^(-st) f(t) dt. For phase-type distributions represented as absorbing Markov chains, the Laplace transform has an elegant matrix form that can be computed efficiently from the graph structure.</p>
<p>The Laplace transform is particularly useful because it provides an alternative characterization of the distribution that often simplifies analytical calculations. Moments can be recovered by differentiating the Laplace transform: the n-th moment is E[T^n] = (-1)^n (d^n L/ds^n)|_{s=0}. The Laplace transform also plays a crucial role in analyzing time-inhomogeneous processes and in computing convolutions of distributions.</p>
<p>In our rabbit model, the Laplace transform captures the moment generating function of the time until all rabbits have died. Let’s compute it and verify that we can recover moments by differentiation.</p>
<div id="cell-167" class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb131"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb131-1"><a href="#cb131-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Compute Laplace transform for several values of s</span></span>
<span id="cb131-2"><a href="#cb131-2" aria-hidden="true" tabindex="-1"></a>s_values <span class="op">=</span> np.array([<span class="fl">0.1</span>, <span class="fl">0.5</span>, <span class="fl">1.0</span>, <span class="fl">2.0</span>, <span class="fl">5.0</span>, <span class="fl">10.0</span>])</span>
<span id="cb131-3"><a href="#cb131-3" aria-hidden="true" tabindex="-1"></a>laplace_values <span class="op">=</span> graph.laplace_transform(s_values)</span>
<span id="cb131-4"><a href="#cb131-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb131-5"><a href="#cb131-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Laplace transform L(s) = E[e^(-sT)]:"</span>)</span>
<span id="cb131-6"><a href="#cb131-6" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> s, L_s <span class="kw">in</span> <span class="bu">zip</span>(s_values, laplace_values):</span>
<span id="cb131-7"><a href="#cb131-7" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"  L(</span><span class="sc">{</span>s<span class="sc">:4.1f}</span><span class="ss">) = </span><span class="sc">{</span>L_s<span class="sc">:.6f}</span><span class="ss">"</span>)</span>
<span id="cb131-8"><a href="#cb131-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb131-9"><a href="#cb131-9" aria-hidden="true" tabindex="-1"></a><span class="co"># Verify that L(0) = 1 (certain event)</span></span>
<span id="cb131-10"><a href="#cb131-10" aria-hidden="true" tabindex="-1"></a>L_0 <span class="op">=</span> graph.laplace_transform(np.array([<span class="fl">0.0</span>]))[<span class="dv">0</span>]</span>
<span id="cb131-11"><a href="#cb131-11" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss">Verification: L(0) = </span><span class="sc">{</span>L_0<span class="sc">:.10f}</span><span class="ss"> (should be 1.0)"</span>)</span>
<span id="cb131-12"><a href="#cb131-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb131-13"><a href="#cb131-13" aria-hidden="true" tabindex="-1"></a><span class="co"># Verify relationship to moments using numerical differentiation</span></span>
<span id="cb131-14"><a href="#cb131-14" aria-hidden="true" tabindex="-1"></a><span class="co"># E[T] = -L'(0), so we approximate with finite differences</span></span>
<span id="cb131-15"><a href="#cb131-15" aria-hidden="true" tabindex="-1"></a>h <span class="op">=</span> <span class="fl">1e-6</span></span>
<span id="cb131-16"><a href="#cb131-16" aria-hidden="true" tabindex="-1"></a>L_h <span class="op">=</span> graph.laplace_transform(np.array([h]))[<span class="dv">0</span>]</span>
<span id="cb131-17"><a href="#cb131-17" aria-hidden="true" tabindex="-1"></a>L_0 <span class="op">=</span> graph.laplace_transform(np.array([<span class="fl">0.0</span>]))[<span class="dv">0</span>]</span>
<span id="cb131-18"><a href="#cb131-18" aria-hidden="true" tabindex="-1"></a>numerical_expectation <span class="op">=</span> <span class="op">-</span>(L_h <span class="op">-</span> L_0) <span class="op">/</span> h</span>
<span id="cb131-19"><a href="#cb131-19" aria-hidden="true" tabindex="-1"></a>analytical_expectation <span class="op">=</span> graph.expectation()</span>
<span id="cb131-20"><a href="#cb131-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb131-21"><a href="#cb131-21" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss">Expectation from Laplace derivative: </span><span class="sc">{</span>numerical_expectation<span class="sc">:.6f}</span><span class="ss">"</span>)</span>
<span id="cb131-22"><a href="#cb131-22" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Expectation from direct computation: </span><span class="sc">{</span>analytical_expectation<span class="sc">:.6f}</span><span class="ss">"</span>)</span>
<span id="cb131-23"><a href="#cb131-23" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Relative error: </span><span class="sc">{</span><span class="bu">abs</span>(numerical_expectation <span class="op">-</span> analytical_expectation)<span class="op">/</span>analytical_expectation <span class="op">*</span> <span class="dv">100</span><span class="sc">:.4f}</span><span class="ss">%"</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
</section>
<section id="joint-probability" class="level2">
<h2 class="anchored" data-anchor-id="joint-probability">Joint probability</h2>
<p>Phase-type distributions can be extended to model joint probabilities of multiple random variables. This is particularly important in applications like population genetics, where we might be interested in the joint distribution of coalescence times for multiple lineages, or in reliability theory, where we might want the joint distribution of failure times for multiple components. The library provides tools for constructing and analyzing such joint distributions through the concept of multi-dimensional phase-type distributions.</p>
<p>The key idea is that we can embed multiple independent or dependent processes into a single state space, where the state vector encodes the progress of all processes simultaneously. Transitions in this joint state space then correspond to events in any of the individual processes. By carefully constructing the edge weights and using reward transformations, we can extract marginal distributions, conditional distributions, and joint distribution functions.</p>
<p>In our rabbit model, we might be interested in the joint distribution of two quantities: the time until the left island is depleted (either by jumping or flooding) and the time until the right island is depleted. These two times are not independent—they are coupled through the rabbits jumping between islands. Let’s construct a model that tracks both times simultaneously.</p>
<div id="cell-169" class="cell" data-execution_count="70">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb132"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb132-1"><a href="#cb132-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Construct a rabbit model that tracks time to depletion for each island separately</span></span>
<span id="cb132-2"><a href="#cb132-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> construct_joint_time_model(nr_rabbits, flood_left, flood_right):</span>
<span id="cb132-3"><a href="#cb132-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb132-4"><a href="#cb132-4" aria-hidden="true" tabindex="-1"></a><span class="co">    Construct a model tracking joint distribution of depletion times.</span></span>
<span id="cb132-5"><a href="#cb132-5" aria-hidden="true" tabindex="-1"></a><span class="co">    State: [rabbits_left, rabbits_right, left_depleted, right_depleted]</span></span>
<span id="cb132-6"><a href="#cb132-6" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb132-7"><a href="#cb132-7" aria-hidden="true" tabindex="-1"></a>    graph <span class="op">=</span> Graph(state_length<span class="op">=</span><span class="dv">4</span>)</span>
<span id="cb132-8"><a href="#cb132-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb132-9"><a href="#cb132-9" aria-hidden="true" tabindex="-1"></a>    initial_state <span class="op">=</span> [nr_rabbits, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>]  <span class="co"># Start with all rabbits on left</span></span>
<span id="cb132-10"><a href="#cb132-10" aria-hidden="true" tabindex="-1"></a>    graph.starting_vertex().add_edge(graph.find_or_create_vertex(initial_state), <span class="dv">1</span>)</span>
<span id="cb132-11"><a href="#cb132-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb132-12"><a href="#cb132-12" aria-hidden="true" tabindex="-1"></a>    index <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb132-13"><a href="#cb132-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> index <span class="op">&lt;</span> graph.vertices_length():</span>
<span id="cb132-14"><a href="#cb132-14" aria-hidden="true" tabindex="-1"></a>        vertex <span class="op">=</span> graph.vertex_at(index)</span>
<span id="cb132-15"><a href="#cb132-15" aria-hidden="true" tabindex="-1"></a>        state <span class="op">=</span> <span class="bu">list</span>(vertex.state())</span>
<span id="cb132-16"><a href="#cb132-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb132-17"><a href="#cb132-17" aria-hidden="true" tabindex="-1"></a>        <span class="co"># If left island has rabbits and not yet depleted</span></span>
<span id="cb132-18"><a href="#cb132-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> state[<span class="dv">0</span>] <span class="op">&gt;</span> <span class="dv">0</span> <span class="kw">and</span> state[<span class="dv">2</span>] <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb132-19"><a href="#cb132-19" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Jump to right</span></span>
<span id="cb132-20"><a href="#cb132-20" aria-hidden="true" tabindex="-1"></a>            child_state <span class="op">=</span> [state[<span class="dv">0</span>] <span class="op">-</span> <span class="dv">1</span>, state[<span class="dv">1</span>] <span class="op">+</span> <span class="dv">1</span>, state[<span class="dv">2</span>], state[<span class="dv">3</span>]]</span>
<span id="cb132-21"><a href="#cb132-21" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> child_state[<span class="dv">0</span>] <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb132-22"><a href="#cb132-22" aria-hidden="true" tabindex="-1"></a>                child_state[<span class="dv">2</span>] <span class="op">=</span> <span class="dv">1</span>  <span class="co"># Mark left as depleted</span></span>
<span id="cb132-23"><a href="#cb132-23" aria-hidden="true" tabindex="-1"></a>            vertex.add_edge(graph.find_or_create_vertex(child_state), weight<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb132-24"><a href="#cb132-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb132-25"><a href="#cb132-25" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Left flooding</span></span>
<span id="cb132-26"><a href="#cb132-26" aria-hidden="true" tabindex="-1"></a>            child_state <span class="op">=</span> [<span class="dv">0</span>, state[<span class="dv">1</span>], <span class="dv">1</span>, state[<span class="dv">3</span>]]  <span class="co"># All left rabbits die, mark depleted</span></span>
<span id="cb132-27"><a href="#cb132-27" aria-hidden="true" tabindex="-1"></a>            vertex.add_edge(graph.find_or_create_vertex(child_state), weight<span class="op">=</span>flood_left)</span>
<span id="cb132-28"><a href="#cb132-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb132-29"><a href="#cb132-29" aria-hidden="true" tabindex="-1"></a>        <span class="co"># If right island has rabbits and not yet depleted</span></span>
<span id="cb132-30"><a href="#cb132-30" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> state[<span class="dv">1</span>] <span class="op">&gt;</span> <span class="dv">0</span> <span class="kw">and</span> state[<span class="dv">3</span>] <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb132-31"><a href="#cb132-31" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Jump to left</span></span>
<span id="cb132-32"><a href="#cb132-32" aria-hidden="true" tabindex="-1"></a>            child_state <span class="op">=</span> [state[<span class="dv">0</span>] <span class="op">+</span> <span class="dv">1</span>, state[<span class="dv">1</span>] <span class="op">-</span> <span class="dv">1</span>, state[<span class="dv">2</span>], state[<span class="dv">3</span>]]</span>
<span id="cb132-33"><a href="#cb132-33" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> child_state[<span class="dv">1</span>] <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb132-34"><a href="#cb132-34" aria-hidden="true" tabindex="-1"></a>                child_state[<span class="dv">3</span>] <span class="op">=</span> <span class="dv">1</span>  <span class="co"># Mark right as depleted</span></span>
<span id="cb132-35"><a href="#cb132-35" aria-hidden="true" tabindex="-1"></a>            vertex.add_edge(graph.find_or_create_vertex(child_state), weight<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb132-36"><a href="#cb132-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb132-37"><a href="#cb132-37" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Right flooding</span></span>
<span id="cb132-38"><a href="#cb132-38" aria-hidden="true" tabindex="-1"></a>            child_state <span class="op">=</span> [state[<span class="dv">0</span>], <span class="dv">0</span>, state[<span class="dv">2</span>], <span class="dv">1</span>]  <span class="co"># All right rabbits die, mark depleted</span></span>
<span id="cb132-39"><a href="#cb132-39" aria-hidden="true" tabindex="-1"></a>            vertex.add_edge(graph.find_or_create_vertex(child_state), weight<span class="op">=</span>flood_right)</span>
<span id="cb132-40"><a href="#cb132-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb132-41"><a href="#cb132-41" aria-hidden="true" tabindex="-1"></a>        index <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb132-42"><a href="#cb132-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb132-43"><a href="#cb132-43" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> graph</span>
<span id="cb132-44"><a href="#cb132-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb132-45"><a href="#cb132-45" aria-hidden="true" tabindex="-1"></a><span class="co"># Create the joint model</span></span>
<span id="cb132-46"><a href="#cb132-46" aria-hidden="true" tabindex="-1"></a>joint_graph <span class="op">=</span> construct_joint_time_model(<span class="dv">3</span>, <span class="fl">2.0</span>, <span class="fl">4.0</span>)</span>
<span id="cb132-47"><a href="#cb132-47" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Created joint model with </span><span class="sc">{</span>joint_graph<span class="sc">.</span>vertices_length()<span class="sc">}</span><span class="ss"> states"</span>)</span>
<span id="cb132-48"><a href="#cb132-48" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss">First few states (rabbits_left, rabbits_right, left_depleted, right_depleted):"</span>)</span>
<span id="cb132-49"><a href="#cb132-49" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">min</span>(<span class="dv">10</span>, joint_graph.vertices_length())):</span>
<span id="cb132-50"><a href="#cb132-50" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"  State </span><span class="sc">{</span>i<span class="sc">}</span><span class="ss">: </span><span class="sc">{</span>joint_graph<span class="sc">.</span>vertex_at(i)<span class="sc">.</span>state()<span class="sc">}</span><span class="ss">"</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>Created joint model with 24 states

First few states (rabbits_left, rabbits_right, left_depleted, right_depleted):
  State 0: [0 0 0 0]
  State 1: [3 0 0 0]
  State 2: [2 1 0 0]
  State 3: [0 0 1 0]
  State 4: [1 2 0 0]
  State 5: [0 1 1 0]
  State 6: [3 0 0 1]
  State 7: [2 0 0 1]
  State 8: [0 3 1 0]
  State 9: [0 2 1 0]</code></pre>
</div>
</div>
<p>Now we can use rewards to extract information about the joint distribution. By defining rewards that are non-zero only until each island is depleted, we can compute the marginal time until depletion for each island. By looking at the joint accumulated rewards, we can explore the correlation between these depletion times.</p>
<div id="cell-171" class="cell" data-execution_count="71">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb134"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb134-1"><a href="#cb134-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Define rewards: earn reward while island is not depleted</span></span>
<span id="cb134-2"><a href="#cb134-2" aria-hidden="true" tabindex="-1"></a>states <span class="op">=</span> joint_graph.states()</span>
<span id="cb134-3"><a href="#cb134-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb134-4"><a href="#cb134-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Reward 1: time spent before left depletion (left_depleted == 0)</span></span>
<span id="cb134-5"><a href="#cb134-5" aria-hidden="true" tabindex="-1"></a>reward_before_left_depletion <span class="op">=</span> (states[:, <span class="dv">2</span>] <span class="op">==</span> <span class="dv">0</span>).astype(<span class="bu">float</span>)</span>
<span id="cb134-6"><a href="#cb134-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb134-7"><a href="#cb134-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Reward 2: time spent before right depletion (right_depleted == 0)</span></span>
<span id="cb134-8"><a href="#cb134-8" aria-hidden="true" tabindex="-1"></a>reward_before_right_depletion <span class="op">=</span> (states[:, <span class="dv">3</span>] <span class="op">==</span> <span class="dv">0</span>).astype(<span class="bu">float</span>)</span>
<span id="cb134-9"><a href="#cb134-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb134-10"><a href="#cb134-10" aria-hidden="true" tabindex="-1"></a><span class="co"># Compute expectations</span></span>
<span id="cb134-11"><a href="#cb134-11" aria-hidden="true" tabindex="-1"></a>E_time_to_left_depletion <span class="op">=</span> joint_graph.expectation(reward_before_left_depletion)</span>
<span id="cb134-12"><a href="#cb134-12" aria-hidden="true" tabindex="-1"></a>E_time_to_right_depletion <span class="op">=</span> joint_graph.expectation(reward_before_right_depletion)</span>
<span id="cb134-13"><a href="#cb134-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb134-14"><a href="#cb134-14" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Expected time until left island depleted: </span><span class="sc">{</span>E_time_to_left_depletion<span class="sc">:.4f}</span><span class="ss">"</span>)</span>
<span id="cb134-15"><a href="#cb134-15" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Expected time until right island depleted: </span><span class="sc">{</span>E_time_to_right_depletion<span class="sc">:.4f}</span><span class="ss">"</span>)</span>
<span id="cb134-16"><a href="#cb134-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb134-17"><a href="#cb134-17" aria-hidden="true" tabindex="-1"></a><span class="co"># Compute covariance between the two times</span></span>
<span id="cb134-18"><a href="#cb134-18" aria-hidden="true" tabindex="-1"></a>cov <span class="op">=</span> joint_graph.covariance(reward_before_left_depletion, reward_before_right_depletion)</span>
<span id="cb134-19"><a href="#cb134-19" aria-hidden="true" tabindex="-1"></a>var_left <span class="op">=</span> joint_graph.variance(reward_before_left_depletion)</span>
<span id="cb134-20"><a href="#cb134-20" aria-hidden="true" tabindex="-1"></a>var_right <span class="op">=</span> joint_graph.variance(reward_before_right_depletion)</span>
<span id="cb134-21"><a href="#cb134-21" aria-hidden="true" tabindex="-1"></a>correlation <span class="op">=</span> cov <span class="op">/</span> np.sqrt(var_left <span class="op">*</span> var_right)</span>
<span id="cb134-22"><a href="#cb134-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb134-23"><a href="#cb134-23" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss">Covariance between depletion times: </span><span class="sc">{</span>cov<span class="sc">:.6f}</span><span class="ss">"</span>)</span>
<span id="cb134-24"><a href="#cb134-24" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Correlation: </span><span class="sc">{</span>correlation<span class="sc">:.4f}</span><span class="ss">"</span>)</span>
<span id="cb134-25"><a href="#cb134-25" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">The positive correlation indicates that when the left island takes longer to deplete,"</span>)</span>
<span id="cb134-26"><a href="#cb134-26" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"the right island also tends to take longer (rabbits jumping back and forth prolongs both)"</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>Expected time until left island depleted: 0.4836
Expected time until right island depleted: 0.4017

Covariance between depletion times: 0.131722
Correlation: 0.7704

The positive correlation indicates that when the left island takes longer to deplete,
the right island also tends to take longer (rabbits jumping back and forth prolongs both)</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>INFO: building reward compute graph...</code></pre>
</div>
</div>
<p>This framework for joint probabilities extends naturally to more complex scenarios. We can model multiple dependent processes, extract conditional distributions, and analyze the dependencies between different random variables in our model. The key is careful state space construction that encodes all relevant information, combined with judicious use of rewards to extract the quantities of interest. In population genetics applications, this approach is used to model the joint distribution of coalescence times across multiple loci or populations, capturing the complex dependencies induced by recombination and migration.</p>
<p>We can increase granularity for better performance:</p>
<div id="cell-174" class="cell" data-execution_count="72">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb137"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb137-1"><a href="#cb137-1" aria-hidden="true" tabindex="-1"></a>np.<span class="bu">sum</span>(graph.accumulated_visiting_time(<span class="fl">0.05</span>, granularity<span class="op">=</span><span class="dv">1000000</span>)<span class="op">*</span>graph.states()[:,<span class="dv">1</span>])</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display" data-execution_count="72">
<pre><code>np.float64(0.0011138317897953385)</code></pre>
</div>
</div>
</section>
</section>
<section id="building-the-state-space-in-c" class="level1">
<h1>Building the state space in C</h1>
<p>Very very large models can be take a long time to construct. So if you have deloped a model that you need to construct repeatedly, the library allow you to implement the state construction as a stand-alone C/C++ extension available as python module.</p>
<p>The C code building the state space for the rabit model looks like this:</p>
<pre class="{c}"><code>ptdalgorithms::Graph build(int starting_rabbits, float flooding_left, float flooding_right) {

    size_t state_size = 2;
    struct ptd_graph *graph = ptd_graph_create(state_size);
    struct ptd_avl_tree *avl_tree = ptd_avl_tree_create(state_size);
    int *initial_state = (int*)calloc(graph-&gt;state_length, sizeof(*initial_state));
    int *child_state = (int*)calloc(graph-&gt;state_length, sizeof(*initial_state));
    initial_state[0] = starting_rabbits;
    ptd_graph_add_edge(
            graph-&gt;starting_vertex,
            ptd_find_or_create_vertex(graph, avl_tree, initial_state),
            1
    );
    for (size_t k = 1; k &lt; graph-&gt;vertices_length; k++) {
        struct ptd_vertex *vertex = graph-&gt;vertices[k];
        int *state = vertex-&gt;state;
        if (state[0] &gt; 0) {
            memcpy(child_state, vertex-&gt;state, graph-&gt;state_length * sizeof(int));
            child_state[0] -= 1;
            child_state[1] += 1;

            ptd_graph_add_edge(
                    vertex,
                    ptd_find_or_create_vertex(graph, avl_tree, child_state),
                    1
            );
            memcpy(child_state, vertex-&gt;state, graph-&gt;state_length * sizeof(int));
            child_state[0] = 0;
            ptd_graph_add_edge(
                    vertex,
                    ptd_find_or_create_vertex(graph, avl_tree, child_state),
                    flooding_left
            );
        }
        if (state[1] &gt; 0) {
            memcpy(child_state, vertex-&gt;state, graph-&gt;state_length * sizeof(int));
            child_state[1] -= 1;
            child_state[0] += 1;
            ptd_graph_add_edge(
                    vertex,
                    ptd_find_or_create_vertex(graph, avl_tree, child_state),
                    1
            );
            memcpy(child_state, vertex-&gt;state, graph-&gt;state_length * sizeof(int));
            child_state[1] = 0;
            ptd_graph_add_edge(
                    vertex,
                    ptd_find_or_create_vertex(graph, avl_tree, child_state),
                    flooding_right
            );
        }
    }
    free(child_state);
    ptdalgorithms::Graph *result = new ptdalgorithms::Graph(graph, avl_tree);
    return *result;
}

To access the function from python, you need to put it a separate file (`rabbit_state_space.cpp`) with the header and footer shown below:

```{c}
#include &lt;pybind11/pybind11.h&gt;
#include &lt;ptdalgorithms.h&gt;
#include "stdint.h"
#include "stdlib.h"

namespace py = pybind11;
using namespace pybind11::literals;
/*******************************************/


/* Your build function goes here */


/********************************************/
PYBIND11_MODULE(rabbit_state_space, m) {     /* &lt;- NB: the model name must match the file name */
     m.def("build", &amp;build);
}

/*
&lt;%
setup_pybind11(cfg)
%&gt;
*/</code></pre>
<p>You can see the complete code in <a href="rabbit_state_space.cpp">rabbit_state_space.cpp</a>.</p>
<p>Then all you need to do is install cppimport</p>
<pre><code>pixi add cppimport</code></pre>
<p>or</p>
<pre><code>pip install cppimport</code></pre>
<p>and then run this code to import your build function.</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb142"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb142-1"><a href="#cb142-1" aria-hidden="true" tabindex="-1"></a><span class="co"># import ptdalgorithms</span></span>
<span id="cb142-2"><a href="#cb142-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> cppimport.import_hook</span>
<span id="cb142-3"><a href="#cb142-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> rabbit_state_space <span class="co"># this will pause for a moment to compile the module</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Then you can use it to construct your graph like this:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb143"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb143-1"><a href="#cb143-1" aria-hidden="true" tabindex="-1"></a>graph <span class="op">=</span> ptd.Graph(rabbit_state_space.build(<span class="dv">2</span>, <span class="dv">2</span>, <span class="dv">4</span>))</span>
<span id="cb143-2"><a href="#cb143-2" aria-hidden="true" tabindex="-1"></a>graph.plot()</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="inference" class="level1">
<h1>Inference</h1>
<section id="bayesian-inference-with-svgd-stein-variational-gradient-descent" class="level2">
<h2 class="anchored" data-anchor-id="bayesian-inference-with-svgd-stein-variational-gradient-descent">Bayesian Inference with SVGD (Stein Variational Gradient Descent)</h2>
<p>Having explored how to construct models, compute their properties, evaluate them efficiently, and scale computations across distributed clusters, we now turn to a fundamental question: given observed data, how do we estimate the parameters of our model? This is the domain of statistical inference. In a Bayesian framework, we seek not just point estimates but entire posterior distributions over parameters, quantifying our uncertainty about parameter values given the data we have observed.</p>
<p>Traditional Markov Chain Monte Carlo (MCMC) methods like Metropolis-Hastings and Hamiltonian Monte Carlo have been the workhorses of Bayesian inference for decades. However, these methods face challenges with high-dimensional parameter spaces, complex posterior geometries, and the need for many sequential samples to achieve convergence. Stein Variational Gradient Descent (SVGD) offers a compelling alternative. Instead of generating samples sequentially through a Markov chain, SVGD represents the posterior with a set of particles (parameter vectors) and updates these particles iteratively to move them toward the posterior distribution. The method combines ideas from optimization, kernel methods, and functional analysis to create a deterministic algorithm that is highly parallelizable and works well in high dimensions.</p>
<p>The key insight of SVGD is to treat inference as an optimization problem in the space of probability distributions. We start with an initial set of particles (typically drawn from the prior or from a simple distribution) and iteratively transport these particles toward the posterior using gradient information. Each particle interacts with all other particles through a kernel function, with the interaction strength depending on the distance between particles. This interaction ensures that particles spread out to cover the posterior distribution rather than collapsing to a single mode. The updates use gradients of the log-likelihood and log-prior, which we can compute efficiently using JAX’s automatic differentiation.</p>
<p>For our rabbit model, imagine we have observed data: the time until all rabbits died. Based on this observation, we want to estimate the three parameters of our model—jump rate, left flooding rate, and right flooding rate—along with quantifying our uncertainty about these parameters. We will set up a likelihood function, specify a prior distribution, and use SVGD to approximate the posterior distribution with a set of particles. This workflow showcases the entire pipeline: model construction, JAX integration, gradient-based inference, and (optionally) distributed computing. Now we need to define our inference problem in terms of a log-posterior function. According to Bayes’ theorem, the posterior is proportional to the likelihood times the prior: p(θ|data) ∝ p(data|θ) × p(θ). Taking logarithms gives us log p(θ|data) = log p(data|θ) + log p(θ) + constant. The SVGD algorithm requires us to provide a function that computes this log-posterior (up to an additive constant, which doesn’t affect gradients).</p>
<p>For the likelihood, we use the probability density function of our phase-type distribution evaluated at the observed times. For the prior, we will use independent log-normal distributions for each parameter, reflecting our prior belief that parameters are positive with uncertainty spanning orders of magnitude.</p>
<div id="cell-187" class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb144"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb144-1"><a href="#cb144-1" aria-hidden="true" tabindex="-1"></a><span class="co"># graph = </span></span>
<span id="cb144-2"><a href="#cb144-2" aria-hidden="true" tabindex="-1"></a><span class="co"># </span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p>The SVGD particles now represent our posterior distribution. Each particle is a plausible set of parameter values given the observed data, and the collection of particles approximates the full posterior. We can use these particles to compute posterior summaries (means, quantiles, credible intervals), make predictions, or perform model checking. The spread of the particles reflects our uncertainty—parameters with wide spread are less constrained by the data, while parameters with narrow spread are well-determined.</p>
<p>This inference workflow showcases the full power of the ptdalgorithms ecosystem. We constructed a complex stochastic model using graph-based state space representation. We parameterized it for efficient exploration of parameter space. We performed symbolic Gaussian elimination to enable ultra-fast repeated evaluation. We integrated with JAX for automatic differentiation and JIT compilation. We implemented a gradient-based inference algorithm (SVGD) that can be parallelized across devices and nodes. And we can scale this entire workflow to much larger problems—more complex models, more observations, more particles—by leveraging distributed computing.</p>
<p>For production inference runs, you would typically use more particles (100-1000), run for more iterations (1000-10000), use adaptive step sizes, monitor convergence diagnostics, and leverage the distributed computing infrastructure we described earlier to parallelize across many nodes. The combination of symbolic elimination (100× faster evaluation), distributed computing (100× more parallel evaluations), and gradient-based inference (100× fewer iterations than MCMC) can easily provide five or six orders of magnitude of speedup compared to naive approaches, transforming intractable problems into routine computations.</p>
<p>Modern computational infrastructure offers substantial computing power not just through faster processors, but through massive parallelism across multiple machines. A typical high-performance computing (HPC) cluster might have dozens to hundreds of compute nodes, each with dozens of CPU cores, representing thousands of processor cores working in parallel. For computationally intensive tasks like Bayesian inference, where we need to evaluate a complex model millions of times, this parallel computing power is transformative. What might take days on a single machine can complete in hours or minutes when distributed across a cluster.</p>
<p>The ptdalgorithms library is designed from the ground up to leverage this distributed computing infrastructure. Through tight integration with JAX’s distributed computing capabilities and support for SLURM (Simple Linux Utility for Resource Management), the standard job scheduler on HPC clusters, the library makes it straightforward to scale from running on your laptop to running on hundreds of nodes. The key insight is that many inference algorithms—particularly particle-based methods like Stein Variational Gradient Descent (SVGD)—are naturally parallel. Each particle can be evaluated independently, and gradients can be computed in parallel across all particles. With the right infrastructure, we can distribute these particles across many machines and aggregate results efficiently.</p>
<p>This section demonstrates how to set up and run distributed computations with ptdalgorithms. We will see how the library automatically detects whether it is running on a SLURM cluster, how it coordinates multiple processes across different nodes, and how JAX distributes computations across available resources. We will work with our rabbit model, showing how the combination of symbolic elimination (for fast per-particle evaluation) and distributed computing (for parallel particle evaluation) enables inference at scales that would be impossible on a single machine.</p>
<p>The workflow has three main components: (1) initialization, where we detect the distributed environment and set up JAX for multi-node computation; (2) model setup, where we construct our parameterized model and perform symbolic elimination; and (3) distributed evaluation, where we leverage JAX’s <code>pmap</code> (parallel map) to evaluate the model across all available devices in parallel. Let’s see each component in detail.</p>
</section>
<section id="distributed-computing" class="level2">
<h2 class="anchored" data-anchor-id="distributed-computing">Distributed Computing</h2>
<div id="cell-191" class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb145"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb145-1"><a href="#cb145-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb145-2"><a href="#cb145-2" aria-hidden="true" tabindex="-1"></a><span class="co"># code here</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stderr">
<pre><code>[INFO] Not running under SLURM - using single-node setup
[INFO] Configured JAX for 1 CPU devices
[INFO] JAX x64 precision enabled
[INFO] Single-node setup - no distributed initialization needed
[INFO] 
Distributed Configuration:
  Job ID: N/A
  Process: 0/1
  Coordinator: localhost:12345 (this node)
  Local devices: 1
  Global devices: 1
  Platform: cpu</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>Distributed computing initialized:</code></pre>
</div>
<div class="cell-output cell-output-error">
<div class="ansi-escaped-output">
<pre><span class="ansi-red-fg">---------------------------------------------------------------------------</span>
<span class="ansi-red-fg">AttributeError</span>                            Traceback (most recent call last)
<span class="ansi-cyan-fg">Cell</span><span class="ansi-cyan-fg"> </span><span class="ansi-green-fg">In[73]</span><span class="ansi-green-fg">, line 21</span>
<span class="ansi-green-fg">     14</span> dist_info = initialize_distributed(
<span class="ansi-green-fg">     15</span>     coordinator_port=<span class="ansi-green-fg">12345</span>,  <span style="font-style:italic;color:rgb(95,135,135)"># Port for process coordination</span>
<span class="ansi-green-fg">     16</span>     platform=<span class="ansi-yellow-fg">"</span><span class="ansi-yellow-fg">cpu</span><span class="ansi-yellow-fg">"</span>,           <span style="font-style:italic;color:rgb(95,135,135)"># or "gpu" for GPU clusters</span>
<span class="ansi-green-fg">     17</span>     enable_x64=<span style="font-weight:bold;color:rgb(0,135,0)">True</span>          <span style="font-style:italic;color:rgb(95,135,135)"># Enable 64-bit precision</span>
<span class="ansi-green-fg">     18</span> )
<span class="ansi-green-fg">     20</span> <span style="color:rgb(0,135,0)">print</span>(<span class="ansi-yellow-fg">f</span><span class="ansi-yellow-fg">"</span><span class="ansi-yellow-fg">Distributed computing initialized:</span><span class="ansi-yellow-fg">"</span>)
<span class="ansi-green-fg">---&gt; </span><span class="ansi-green-fg">21</span> <span style="color:rgb(0,135,0)">print</span>(<span class="ansi-yellow-fg">f</span><span class="ansi-yellow-fg">"</span><span class="ansi-yellow-fg">  Process rank: </span><span style="font-weight:bold;color:rgb(175,95,135)">{</span><span class="ansi-yellow-bg">dist_info</span><span class="ansi-yellow-bg">.</span><span class="ansi-yellow-bg">global_rank</span><span style="font-weight:bold;color:rgb(175,95,135)">}</span><span class="ansi-yellow-fg">"</span>)
<span class="ansi-green-fg">     22</span> <span style="color:rgb(0,135,0)">print</span>(<span class="ansi-yellow-fg">f</span><span class="ansi-yellow-fg">"</span><span class="ansi-yellow-fg">  Total processes: </span><span style="font-weight:bold;color:rgb(175,95,135)">{</span>dist_info.num_processes<span style="font-weight:bold;color:rgb(175,95,135)">}</span><span class="ansi-yellow-fg">"</span>)
<span class="ansi-green-fg">     23</span> <span style="color:rgb(0,135,0)">print</span>(<span class="ansi-yellow-fg">f</span><span class="ansi-yellow-fg">"</span><span class="ansi-yellow-fg">  Local devices: </span><span style="font-weight:bold;color:rgb(175,95,135)">{</span>dist_info.num_local_devices<span style="font-weight:bold;color:rgb(175,95,135)">}</span><span class="ansi-yellow-fg">"</span>)

<span class="ansi-red-fg">AttributeError</span>: 'DistributedConfig' object has no attribute 'global_rank'</pre>
</div>
</div>
</div>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/munch-group\.github\.io\/PtDAlgorithms\/");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="../../pages/getting_started.html" class="pagination-link" aria-label="Getting Started">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text">Getting Started</span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="../../pages/tutorials/coalescent_full_py_api_example.html" class="pagination-link" aria-label="Coalescent - Full API">
        <span class="nav-page-text">Coalescent - Full API</span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->
<script>var lightboxQuarto = GLightbox({"closeEffect":"zoom","descPosition":"bottom","loop":false,"openEffect":"zoom","selector":".lightbox"});
(function() {
  let previousOnload = window.onload;
  window.onload = () => {
    if (previousOnload) {
      previousOnload();
    }
    lightboxQuarto.on('slide_before_load', (data) => {
      const { slideIndex, slideNode, slideConfig, player, trigger } = data;
      const href = trigger.getAttribute('href');
      if (href !== null) {
        const imgEl = window.document.querySelector(`a[href="${href}"] img`);
        if (imgEl !== null) {
          const srcAttr = imgEl.getAttribute("src");
          if (srcAttr && srcAttr.startsWith("data:")) {
            slideConfig.href = srcAttr;
          }
        }
      } 
    });
  
    lightboxQuarto.on('slide_after_load', (data) => {
      const { slideIndex, slideNode, slideConfig, player, trigger } = data;
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(slideNode);
      }
    });
  
  };
  
})();
          </script>




</body></html>