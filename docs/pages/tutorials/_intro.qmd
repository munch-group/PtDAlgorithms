This comprehensive tutorial explores the complete Python API of the phasic library, a high-performance computational framework for working with phase-type distributions. At its core, the library implements sophisticated graph-based algorithms published in peer-reviewed literature, offering performance improvements of several orders of magnitude compared to traditional matrix-based approaches that have dominated the field for decades. The implementation leverages C for computational efficiency, with carefully designed bindings to Python through C++ and pybind11, ensuring that Python users can access near-native performance without sacrificing the convenience and flexibility of high-level scripting.

Throughout this tutorial, we will construct increasingly sophisticated models using a simple but illustrative example: rabbits living on two islands that can jump between islands and face periodic flooding events. This seemingly simple scenario will allow us to explore the full richness of the library's capabilities, from basic state space construction and moment calculations to advanced features like reward transformations, multivariate distributions, parameterized models, symbolic elimination for ultra-fast parameter sweeps, distributed computing across SLURM clusters, and Bayesian inference using Stein Variational Gradient Descent (SVGD).

The tutorial begins with fundamental operations—constructing state spaces, computing expectations and variances, evaluating distribution functions—and progressively builds toward advanced topics. We will see how to work with both continuous phase-type distributions (modeling time until absorption) and discrete phase-type distributions (modeling the number of transitions before absorption). We will explore rewards, which allow us to compute accumulated quantities along paths through the state space, and multivariate extensions that capture joint distributions of multiple quantities. We will learn how to parameterize edge weights, enabling efficient exploration of parameter space, and how symbolic elimination can accelerate this exploration by orders of magnitude.

In the advanced sections, we will discover how to leverage distributed computing infrastructure, scaling our computations from a single machine to hundreds of nodes on a SLURM cluster. We will see how the library integrates seamlessly with JAX, enabling automatic differentiation and GPU acceleration. Finally, we will apply these tools to Bayesian inference problems, using SVGD to estimate model parameters from observed data—a workflow that combines graph construction, symbolic elimination, distributed computing, and gradient-based optimization into a unified, high-performance pipeline.

By the end of this tutorial, you will have mastered not just the mechanics of the API, but the underlying concepts and workflows that make phasic a powerful tool for probabilistic modeling, statistical inference, and computational biology.