---
title: Phase-Type Distributions
---

# Introduction to Phase-Type Distributions

Phase-type distributions are a versatile class of probability distributions that model the time until absorption in a Markov chain. They can approximate virtually any positive-valued distribution and are particularly powerful for modeling complex stochastic processes.

## What are Phase-Type Distributions?

A **phase-type distribution** represents the time until a Markov process reaches an absorbing state. The process:

1. Starts in one of several **transient states** (phases)
2. Transitions between states according to a rate matrix
3. Eventually reaches an **absorbing state** (termination)

The time to absorption follows a phase-type distribution.

## Continuous vs Discrete

### Continuous Phase-Type (CPH)

Models **time** until absorption in a continuous-time Markov chain:

- Transitions occur at exponential rates
- Represents waiting times, lifetimes, or durations
- Example: Time until system failure, time to coalescence in population genetics

**Key properties:**
- State space: finite set of transient states + one absorbing state
- Transition rates: specified by rate matrix **T**
- Initial distribution: **α** (probabilities of starting states)

### Discrete Phase-Type (DPH)

Models **number of steps** until absorption in a discrete-time Markov chain:

- Transitions occur at discrete time steps
- Represents counts of events
- Example: Number of collisions before absorption, number of generations

**Key properties:**
- State space: finite set of transient states + one absorbing state
- Transition probabilities: specified by sub-transition matrix **T**
- Initial distribution: **α**

## Graph Representation

PtDAlgorithms uses a **graph-based representation** instead of matrices:

- **Vertices** represent states (integer vectors)
- **Edges** represent transitions with associated rates/probabilities
- **Graph algorithms** replace expensive matrix operations

### Advantages of Graph Representation

1. **Memory efficient**: Only stores existing transitions (sparse)
2. **Fast construction**: O(log n) state lookup using AVL trees
3. **Orders of magnitude faster**: Compared to traditional matrix methods
4. **Natural modeling**: Build state spaces incrementally

## Common Examples

### Exponential Distribution

The simplest phase-type distribution - just one transient state:

```python
import ptdalgorithms as ptd

graph = ptd.Graph(1)
start = graph.starting_vertex()
absorbing = graph.find_or_create_vertex([0])
start.add_edge(absorbing, rate=1.0)

print(f"Expectation: {graph.expectation()}")  # 1.0
```

### Erlang Distribution

Sum of k exponential distributions (k phases in sequence):

```python
graph = ptd.Graph(1)
start = graph.starting_vertex()

# Create chain of k=5 phases
k = 5
vertices = [start]
for i in range(k):
    v = graph.find_or_create_vertex([i + 1])
    vertices.append(v)

# Connect with rate λ=2
for i in range(k):
    vertices[i].add_edge(vertices[i + 1], weight=2.0)

print(f"Expectation: {graph.expectation()}")  # k/λ = 5/2 = 2.5
```

### Hyperexponential Distribution

Mixture of exponentials (parallel paths):

```python
graph = ptd.Graph(1)
start = graph.starting_vertex()
absorbing = graph.find_or_create_vertex([0])

# Two paths with different rates
path1 = graph.find_or_create_vertex([1])
path2 = graph.find_or_create_vertex([2])

# Mix probabilities
start.add_edge(path1, weight=0.7)
start.add_edge(path2, weight=0.3)

# Different rates
path1.add_edge(absorbing, weight=1.0)
path2.add_edge(absorbing, weight=5.0)
```

## Key Operations

### Moments

Compute expectation, variance, and higher moments:

```python
# First three moments
moments = graph.moments(3)
print(f"Expectation: {moments[0]}")
print(f"Second moment: {moments[1]}")
print(f"Third moment: {moments[2]}")

# Variance
var = graph.variance()

# Or compute directly
E = graph.expectation()
```

### Distribution Functions

Evaluate PDF, CDF, or PMF:

```python
import numpy as np

times = np.linspace(0, 10, 100)

# Continuous phase-type
pdf = graph.pdf(times)  # Probability density
cdf = graph.cdf(times)  # Cumulative distribution

# Discrete phase-type
graph.normalize()  # Convert to discrete
jumps = np.arange(0, 20)
pmf = graph.dph_pmf(jumps)  # Probability mass
```

### Rewards

Add rewards to compute multivariate distributions:

```python
# Define rewards (one per state)
rewards = np.array([0, 1, 2, 1, 0, 3, 2])

# Expectation of accumulated rewards
E_reward = graph.expectation(rewards)

# Or transform the distribution
reward_graph = graph.reward_transform(rewards)
E_reward2 = reward_graph.expectation()  # Same result
```

### Sampling

Generate random samples:

```python
# Sample 1000 waiting times
samples = graph.sample(1000)

# With rewards
samples_reward = graph.sample(1000, rewards)

# Verify via sampling
import numpy as np
print(f"Sample mean: {np.mean(samples)}")
print(f"True expectation: {graph.expectation()}")
```

## Advanced Features

### Parameterized Graphs

Edges can have parameterized rates for efficient parameter sweeps:

```python
# Build with parameterized edges
graph = ptd.Graph(state_length=2, parameterized=True)

# Edge states represent parameter indices/coefficients
vertex.add_edge(child, weight=0, parameterized_edge_state=[1.0, 0, 0])

# Update all edge weights from parameter vector
theta = np.array([2.0, 4.0, 1.5])
graph.update_weights_parameterized(theta)

# Recompute
E = graph.expectation()
```

### Symbolic Computation

For cyclic graphs, symbolic Gaussian elimination converts to acyclic form:

```python
# Build cyclic parameterized graph
graph = ptd.Graph(callback=my_callback, parameterized=True)

# Convert to symbolic acyclic form (one-time cost)
symbolic_graph = graph.symbolic_elimination()

# Now evaluation is extremely fast for any parameter values
for theta in parameter_grid:
    symbolic_graph.update_weights(theta)
    pdf = symbolic_graph.pdf(times)  # Much faster!
```

### JAX Integration

Convert graphs to JAX-compatible functions for automatic differentiation:

```python
import jax
import jax.numpy as jnp

# Convert to JAX function
pmf_fn = ptd.Graph.pmf_from_graph(graph, discrete=False)

# Now supports JAX transformations
pmf_fn_jit = jax.jit(pmf_fn)              # JIT compilation
pmf_fn_grad = jax.grad(pmf_fn)             # Automatic differentiation
pmf_fn_vmap = jax.vmap(pmf_fn)             # Vectorization
pmf_fn_pmap = jax.pmap(pmf_fn)             # Parallelization

# Use for inference
theta = jnp.array([1.0])
times = jnp.linspace(0, 5, 50)
pdf_values = pmf_fn(theta, times)
gradient = pmf_fn_grad(theta, times)
```

## Applications

### Population Genetics

Model coalescent processes, migration, recombination:

```python
def coalescent_callback(state, nr_samples=10):
    """Coalescent with n samples."""
    if not state.size:
        return [[[nr_samples], 1, [1]]]

    transitions = []
    if state[0] > 1:
        n = state[0]
        rate = n * (n - 1) / 2
        new = state.copy()
        new[0] -= 1
        transitions.append([new, 0, [rate]])
    return transitions

graph = ptd.Graph(callback=coalescent_callback,
                  parameterized=True,
                  nr_samples=10)
```

### Reliability Engineering

Model system failures with multiple components:

```python
# Series system: all components must work
# Parallel system: at least one must work
# Complex: mix of series and parallel
```

### Queueing Theory

Model service times, waiting times in queues:

```python
# M/M/1 queue, M/M/k queue
# Phase-type service times
# Customer arrival processes
```

## Learn More

- [State Space Construction](state_space_construction.ipynb) - Build complex models
- [Symbolic Elimination](symbolic_gauss_elimination.qmd) - Fast parameterized evaluation
- [SVGD Inference](svgd/svgd.ipynb) - Bayesian parameter inference
- [API Reference](../api/Graph.html) - Complete Graph class documentation

## References

Røikjer, T., Hobolth, A., & Munch, K. (2022). Graph-based algorithms for phase-type distributions. *Statistics and Computing*, 32, 91.
